<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>FuLucas's blog</title><meta name="description" content="Shifting eyes and vacancy coming."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/widget-post-list.css"><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">FuLucas's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><span>Tags · HIT-Software-Process-and-Tools</span></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><article class="post-container is-flex is-justify-content-center section container is-max-widescreen pt-4 px-2"><div class="columns is-variable is-1-tablet is-3-desktop-only is-2-widescreen is-full-width"><section class="column"><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211227195118410.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/02/Software%20Process%20and%20Tools/09%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211227195118410.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/02/Software%20Process%20and%20Tools/09%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">软件过程与工具——结构化设计</a></h2><time class="has-text-grey" datetime="2022-01-02T10:38:38.000Z">2022-01-02</time><p class="is-flex-grow-2 mt-2">结构化设计
一. 简介
1. 结构化设计的内容
结构化的系统设计主要考虑：模块的层次化、模块之间的接口、数据库设计、用户界面设计
为每个模块设计内部逻辑
采用自顶向下方法进行设计：具有系统自动化边界的DFD、结构图
2. 自动化系统边界划分

将数据流图划分为手工处理部分和系统能自动完成的部分
程序的处理过程可以在系统边界内部或外部
数据流可以在系统边界内部或外部
穿过系统界线的数据流代表了系统的输入和输出
在最终的系统中，数据流将成为用户界面中的表单、报表、供其他系统使用的数据文件等


image-20211227195118410

二. 结构图
1. 简介
结构图的定义：以模块为基础、以模块间的调用为关联所构成的图称为模块结构图，简称结构图。
结构图的作用： 层次化的方法来描述系统每部分的功能和子功..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/02/Software%20Process%20and%20Tools/09%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211224121404794.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/08%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211224121404794.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/08%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90/">软件过程与工具——软件需求与需求获取</a></h2><time class="has-text-grey" datetime="2022-01-01T15:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件需求与需求获取
一. 软件需求的定义
对用户需求的管理水平是决定软件成败的重要原因！
错误需求的扩散效应：错误的需求会导致之后的设计和编码等工作都是错误的

错误需求的修复代价：随着需求、设计、编码、测试、执行的过程代价增高（需求在出错之后会严重影响随后实现的系统）
根本原因：需求的鸿沟（期望差异）——开发者开发的与用户所想得到的软件存在着巨大期望差异！
！！！软件需求的定义： 以一种清晰、简洁、一致且无二义性的方式，描述用户对目标软件系统在功能、行为、性能、设计约束等方面的期望，是在开发过程中对系统的约束
需求是质量的基础

为软件项目的成本、时间、风险估计提供准确的依据
减少开发工作量，避免将时间与资源浪费在设计与实现错误的需求上
通过提供需求文档和需求基线，来有效的管理系统演化与变更
作为客户与开..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/08%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E4%B8%8E%E5%88%86%E6%9E%90/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211221203106899.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/06%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211221203106899.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/06%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/">软件过程与工具——软件演化与配置管理</a></h2><time class="has-text-grey" datetime="2022-01-01T14:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件演化与配置管理
一. 软件演化
1. Lifecycle of a software
Software Development Life Cycle (SDLC): From 0 to 1

Multiple versions in the life of a software: From 1 to n

软件演化Lehman定律

持续变化

环境变化产生软件修改，软件修改促进环境变化

复杂度逐渐增大

系统变化，结构和功能变复杂  难以维护并失去控制，无法继续演化  需要大量额外的资源和维护工作来保持系统的正常运行
软件修改引入新的错误，造成故障率升高


2. 软件演化的处理策略

软件维护

修改软件缺陷或增加新功能而对软件进行的变更
软件变更通常发生在局部，不会改变整个结构

软件再工程

..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/06%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211223120418441.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/07UML%E5%8F%8A%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211223120418441.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/07UML%E5%8F%8A%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/">软件过程与工具——UML及建模工具</a></h2><time class="has-text-grey" datetime="2022-01-01T14:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">UML及建模工具
一. UML简介
1. 模型及其作用

模型就是现实的简单化
模型的目的或用途：模型是为了更好地理解正在开发的系统：系统可视化、详细说明系统的结构或行为（e.g. 静态/动态结构、行为  时序描写）、指导构造系统的模板、决策进行文档化、构建物理实体前先测试、与客户交流、降低复杂度。
面向对象的建模：软件系统用对象（类）作为其构造单元（块）；class属性（静态）、方法（动态）

从问题空间或解空间的词汇中找出对象
类是对具有共同性质的一组对象的描述


2. UML介绍
UML——Unified Modeling Language 统一建模语言
UML 是一种对软件系统的制作过程/产出物进行下述工作的描述语言，这些工作包括：可视化（visualizing）、详述 （specifying）、..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/07UML%E5%8F%8A%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211221101701218.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/05%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211221101701218.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/05%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">软件过程与工具——软件项目管理</a></h2><time class="has-text-grey" datetime="2022-01-01T13:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件项目管理
一. 软件项目管理的案例

软件项目管理的挑战

在预定的范围、质量、时间和成本等约束条件下交付项目
通过优化资源（资金、人、原料、能源、空间等）的分配与集成来满足预先定义的目标

软件项目的特征

软件产品的不可见性  软件项目复杂和抽象
项目高度不确定性  预定计划和实际情况存在较大偏差
软件过程的多变化性  不确定、不稳定
软件人员的高技能及其高流动性  风险


软件项目管理的“4P”

image-20211221101701218


image-20211221101724398

二. 人员 People

软件项目的参与人员

高级管理者：负责定义业务问题（产品经理）
项目（技术）管理者：计划、激励、组织和控制软件开发人员（项目经理）
开发人员：拥有开发软件所需技能的人员

..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/05%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211220210615264.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/04%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%87%E7%A8%8B/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211220210615264.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/04%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%87%E7%A8%8B/">软件过程与工具——敏捷方法与过程</a></h2><time class="has-text-grey" datetime="2022-01-01T12:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">敏捷方法与过程
一. 敏捷过程模型
变化无处不在，难以预测变化何时发生，要在每一项开发活动中贯穿变化的意识
《敏捷软件开发宣言》

总结：小步快跑，及时反馈
本质：以快速的增量和迭代的方式进行软件开发

不强调文档而强调可运行软件片段
开发者与客户频繁沟通
快速开发，快速反馈，快速修改，增量交付
持续不断的短周期迭代
不看重形式和工具，看重人和内容，保持简洁


敏捷开发前期开发成本比传统开发过程高，而后期成本要比传统开发过程低
敏捷过程中最重要的因素：人
（这里的人应该指的是开发者和客户）

目前广泛使用敏捷开发方法论
略，包括极限编程和Scrum，XP是Scrum的基础
二. 极限编程（XP）

极限：把事情做到极致

了解客户需求  客户时时刻刻都在身边，时时了解需求
测试/单元测试提高质量  TDD..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/04%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%87%E7%A8%8B/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211220154212173.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/03%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211220154212173.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/03%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/">软件过程与工具——软件过程模型</a></h2><time class="has-text-grey" datetime="2022-01-01T11:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件过程模型
一. 软件过程

软件过程定义内容：人员与分工、所执行的活动、活动的细节和步骤
软件过程通过以下方式组织和管理软件生命周期：定义软件生产过程中的活动、定义这些活动的顺序及其关系
软件过程的目的：标准化、可预见性、提高开发效率、高质量产品，提升制定时间和预算计划的能力

黑盒测试与白盒测试（后面还会细讲，具体来说白盒测试知道代码怎么写的，可以根据代码来写测试）

image-20211220154212173


image-20211220154233917

软件过程的典型阶段：提出设想  深入调研  需求规格说明  软件设计  软件实现  软件部署  软件验证  软件演化
二. 典型软件过程模型
1. 瀑布模型（鲑鱼模型）
一旦向前一阶段就很难回溯
计划  需求分析  设计  编码  测试..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/03%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211219162059891.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/01%E6%A6%82%E8%AE%BA/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211219162059891.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/01%E6%A6%82%E8%AE%BA/">软件过程与工具——概论</a></h2><time class="has-text-grey" datetime="2022-01-01T10:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">第一章.概论
一. 软件的基本概念
1. 什么是软件
一个例子：简单计算的工具，自己孩子用小程序、全校学生用软件、放在网站上服务
规模越来越大，需求越来越复杂；难度越来越大，所需的时间越来越长；出错的概率也越来越大
1.1 软件的定义
软件(Software)：一组对象或项目所形成的一个“配置”，由程序、文档和数据等部分构成。

程序(program)：可被计算机硬件理解并执行的一组指令，提供期望的功能和性能
数据(data structure)：程序能正常操纵信息的数据结构
文档(document)：与程序开发、维护和使用有关的图文材料

程序只是软件的一部分
1.2 软件的四大特征

复杂性（complexity）

要解决的现实问题通常很复杂，数据、状态、逻辑关系的可能组合导致了软件本身的复杂性
软件..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/01%E6%A6%82%E8%AE%BA/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228162545278.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/10%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228162545278.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/10%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件过程与工具——软件测试</a></h2><time class="has-text-grey" datetime="2022-01-01T09:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件测试
一. 软件测试基础
传统：评估一个程序或系统的属性或能力，确定它是否符号其所需结果的活动
软件测试目的：在程序中找错误，检验是否满足需求。
程序交付测试之前，程序员可以找到和纠正超过99%的错误，软件测试的目的就是找到剩下的1%。

软件测试的原则

尽早的、不断的测试
程序员避免检查自己的程序
从小规模开始，逐渐到大规模
设计测试用例时，应该包括合理的输入和不合理的输入，以及各种边界条件
充分注意测试中的聚集现象：80%的错误由20%造成
对测试结果一定要有一个确认过程
严格的测试计划
注意回归测试的关联性（回归测试，小的改动一定要走一遍全部的测试）
妥善保存一切测试文档

测试用例：为特定目的而设计的一组测试输入、执行条件和预期的结果，最小的测试实体
测试用例的设计原则：代表性、可判定性、可再..</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/10%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">Read more</a></section></article><article class="post-item-card"><header class="is-relative is-flex"><div class="post-cover-backdrop is-hidden"><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211219221556475.png" alt="loading.."></div><a class="post-cover-link has-text-centered skeleton" href="/2022/01/01/Software%20Process%20and%20Tools/02%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"><img class="post-cover-img js-img-fadeIn" src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211219221556475.png" alt="loading.." data-backdrop="true"></a></header><section class="content post-card-content p-4 pb-5"><header><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h2 class="mt-4 mb-0 is-family-serif"><a href="/2022/01/01/Software%20Process%20and%20Tools/02%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/">软件过程与工具——软件工程核心思想</a></h2><time class="has-text-grey" datetime="2022-01-01T07:38:38.000Z">2022-01-01</time><p class="is-flex-grow-2 mt-2">软件工程核心思想
一. 软件工程的本质：不同抽象层次之间的映射与转换
1. 映射与转换
任何软件系统开发的共同本质在于：从现实空间的需求到计算机空间的软件代码之间的映射与转换

image-20211219221556475

2. 单步映射与多步映射

image-20211219221748916

软件工程本质：用严格的规范和管理手段来缩小偏差，通过牺牲“时间”来提高“质量”
3. 软件工程的两个映射

概念映射：问题空间的概念与解空间的模型化概念之间的映射（概念映射，类似于数据结构）

e.g. 学生成绩  Struct StudentScore (StudentNo, CourseNo, Score)

业务逻辑映射：问题空间的处理逻辑与解空间处理逻辑之间的映射（处理逻辑映射，类似于算法）

e...</p><a class="button is-default mt-2 has-text-weight-semibold" href="/2022/01/01/Software%20Process%20and%20Tools/02%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/">Read more</a></section></article></section><aside class="column is-hidden-mobile is-4-tablet is-3-widescreen"><div style="position: sticky; top: 50px;"><main class="aside-card-container tag-widget is-in-tag-page"><h3>Tags</h3><section><a href="/tags/HIT-Software-Construction"><span class="tag post-item-tag" style="margin-bottom: 5px;">HIT-Software-Construction</span></a><a href="/tags/HIT-CSAPP"><span class="tag post-item-tag" style="margin-bottom: 5px;">HIT-CSAPP</span></a><a href="/tags/HIT-Software-Process-and-Tools"><span class="tag post-item-tag" style="margin-bottom: 5px;">HIT-Software-Process-and-Tools</span></a><a href="/tags/Others"><span class="tag post-item-tag" style="margin-bottom: 5px;">Others</span></a></section></main></div></aside></div></article><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/FuLucas"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> FuLucas 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script>$claudia.fadeInImage(null, $claudia.blurBackdropImg)

window.addEventListener('resize', $claudia.throttle(function () {
    var images = document.querySelectorAll('.js-img-fadeIn')

    images.forEach($claudia.blurBackdropImg)
}, 150))</script></body></html>