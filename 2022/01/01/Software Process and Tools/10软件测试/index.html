<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>软件过程与工具——软件测试</title><meta name="description" content="Shifting eyes and vacancy coming."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="软件测试
一. 软件测试基础
传统：评估一个程序或系统的属性或能力，确定它是否符号其所需结果的活动
软件测试目的：在程序中找错误，检验是否满足需求。
程序交付测试之前，程序员可以找到和纠正超过99%的错误，软件测试的目的就是找到剩下的1%。

软件测试的原则

尽早的、不断的测试
程序员避免检查自己的程序
从小规模开始，逐渐到大规模
设计测试用例时，应该包括合理的输入和不合理的输入，以及各种边界条件
充分注意测试中的聚集现象：80%的错误由20%造成
对测试结果一定要有一个确认过程
严格的测试计划
注意回归测试的关联性（回归测试，小的改动一定要走一遍全部的测试）
妥善保存一切测试文档

测试用例：为特定目的而设计的一组测试输入、执行条件和预期的结果，最小的测试实体
测试用例的设计原则：代表性、可判定性、可再.."><meta name="generator" content="Hexo 6.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">FuLucas's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">软件过程与工具——软件测试</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80"><span class="toc-text">一. 软件测试基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.-%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-text">二. 测试过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-text">三. 测试方法分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4%E5%88%92%E5%88%86"><span class="toc-text">1. 按实施步骤划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E5%88%92%E5%88%86"><span class="toc-text">2. 按使用的测试技术划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%BD%AF%E4%BB%B6%E7%BB%84%E8%A3%85%E7%AD%96%E7%95%A5%E5%88%92%E5%88%86"><span class="toc-text">3. 按软件组装策略划分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">四. 黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 黑盒测试概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%96%B9%E6%B3%95"><span class="toc-text">2. 等价类划分方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-text">3. 边界值方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94.-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-text">五. 白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 白盒测试概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E8%A6%86%E7%9B%96%E6%A0%87%E5%87%86"><span class="toc-text">2. 白盒测试的覆盖标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B3%95"><span class="toc-text">3. 基本路径法</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">软件过程与工具——软件测试</h1><time class="has-text-grey" datetime="2022-01-01T09:38:38.000Z">2022-01-01</time><article class="mt-2 post-content"><h1 id="软件测试">软件测试</h1>
<h2 id="一.-软件测试基础">一. 软件测试基础</h2>
<p>传统：评估一个程序或系统的属性或能力，确定它是否符号其所需结果的活动</p>
<p><strong><em>软件测试目的：在程序中找错误，检验是否满足需求。</em></strong></p>
<p>程序交付测试之前，程序员可以找到和纠正超过99%的错误，软件测试的目的就是找到剩下的1%。</p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228162545278.png" alt="image-20211228162545278" style="zoom: 67%;"></p>
<p><strong><em>软件测试的原则</em></strong></p>
<ul>
<li><strong>尽早的</strong>、不断的测试</li>
<li>程序员<strong>避免检查自己的程序</strong></li>
<li>从小规模开始，逐渐到大规模</li>
<li>设计测试用例时，应该包括<strong>合理的输入和不合理的输入</strong>，以及各种<strong>边界条件</strong></li>
<li>充分注意测试中的聚集现象：80%的错误由20%造成</li>
<li>对测试结果一定要有一个确认过程</li>
<li>严格的测试计划</li>
<li>注意<strong>回归测试的关联性</strong>（回归测试，小的改动一定要走一遍全部的测试）</li>
<li>妥善保存一切<strong>测试文档</strong></li>
</ul>
<p><strong><em>测试用例：</em></strong>为特定目的而设计的一组<strong>测试输入、执行条件和预期的结果</strong>，最小的测试实体</p>
<p>测试用例的设计原则：代表性、可判定性、可再现性</p>
<h2 id="二.-测试过程">二. 测试过程</h2>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228163600032.png" alt="image-20211228163600032" style="zoom:80%;"></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228163635797.png" alt="image-20211228163635797" style="zoom:80%;"></p>
<h2 id="三.-测试方法分类">三. 测试方法分类</h2>
<h3 id="按实施步骤划分">1. 按实施步骤划分</h3>
<ul>
<li><strong><em><u>单元测试 Unit Testing</u></em></strong>
<ul>
<li>对软件<strong>基本组成单元</strong>进行测试，也称组件测试，以class为单位；一般是编写该单元的<strong><em>开发人员</em></strong>执行</li>
<li>测试环境：<strong>驱动模块（Driver）</strong>——被测模块的上一级模块，接收测试数据，把数据传送给所测模块，最后再输出实际测试结果，也就是被谁调用。<strong>桩模块（stub）</strong>——模拟被测单元所需要调用的其他函数接口，模拟实现子函数的某些功能，重要的是返回一个结果值。</li>
</ul></li>
<li><strong><em><u>集成测试 Integration Testing</u></em></strong>——满足<strong>软件设计文档</strong>
<ul>
<li>很多单元集成在一起 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container></span> 不能工作？</li>
<li>在单元测试的基础上，将所有模块按总体设计组装成子系统或系统，<strong>集成测试的对象是模块间的接口</strong></li>
<li><strong>集成测试的方法</strong>（具体案例见后）
<ul>
<li><strong>整体集成（非增量集成）</strong>：所有模块一次全部组装，进行整体测试
<ul>
<li>优点：效率高、工作量低、简单</li>
<li>缺点：错误<strong>难以定位和修改</strong>（修改时新旧错误混杂）、即使测试通过也会<strong>遗漏很多错误</strong></li>
</ul></li>
<li><strong>增量式集成测试</strong>：逐步将新模块加入测试
<ul>
<li><strong><em>自顶向下的增量集成：</em></strong>从主控模块开始，按软件的控制层次结构，以深度优先或广度优先的策略，逐步把各个模块集成在一起（每次只替代一个桩模块，不断进行回归测试）
<ul>
<li>优点：主要控制和决策机制较早测试；<strong>较少需要驱动模块</strong></li>
<li>缺点：<strong>桩模块数量巨大</strong>；测试高层模块，低层用桩模块替代没有反应真实情况，测试不充分</li>
</ul></li>
<li><strong><em>自底向上的增量集成：</em></strong>从软件结构最底层的模块开始组装测试
<ul>
<li>优点：<strong>不用桩模块</strong></li>
<li>缺点：<strong>难以建立信心</strong></li>
</ul></li>
<li><strong><em>三明治集成：</em></strong>一种混合增量式集成策略，综合了自顶向下和自底向上两种方法的优点</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong><em><u>确认测试 Validation Testing</u></em></strong>
<ul>
<li>检测软件能否按照合同要求进行工作，满足<strong>软件需求说明书</strong>的确认标准</li>
<li>确认测试一般是<strong>开发人员</strong>来做</li>
</ul></li>
<li><strong><em><u>系统测试 System Testing</u></em></strong>
<ul>
<li>系统测试是将<strong>已经集成好的软件系统</strong>作为一个元素，与计算机硬件、外设、某些支持软件、数据和人员等<strong>其他元素结合</strong>在一起，在<strong>实际运行环境</strong>下进行的一系列测试</li>
<li>功能测试（不管代码好坏）、压力测试（资源超负荷）、安全性测试、恢复测试（失败中恢复）、GUI测试、安装测试（目标环境中进行安装，用户亲自测试）</li>
</ul></li>
<li><strong><em><u>验收测试 Verification Testing</u></em></strong>
<ul>
<li><strong>以用户为主的测试</strong></li>
<li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.281ex" height="2.034ex" role="img" focusable="false" viewBox="0 -705 566 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"></path></g></g></g></svg></mjx-container></span> 测试
<ul>
<li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container></span> 是用户在<strong>开发环境</strong>下进行的测试</li>
<li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.281ex" height="2.034ex" role="img" focusable="false" viewBox="0 -705 566 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"></path></g></g></g></svg></mjx-container></span> 是用户在<strong>实际使用环境</strong>下进行的测试</li>
</ul></li>
</ul></li>
<li><strong><em><u>回归测试 Regression Testing</u></em></strong>
<ul>
<li>验证对系统的变更<strong>有没有影响以前的功能</strong>，并且保证当前功能的变更是正确的</li>
<li><strong>发生在软件测试的任何阶段</strong>，包括单元测试、集成测试和系统测试，频繁重复性劳动</li>
<li>范围：<strong>有选择性地</strong>执行以前地测试用例</li>
</ul></li>
</ul>
<h3 id="按使用的测试技术划分">2. 按使用的测试技术划分</h3>
<ul>
<li><p>静态测试：走查/评审</p></li>
<li><p>动态测试：白盒/黑盒</p></li>
</ul>
<h3 id="按软件组装策略划分">3. 按软件组装策略划分</h3>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228165259847.png" alt="image-20211228165259847" style="zoom:67%;"></p>
<ul>
<li><strong><em><u>非增量测试：整体集成</u></em></strong>
<ul>
<li><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228165336183.png" alt="image-20211228165336183" style="zoom: 80%;"></li>
</ul></li>
<li><strong><em><u>增量测试：自顶向下、自底向上、三明治（双向）</u></em></strong>
<ul>
<li><strong><em>自顶向下</em></strong>
<ul>
<li><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228165920464.png" alt="image-20211228165920464" style="zoom:80%;"></li>
</ul></li>
<li><strong><em>自底向上</em></strong>
<ul>
<li><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228170004185.png" alt="image-20211228170004185" style="zoom:80%;"></li>
</ul></li>
<li><strong><em>三明治</em></strong>
<ul>
<li><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228170022985.png" title="fig:" alt="image-20211228170022985"></li>
</ul></li>
</ul></li>
</ul>
<h2 id="四.-黑盒测试">四. 黑盒测试</h2>
<h3 id="黑盒测试概述">1. 黑盒测试概述</h3>
<p><strong>不考虑程序的内部逻辑结构和特性，只依据程序的需求规格说明书</strong></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228173120360.png" alt="image-20211228173120360" style="zoom:80%;"></p>
<p><strong>测试用例所覆盖的规格说明范围越大，就越优良</strong></p>
<p><strong>设计良好的测试用例，使之尽可能完全覆盖软件的规格说明</strong></p>
<h3 id="等价类划分方法">2. 等价类划分方法</h3>
<p><strong><em>等价类：</em></strong>输入数据的某个子集，<strong>子集内数据等价</strong>，假定”测试某等价类的代表值就等于对这一类的其他值的测试“</p>
<p>在每一个等价类中选取少量有代表性的数据作为测试的输入条件，就可以用少量代表性的测试数据，并取得较好的测试结果</p>
<p><strong><em>等价类划分基本原则：</em></strong>每个可能输入只属于一个等价类；用等价类某成员作为输入存在问题，用其他成员作为输入也能检测到同样的问题</p>
<ul>
<li><strong>有效等价类：</strong>对于程序的规格说明来说是 <strong>合理的、有意义的</strong>输入数据构成的集合（如，年龄0-100）</li>
<li><strong>无效等价类：</strong>对于程序的规格说明来说是 <strong>不合理的或无意义的</strong>输入数据构成的集合（如，年龄-1、200）
<ul>
<li>无效等价类至少一个，也可能多个</li>
<li>无效等价类的作用：可以用于程序对无理输入的应对</li>
</ul></li>
</ul>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228174333826.png" alt="image-20211228174333826" style="zoom:80%;"></p>
<p><strong><em>确定等价类的六大原则：</em></strong></p>
<ul>
<li>输入条件规定了<strong>取值范围或值</strong>的个数的情况下，则可以确立1个有效等价类和2个无效等价类
<ul>
<li><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228174445098.png" alt="image-20211228174445098" style="zoom:67%;"></li>
</ul></li>
<li>输入条件规定了<strong>输入值的集合</strong>或者规定了<strong>“必须如何”的条件</strong>的情况下，可确立1个有效等价类和1个无效等价类</li>
<li>输入条件是一个<strong>布尔量</strong>的情况下，可确定1个有效等价类和1个无效等价类</li>
<li>规定了输入数据的<strong>一组值（假定n个）</strong>、并且程序要对每一个输入值<strong>分别处理</strong>的情况下，可确立n个有效等价类和1个无效等价类</li>
<li>规定了输入数据必须遵守的规则的情况下，可确立1个有效等价类（符合规则）和n个无效等价类（从不同角度违反规则）</li>
<li>在确知已划分的等价类中各元素在程序<strong>处理中的方式不同</strong>的情况下，则应再将该等价类进一步的划分为更小的等价类</li>
</ul>
<p><strong><em>测试用例={测试数据+期望结果}</em></strong></p>
<p><strong><em>测试结果={测试数据+期望结果+实际结果}</em></strong></p>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228175027502.png" alt="image-20211228175027502"><figcaption aria-hidden="true">image-20211228175027502</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228175158430.png" alt="image-20211228175158430"><figcaption aria-hidden="true">image-20211228175158430</figcaption>
</figure>
<h3 id="边界值方法">3. 边界值方法</h3>
<p>边界值分析是<strong>等价类测试的特例</strong>，主要是考虑<strong>等价类的边界条件</strong>，在等价类的<strong>“边缘”选择元素</strong>。</p>
<p>大量的错误是发生在<strong>输入或输出范围的边界上</strong>，而不是发生在输入输出范围的内部</p>
<p>选取<strong><em>正好等于、刚刚大于、刚刚小于边界的值</em></strong>作为测试数据，而非选取等价类中的典型值作为测试数据</p>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228180213875.png" alt="image-20211228180213875"><figcaption aria-hidden="true">image-20211228180213875</figcaption>
</figure>
<p><strong><em><u>边界值分析的原则</u></em></strong></p>
<ul>
<li>如果输入条件<strong>规定了值的范围</strong>，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据（10公斤至50公斤，应取10、50、10.01、49.99、9.99及50.01等）<strong><em>边界及边界±r</em></strong></li>
<li>输入条件规定了值的个数，则用<strong>最大个数、最小个数</strong>、比最小个数少1,比最大个数多1的数据作为测试数据</li>
<li>将原则1和原则2应用于输出条件，即<strong>设计测试用例使输出值达到边界值及其左右的值</strong></li>
<li>程序的规格说明给出的<strong>输入域或输出域是有序集合</strong>，则应选取集合的<strong>第一个元素和最后一个元素</strong>作为测试用例</li>
<li>如果程序中使用了一个<strong>内部数据结构</strong>，则应当选择这个<strong>内部数据结构的边界</strong>上的值作为测试用例（如，a[0..n]，应该选取a[0]与a[n]作测试用例，栈选栈空、栈满作测试用例）</li>
<li>分析规格说明，找出其它可能的边界条件</li>
</ul>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228181004230.png" alt="image-20211228181004230"><figcaption aria-hidden="true">image-20211228181004230</figcaption>
</figure>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228180947276.png" alt="image-20211228180947276"><figcaption aria-hidden="true">image-20211228180947276</figcaption>
</figure>
<h2 id="五.-白盒测试">五. 白盒测试</h2>
<h3 id="白盒测试概述">1. 白盒测试概述</h3>
<p><strong><em>又称结构测试或逻辑驱动测试</em></strong></p>
<p>白盒测试更加充分，主要是程序员在使用</p>
<p><strong>白盒测试的目的：发现代码中的错误</strong></p>
<p><strong><em>白盒测试中的输入数据从程序结构导出，期望输出从需求规格中导出</em></strong></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183013943.png" alt="image-20211228183013943" style="zoom:80%;"></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183029678.png" alt="image-20211228183029678" style="zoom:80%;"></p>
<h3 id="白盒测试的覆盖标准">2. 白盒测试的覆盖标准</h3>
<p>最彻底的白盒测试是覆盖程序中的每一条路径，但是由于程序中一般含有循环，所以路径的数目极大，要执行每一条路径是不可能的，<strong>只能希望覆盖代码的程度尽可能高些</strong>。</p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183257672.png" alt="image-20211228183257672" style="zoom:80%;"></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183334520.png" alt="image-20211228183334520" style="zoom:80%;"></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183358054.png" alt="image-20211228183358054" style="zoom:88%;"></p>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228183410769.png" alt="image-20211228183410769"><figcaption aria-hidden="true">image-20211228183410769</figcaption>
</figure>
<p>若每个分支都有语句，那么语句覆盖=判定覆盖</p>
<p>条件覆盖不保证覆盖全部分支，即条件覆盖不包含判定覆盖，反之也是</p>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228184015675.png" alt="image-20211228184015675"><figcaption aria-hidden="true">image-20211228184015675</figcaption>
</figure>
<h3 id="基本路径法">3. 基本路径法</h3>
<p><strong><em>路径测试：</em></strong>设计足够多的测试用例，覆盖被测试对象中的<strong>所有可能路径</strong></p>
<p>测试中覆盖所有路径的组合是不现实的，把覆盖的路径数压缩到一定限度内，例如，程序中的循环体只执行一次</p>
<p><strong><em>基本路径测试：</em></strong> 在<strong>程序控制图</strong>的基础上，通过分析控制构造的环行复杂性，导出基本可执行路径集合，从而设计测试用例，使得每一个 <strong>基本独立路径</strong> 至少执行一次。步骤如下：</p>
<ul>
<li><strong>程序的控制流图</strong></li>
<li><strong>程序圈复杂度：</strong>确定程序中每个可执行语句至少执行一次所必须的<strong>测试用例数目的上界</strong>
<ul>
<li>流图中<strong>区域的数量</strong></li>
<li>给定流图G的圈复杂度V(G)，定义为<strong>V(G)=E-N+2，E是流图中的边数量，N是流图中节点数量</strong></li>
<li>给定流图G的圈复杂度V(G)，定义为<strong>V(G)=P+1，P是流图G中判定结点的数量</strong></li>
</ul></li>
<li><strong>导出测试用例</strong></li>
<li><strong>准备测试用例：</strong>确保基本路径集中的每一条路径的执行
<ul>
<li>测试用例 = {测试数据+期望结果}</li>
<li>测试数据是由路径和程序推论出来的；<strong>预期结果是从函数说明中导出</strong>，不能根据程序结构中导出</li>
</ul></li>
</ul>
<p><strong><em>控制流图</em></strong></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228185448686.png" alt="image-20211228185448686" style="zoom:80%;"></p>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228185524323.png" alt="image-20211228185524323" style="zoom:67%;"></p>
<ul>
<li>判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR) 连接的<strong>复合条件表达式</strong>，则需要<strong>改为一系列只有单条件的嵌套的判断</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228185728362.png" alt="image-20211228185728362" style="zoom:80%;"></p>
<figure>
<img src="https://raw.githubusercontent.com/FuLucas/image/main/2022/image-20211228185810590.png" alt="image-20211228185810590"><figcaption aria-hidden="true">image-20211228185810590</figcaption>
</figure>
<p><strong><em>独立路径（基本路径）：</em></strong>一条程序执行的路径，<strong>至少包含一条在定义该路径之前的其他基本路径中所不曾用过的边</strong>(即：至少引入程序的一个新处理语句集合或一个新条件)</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/01/Software%20Process%20and%20Tools/01%E6%A6%82%E8%AE%BA/" title="软件过程与工具——概论"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 软件过程与工具——概论</span></a><a class="button is-default" href="/2022/01/01/Software%20Process%20and%20Tools/02%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/" title="软件过程与工具——软件工程核心思想"><span class="has-text-weight-semibold">Next: 软件过程与工具——软件工程核心思想</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/FuLucas"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> FuLucas 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>