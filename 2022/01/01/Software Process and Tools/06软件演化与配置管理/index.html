<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>软件过程与工具——软件演化与配置管理</title><meta name="description" content="Shifting eyes and vacancy coming."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="软件演化与配置管理
一. 软件演化
1. Lifecycle of a software
Software Development Life Cycle (SDLC): From 0 to 1

Multiple versions in the life of a software: From 1 to n

软件演化Lehman定律

持续变化

环境变化产生软件修改，软件修改促进环境变化

复杂度逐渐增大

系统变化，结构和功能变复杂  难以维护并失去控制，无法继续演化  需要大量额外的资源和维护工作来保持系统的正常运行
软件修改引入新的错误，造成故障率升高


2. 软件演化的处理策略

软件维护

修改软件缺陷或增加新功能而对软件进行的变更
软件变更通常发生在局部，不会改变整个结构

软件再工程

.."><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">FuLucas's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">软件过程与工具——软件演化与配置管理</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-text">软件演化与配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.-%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96"><span class="toc-text">一. 软件演化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lifecycle-of-a-software"><span class="toc-text">1. Lifecycle of a software</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8C%96%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-text">2. 软件演化的处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4"><span class="toc-text">二. 软件维护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86scm"><span class="toc-text">三. 软件配置管理（SCM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text">1. 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2. 软件配置的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scm%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0"><span class="toc-text">3. SCM的基本元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9-ci"><span class="toc-text">3.1 配置项 CI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%BA%BF-baseline"><span class="toc-text">3.2 基线 Baseline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3.3 配置管理数据库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="toc-text">四. 持续集成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git%E4%B8%8Egithub"><span class="toc-text">Git与GitHub</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80.-%E6%9C%AC%E5%9C%B0-vs-%E9%9B%86%E4%B8%AD%E5%BC%8F-vs-%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">一. 本地 VS 集中式 VS 分布式版本控制系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C.-git%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">二. Git的基本思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89.-%E5%9F%BA%E6%9C%ACgit%E6%8C%87%E4%BB%A4"><span class="toc-text">三. 基本Git指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B.-git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8C%87%E4%BB%A4"><span class="toc-text">四. Git远程仓库指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94.-git%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4"><span class="toc-text">五. Git分支指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD.-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="toc-text">六. 远程分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83.-%E4%BD%BF%E7%94%A8git%E8%BF%9B%E8%A1%8C%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-text">七. 使用Git进行协同开发的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB.-github"><span class="toc-text">八. GitHub</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/HIT-Software-Process-and-Tools"><i class="tag post-item-tag">HIT-Software-Process-and-Tools</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">软件过程与工具——软件演化与配置管理</h1><time class="has-text-grey" datetime="2022-01-01T14:38:38.000Z">2022-01-01</time><article class="mt-2 post-content"><h1 id="软件演化与配置管理">软件演化与配置管理</h1>
<h2 id="一.-软件演化">一. 软件演化</h2>
<h3 id="lifecycle-of-a-software">1. Lifecycle of a software</h3>
<p><strong>Software Development Life Cycle (SDLC): From 0 to 1</strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211221203106899.png" alt="image-20211221203106899" style="zoom: 67%;"></p>
<p><strong>Multiple versions in the life of a software: From 1 to n</strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211221203333937.png" alt="image-20211221203333937" style="zoom:80%;"></p>
<p><strong><em>软件演化Lehman定律</em></strong></p>
<ul>
<li><strong>持续变化</strong>
<ul>
<li>环境变化产生软件修改，软件修改促进环境变化</li>
</ul></li>
<li><strong>复杂度逐渐增大</strong>
<ul>
<li>系统变化，结构和功能变复杂 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 难以维护并失去控制，无法继续演化 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 需要大量额外的资源和维护工作来保持系统的正常运行</li>
<li>软件修改引入新的错误，造成故障率升高</li>
</ul></li>
</ul>
<h3 id="软件演化的处理策略">2. 软件演化的处理策略</h3>
<ul>
<li><strong><em>软件维护</em></strong>
<ul>
<li><strong>修改软件缺陷</strong>或增加<strong>新功能</strong>而对软件进行的<strong>变更</strong></li>
<li>软件变更通常发生在<strong>局部</strong>，不会改变整个结构</li>
</ul></li>
<li><strong><em>软件再工程</em></strong>
<ul>
<li>避免软件退化而对软件的一部分进行<strong>重新设计、编码和测试</strong>，提高软件的可维护性和可靠性等</li>
</ul></li>
</ul>
<h2 id="二.-软件维护">二. 软件维护</h2>
<p><strong><em>软件维护的概念</em></strong>：软件产品发行和被投入运行使用之后对其的修改，以改正错误，改善性能或其他属性，从而使产品适应新的环境或新的需求</p>
<p><strong><em><u>软件维护的类型</u></em></strong></p>
<ul>
<li><strong><em>纠错性维护：</em></strong>开发时的测试不彻底，错误隐藏，特定环境暴露 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 诊断和改正错误（改正性维护）</li>
<li><strong><em>适应性维护：</em></strong>外部环境（硬软件配置）和数据环境（数据库、数据格式、输入输出方式、数据存储介质）变化 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 适应变化（适应性维护）</li>
<li><strong><em>完善性维护：</em></strong>用户提出的功能与性能要求 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 完善性维护</li>
<li><strong><em>预防性维护：</em></strong>提高软件的<strong>可维护性、可靠性</strong>等，为<strong>以后</strong>进一步改进软件打下良好基础</li>
</ul>
<p>几种维护活动中，<strong><em><u>完善性维护所占的比重最大</u></em></strong>，即大部分维护工作是改变和加强软件，而不是纠错</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222161751794.png" alt="image-20211222161751794" style="zoom: 67%;"></p>
<p><strong><em><u>软件维护的内容</u></em></strong></p>
<ul>
<li><strong><em>程序维护</em></strong></li>
<li><strong><em>数据维护</em></strong></li>
<li><strong><em>硬件维护</em></strong></li>
</ul>
<p><strong><em>软件维护的成本——极其昂贵</em></strong></p>
<ul>
<li>业务应用系统：维护成本与开发成本大体相同</li>
<li><strong>嵌入式实时系统：维护成本是开发成本的四倍以上</strong></li>
</ul>
<p><strong><em>软件维护的典型困难</em></strong></p>
<ul>
<li>软件维护中的大部分问题都可以归咎于<strong>软件规划和开发方法的缺陷</strong>：原开发人员程序难以读懂；人员流动，难以沟通；文档不足；软件设计时，欠考虑软件的可修改性；软件升级频繁，难以追踪演化</li>
</ul>
<p><strong>遗留系统：</strong>已经运行了很长时间的、对用户来说很重要的、但是目前已无法完全满足要求却不知道如何处理的软件系统（维护人员没有参与开发、不具备现有的开发规范、文档不完整） <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 更换有风险</p>
<h2 id="三.-软件配置管理scm">三. 软件配置管理（SCM）</h2>
<h3 id="背景">1. 背景</h3>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222162934146.png" alt="image-20211222162934146" style="zoom:67%;"></p>
<h3 id="软件配置的概念">2. 软件配置的概念</h3>
<p><strong><em>软件配置：</em></strong>由在软件工程过程中产生的<strong>所有信息项构成</strong>，可以看作该软件的具体形态（<strong>软件配置项</strong>）在某一时刻的<strong>瞬间映像</strong></p>
<p>SCI：软件配置项</p>
<p>SCM：软件配置管理（Software Configuration Management）——处理变更、保持软件系统的完整性，跟踪变更，保存系统在不同时间的状态；使混乱减到最小，对正在开发的软件进行标识、组织和控制</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222165140722.png" alt="image-20211222165140722" style="zoom:80%;"></p>
<p><strong><em>软件配置管理的目标：</em></strong>标识变更、控制变更、确保变更的正确实现、向开发组织内各角色报告变更</p>
<p><strong><em>当变更发生时，能够提高适应变更的容易程度，并且能够减少所花费的工作量</em></strong></p>
<h3 id="scm的基本元素">3. SCM的基本元素</h3>
<p><strong><em>配置项（Configuration Item, CI），基线（Baseline），配置管理数据库（CMDB），最终硬件库（Definitive Hardware Store, DHS），最终软件库（Definitive Software Library, DSL）</em></strong></p>
<h4 id="配置项-ci">3.1 配置项 CI</h4>
<p>软件过程的输出信息主要包括三个主要类别：<strong>计算机程序（源代码和可执行程序）、描述计算机程序的文档（针对技术开发者和用户）、数据（包含在程序内部或外部）</strong>。这些项包含了所有在软件过程中产生的信息，总称为软件配置项（SCI）。SCI是软件全生命周期内受管理和控制的基本单位，大到整个系统，小到某个硬件设备或软件模块。</p>
<p>SCI具有<strong>唯一的名称标识和多个属性</strong>：名称、描述、类型（模型元素、程序、数据、文档等）、项目标识符、关联关系、变更和版本信息</p>
<p><strong><em>配置项之间的依赖关系</em></strong></p>
<figure>
<img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222183927178.png" alt="image-20211222183927178"><figcaption aria-hidden="true">image-20211222183927178</figcaption>
</figure>
<ul>
<li><strong>整体-部分关系</strong>
<ul>
<li><strong>Data flow diagram (DFD) <part-of> analysis model</part-of></strong></li>
<li><strong>Analysis model <part-of> requirement specification</part-of></strong></li>
</ul></li>
<li><strong>关联关系</strong>
<ul>
<li><strong>Data model <interrelated> data flow diagram (DFD)</interrelated></strong></li>
<li><strong>Data model <interrelated> test case class m</interrelated></strong></li>
</ul></li>
<li>组成关系、组合关系</li>
</ul>
<p><strong><em>配置项的演变图</em></strong></p>
<p>在对象成为基线以前可能要做多次变更，在成为基线之后也可能需要频繁的变更；对于每一配置项都要建立一个演变图，以记录对象的变更历史。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222184547493.png" alt="image-20211222184547493" style="zoom:80%;"></p>
<h4 id="基线-baseline">3.2 基线 Baseline</h4>
<p><strong><em>基线的概念：</em></strong>已经通过 <strong>正式评审和批准</strong> 的软件规格说明或代码，可以作为进一步开发的基础，并且<strong>只有通过正式的变更规程才能修改基线</strong>，基线可以看作是软件开发过程中的“里程碑”。（软件配置项成为基线前，可以迅速而随意的进行变更）</p>
<p><strong><em>Version <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container></span> Release（内发布，相对正确的基线） <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container></span> Baseline <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container></span> Milestone <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.751ex" role="img" focusable="false" viewBox="0 -636 778 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g></g></g></svg></mjx-container></span> Checkpoint</em></strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222185513337.png" alt="image-20211222185513337" style="zoom:80%;"></p>
<p>基线是在某个时间点上对产品属性的一致描述，它是定义变化的基础？？？</p>
<figure>
<img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222185651825.png" alt="image-20211222185651825"><figcaption aria-hidden="true">image-20211222185651825</figcaption>
</figure>
<h4 id="配置管理数据库">3.3 配置管理数据库</h4>
<p><strong>配置管理数据库(CMDB，也称“SCM中心存储库”)</strong>，用于保存与软件相关的<strong>所有配置项</strong>的信息以及<strong>配置项之间关系</strong>的数据库——配置项及其版本号、变更可能影响到的配置项、配置项变更路线及轨迹、与配置项有关的变更内容、计划升级替换或弃用的配置项、不同配置项之间的关系（关联矩阵）</p>
<p>配置管理数据库 CMDB的功能：存储配置项及其之间的关系、版本控制、相关性跟踪和变更管理、需求跟踪、配置管理、审核跟踪</p>
<p><strong><em>版本控制</em></strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222190241021.png" alt="image-20211222190241021" style="zoom:67%;"></p>
<ul>
<li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container></span> 测试：开发环境下，由开发人员参与的测试</li>
<li><span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.281ex" height="2.034ex" role="img" focusable="false" viewBox="0 -705 566 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FD" d="M29 -194Q23 -188 23 -186Q23 -183 102 134T186 465Q208 533 243 584T309 658Q365 705 429 705H431Q493 705 533 667T573 570Q573 465 469 396L482 383Q533 332 533 252Q533 139 448 65T257 -10Q227 -10 203 -2T165 17T143 40T131 59T126 65L62 -188Q60 -194 42 -194H29ZM353 431Q392 431 427 419L432 422Q436 426 439 429T449 439T461 453T472 471T484 495T493 524T501 560Q503 569 503 593Q503 611 502 616Q487 667 426 667Q384 667 347 643T286 582T247 514T224 455Q219 439 186 308T152 168Q151 163 151 147Q151 99 173 68Q204 26 260 26Q302 26 349 51T425 137Q441 171 449 214T457 279Q457 337 422 372Q380 358 347 358H337Q258 358 258 389Q258 396 261 403Q275 431 353 431Z"></path></g></g></g></svg></mjx-container></span> 测试：开发环境，外部用户参与测试</li>
</ul>
<p><strong>SCM 软件配置管理常用工具</strong>：VSS (Microsoft Visual SourceSafe)、CVS (Concurrent Version System)、IBM Rational ClearCase、<strong>SVN (Subversion)、Git(GitHub、GitLab、GitEE)</strong></p>
<h2 id="四.-持续集成">四. 持续集成</h2>
<ul>
<li><strong><em>持续集成：敏捷开发的一项重要实践</em></strong>
<ul>
<li>每个成员每天<strong>至少集成一次</strong>（可能多次）</li>
<li>每次集成通过<strong>自动化的构建（包括编译、发布、自动化测试）</strong>来验证，从而尽快发现集成错误，大大减少集成的问题，让团队能够更快的开发内聚的软件</li>
</ul></li>
<li>价值
<ul>
<li><strong>减少风险</strong>：不是等到最后再做集成测试，而是<strong>每天都做测试</strong></li>
<li><strong>减少重复过程</strong>：通过<strong>自动化</strong>来实现</li>
<li>任何时间、任何地点生成<strong>可部署</strong>的软件</li>
<li>增强项目的<strong>可见性</strong></li>
<li>建立团队对开发产品的信心</li>
</ul></li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222191322283.png" alt="image-20211222191322283" style="zoom:80%;"></p>
<h1 id="git与github">Git与GitHub</h1>
<h2 id="一.-本地-vs-集中式-vs-分布式版本控制系统">一. 本地 VS 集中式 VS 分布式版本控制系统</h2>
<ul>
<li><strong>本地版本控制系统（Local VCS）</strong>：采用简单的 <strong>数据库或文件系统</strong> 来记录本地文件的<strong>历次更新差异</strong>。</li>
<li><strong>集中化的版本控制系统（Centralized VCS）</strong>：包括CVS、Subversion和Perforce等，有一个<strong>单一的集中管理服务器</strong>，保存所有文件的修订版本，而协同工作的开发者通过客户端连到这台服务器，取出<strong>最新</strong>的<strong>文件</strong>或者提交更新（不涉及版本信息）（<strong>有单点故障和可靠性问题</strong>）。</li>
<li><strong>分布式版本控制系统（Distributed VCS）</strong>：客户端并不只提取最新版本的文件快照，而是把<strong>原始的代码仓库完整地镜像下来</strong>；协同工作的某一服务器发生故障，都可以用任何一个镜像出来的本地仓库恢复。</li>
</ul>
<table>
<thead>
<tr class="header">
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222192840621.png" alt="image-20211222192840621"></th>
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222192844979.png" alt="image-20211222192844979"></th>
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222192850082.png" alt="image-20211222192850082"></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<h2 id="二.-git的基本思想">二. Git的基本思想</h2>
<p><strong><em><u>分布式版本控制工具</u></em></strong>——最开始是用于管理Linux内核的开发（绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上）</p>
<p>基本思想：其他大多数SCM系统则关心文件内容的具体差异（记录更新文件，以及更新哪些行的内容），而Git关心文件数据整体是否发生了变化（不保存这些前后变化的差异）</p>
<ul>
<li><strong>变化的文件</strong>作<strong>快照</strong>，记录在微型的文件系统中</li>
<li>提交更新，纵览全部文件的指纹信息并对文件作一快照，然后保存一个<strong>指向这次快照的索引</strong></li>
<li>若文件没有变化，Git不会再次保存，只<strong>对上次保存的快照作一链接</strong></li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222200003014.png" alt="image-20211222200003014" style="zoom:80%;"></p>
<p><strong><em>Git中文件的三种状态：</em></strong> <strong>已提交(committed)</strong>：文件已经被安全地保存在本地数据库中；<strong>已修改(modified)</strong>：文件被修改，还没提交保存；<strong>已暂存(staged)</strong>：把已修改的文件放在下次提交时要保存的清单中</p>
<p><strong><em>Git管理项目的三个工作区：</em></strong> <strong>Git目录（仓库，Git Directory）、工作目录（working directory）、暂存目录（staging area，本质上是一个文件，保存下次将要提交的文件列表信息）</strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222200609090.png" alt="image-20211222200609090" style="zoom:80%;"></p>
<p><strong><em>工作流程：</em></strong>在工作目录中修改某些文件 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 修改后的文件<strong>进行快照</strong>，保存到暂存区域 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 提交更新，将保存到暂存区域的文件快照永久转储到Git目录中</p>
<h2 id="三.-基本git指令">三. 基本Git指令</h2>
<ul>
<li><p>初始化新仓库执行git init命令</p></li>
<li><p>git add 命令告诉Git开始对这些文件进行跟踪（运行了git add之后又对相应文件做了修改，要重新git add，否则提交时只会提交add之前所做的修改）</p></li>
<li><p>提交 git commit</p>
<ul>
<li>git commit 加上-a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add步骤</li>
<li>git commit --amend撤销上一次提交，形成新的提交（本质：<strong>合并暂存区的修改和最近的一次commit的修改内容</strong>，用生成的新的commit替换掉原来的commit，而不会形成新的分支）</li>
<li>git reset HEAD^：工作区不变，<strong>暂存区回退到上一次commit之前</strong>，上一次commit取消</li>
</ul></li>
<li><p>git clone [URL]从远程服务器克隆特定的git仓库至本地</p></li>
<li><p>文件当前处于什么状态，用git status命令</p>
<ul>
<li><strong># On branch master nothing to commit (working directory clean) </strong> 当前没有任何跟踪着的文件，也没有任何文件在上次提交后更改过</li>
<li><strong># On branch master # Untracked files: …</strong> 有未跟踪的文件，使用git add开始跟踪一个新文件</li>
<li><strong># On branch master # Changes to be committed: </strong> 有处于已暂存状态的文件</li>
</ul></li>
<li><p>查看具体修改了什么地方，可以用git diff命令</p>
<ul>
<li><strong>git diff</strong> ，比较工作目录中当前文件和暂存区域快照之间的差异，（修改之后但未加入暂存）</li>
<li><strong>git diff --cached</strong>，比较暂存区域内的文件的更改（修改之后加入缓存但尚未提交，与上次提交时的快照差异）</li>
<li><strong>git diff HEAD</strong>，已缓存和未缓存的所有差异</li>
<li><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222203634211.png" alt="image-20211222203634211" style="zoom:80%;"></li>
</ul></li>
<li><p>git reset [files] 重置文件的暂存状态，把文件从暂存区移除，使得暂存区版本和仓库版本一致、</p></li>
<li><p>git checkout把文件从暂存区复制到工作目录，丢弃自上一次git add以来的所有本地修改</p></li>
<li><p>git checkout HEAD命令将最后一次提交的结果复制到工作目录和暂存区，丢弃了本地修改</p></li>
<li><p>git rm命令从暂存区域中移除，并从工作目录中删除指定的文件（不从工作目录中删除用 git rm --cached）</p></li>
<li><p>git log查看git项目的提交历史，进行统计分析</p>
<ul>
<li>不加任何参数：会按提交时间列出所有的commit，最近的排在最上面，包含SHA-1校验和、作者的名字和电子邮件地址、提交时间以及提交说明</li>
<li>-p参数：显示每次提交的内容差异(针对每个变化了的文件，增加了哪些行、删除了哪些行)</li>
<li>--stat参数：查看每次commit的简要统计信息，列出所有被修改过的文件及总数量、每个被修改过的文件有多少行发生变化等</li>
<li>--pretty=format:… 按特定格式展示commit的结果(格式化输出)</li>
<li>--graph：以图形方式展示commit的历史</li>
</ul></li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222211322457.png" alt="image-20211222211322457" style="zoom:80%;"></p>
<h2 id="四.-git远程仓库指令">四. Git远程仓库指令</h2>
<p><strong><em>远程仓库：托管在网络上的Git项目仓库</em></strong></p>
<ul>
<li>添加远程仓库
<ul>
<li><strong>git</strong> <strong>clone</strong>，指令在克隆远程仓库内容到本地之后，自动生成了一个远程仓库配置(origin)</li>
<li><strong>git remote add <shortname> <url></url></shortname></strong>，添加一个新的远程Git仓库，同时指定一个缩写</li>
</ul></li>
<li>查看已配置的远程仓库
<ul>
<li><strong>git</strong> <strong>remote</strong>：获取当前配置的所有远程仓库</li>
<li><strong>git</strong> <strong>remote –v:</strong> 显示当前配置的远程仓库及其读写操作权限(fetch, push)和URL地址</li>
<li><strong>git</strong> <strong>remote show [remote-name]</strong>：查看某个远程仓库的详细信息</li>
</ul></li>
<li>git remote rm pb：从本地移除远程仓库 (不再关注其更新、不再对其有贡献)</li>
<li>git remote rename pb pb1：将远程仓库重命名</li>
<li>git fetch：从远程仓库抓取数据到本地，获取本地仓库尚未拥有的全部更新
<ul>
<li>如果本地仓库有了不同的修改，则需要手工将本地修改与远程仓库的修改合并起来(分支的合并git merge)</li>
</ul></li>
<li>git pull == git fetch + git merge：获取远程仓库的更新并与本地当前分支合并</li>
<li>git push [remote-name] [branch-name]：将本地仓库中的数据推送到远程仓库</li>
</ul>
<h2 id="五.-git分支指令">五. Git分支指令</h2>
<p>在 git 中提交时，会保存一个提交(commit)对象，该对象<strong>包含一个指向暂存内容快照的指针</strong>，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针</p>
<p><strong><em>Git中的分支本质上仅仅是个指向 commit 对象的可变指针</em></strong></p>
<p>新提交节点中的所有文件都会被复制到暂存区域和工作目录中；只存在于老的提交节点中的文件会被删除</p>
<ul>
<li>git branch列出当前所有分支</li>
<li>git branch (name) 在当前commit对象上新建一个分支指针</li>
<li>git使用一个叫做HEAD的特别指针来获知你当前在哪个分支上工作</li>
<li>要切换到其他分支，可以执行git checkout命令</li>
<li>创建一个新的分支并立即切换过去：git branch –b</li>
<li>删除一个分支：git branch –d</li>
<li>使用git log –decorate查看当前各个分支所指的commit对象</li>
</ul>
<figure>
<img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222221210782.png" alt="image-20211222221210782"><figcaption aria-hidden="true">image-20211222221210782</figcaption>
</figure>
<figure>
<img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222221226032.png" alt="image-20211222221226032"><figcaption aria-hidden="true">image-20211222221226032</figcaption>
</figure>
<p>如果在不同的分支中都修改了同一个文件的同一部分，Git无法干净地把两者合到一起，使用<strong>git status查看任何包含未解决冲突的文件</strong>，在有冲突的文件里加入标准的冲突解决标记，可以通过它们来<strong>手工定位并解决这些冲突</strong></p>
<p><strong><em><u>分支合并的本质</u></em></strong></p>
<ul>
<li><strong>被合并的分支是当前commit对象的祖父节点</strong>，那么合并命令将什么也不做</li>
<li><strong>当前commit是被合并分支的祖父节点</strong>，就导致fast-forward合并；指向只是简单的移动，并生成一个新<strong>的提交</strong></li>
<li>默认把当前commit对象和被合并的分支，以及他们的共同祖父commit节点进行<strong>一次三方合并</strong></li>
</ul>
<table>
<thead>
<tr class="header">
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222222429399.png" alt="image-20211222222429399"></th>
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222222434284.png" alt="image-20211222222434284"></th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p><strong><em>分支的衍合/变基（rebase）</em></strong></p>
<p><strong>merge</strong>：把两个父分支合并进行一次提交，提交历史不是线性的</p>
<p><strong>rebase</strong>：在当前分支上<strong>重演另一个分支的历史</strong>，提交历史是线性的——保持提交历史的整洁</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2022/image-20211222222741305.png" alt="image-20211222222741305" style="zoom:80%;"></p>
<p><strong><em>利用分支进行开发的工作流程</em></strong></p>
<ul>
<li><strong>长期分支</strong>：稳定master；develop或next后续开发或稳定性测试 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></span> 进入稳定状态合并至master（拥有不同层次的<strong>稳定性</strong>：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去 ）</li>
<li><strong>特性分支（Topic）</strong>：短期的、用来实现单一特性或与其相关工作的分支（开发工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关）</li>
</ul>
<h2 id="六.-远程分支">六. 远程分支</h2>
<p>使用“(远程仓库名)/(分支名)”表示</p>
<p>只能看，不能修改</p>
<p>git push origin --delete serverfix 从origin远程仓库上删除serverfix的远程分支</p>
<h2 id="七.-使用git进行协同开发的实例">七. 使用Git进行协同开发的实例</h2>
<h2 id="八.-github">八. GitHub</h2>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/01/01/Software%20Process%20and%20Tools/07UML%E5%8F%8A%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/" title="软件过程与工具——UML及建模工具"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: 软件过程与工具——UML及建模工具</span></a><a class="button is-default" href="/2022/01/01/Software%20Process%20and%20Tools/05%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" title="软件过程与工具——软件项目管理"><span class="has-text-weight-semibold">Next: 软件过程与工具——软件项目管理</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/FuLucas"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> FuLucas 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>