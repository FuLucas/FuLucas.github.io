<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件构造笔记六：ADT抽象数据类型</title>
      <link href="/2021/07/04/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
      <url>/2021/07/04/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>抽象数据类型</strong> </font></p><p><font color="red"> <strong>表示泄露</strong> </font></p><p><font color="red"> <strong>AF</strong> </font></p><p><font color="red"> <strong>RI</strong> </font></p></blockquote><h1 id="Abstraction-and-User-Defined-Types-抽象和用户定义的类型"><a href="#Abstraction-and-User-Defined-Types-抽象和用户定义的类型" class="headerlink" title="Abstraction and User-Defined Types 抽象和用户定义的类型"></a>Abstraction and User-Defined Types 抽象和用户定义的类型</h1><p>抽象类型：强调“作用于数据上的操作”，程序员和client<strong>无需关心数据如何具体存储</strong>的，只需设计/使用<strong>操作</strong>即可。</p><p>ADT是由操作定义的，与其内部如何实现无关！</p><h1 id="2-Classifying-Types-and-Operations-分类类型和操作"><a href="#2-Classifying-Types-and-Operations-分类类型和操作" class="headerlink" title="2 Classifying Types and Operations 分类类型和操作"></a>2 Classifying Types and Operations 分类类型和操作</h1><p>可变类型的对象：提供了可改变其内部数据的值的操作。不变数据类型： 其操作不改变内部值，而是<strong>构造新的对象</strong></p><ul><li><font color="red"> Creator 构造器 </font> 可以将对象作为参数，但是不能把对象类型作为构造对象。(t* -&gt; T)</li><li><font color="red"> Producer 生产器 </font> 例如 String 的 contact 方法，将两个两个字符串连接为一个新的字符串。(T+, t* -&gt; T)</li><li><font color="red"> Observer 观察器 </font> 参看数据，例如 size() 方法。(T+, t* -&gt; t)</li><li><font color="red"> Mutator 变值器 </font> 改变对象属性的方法，例如 List 的 add() 方法。(T+, t* -&gt; void | t | T)</li></ul><p>其中T代表抽象类型，t代表其他类型。</p><h2 id="creator-构造器"><a href="#creator-构造器" class="headerlink" title="creator 构造器"></a>creator 构造器</h2><p>A creator is either implemented as a <strong>constructor</strong> , like new ArrayList(), or simply <strong>a static method</strong> instead, like Arrays.asList(), List.of(). 构造器：可能实现为构造函数或静态函数。</p><p>factory method 工厂方法：a creator implemented as a static method.</p><h2 id="mutator-变值器"><a href="#mutator-变值器" class="headerlink" title="mutator 变值器"></a>mutator 变值器</h2><p>变值器通常返回 void，变值器也可能返回非空类型。</p><h1 id="3-Abstract-Data-Type-Examples"><a href="#3-Abstract-Data-Type-Examples" class="headerlink" title="3 Abstract Data Type Examples"></a>3 Abstract Data Type Examples</h1><p><strong>只有 mutable 数据类型才有 mutator（这改变具体的对象）</strong></p><table><thead><tr><th>数据类型</th><th>Operations</th></tr></thead><tbody><tr><td>int(immutable)</td><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144710.jpg" alt="int"></td></tr><tr><td>String(immutable)</td><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144754.jpg" alt="String"></td></tr><tr><td>List(mutable)</td><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144741.jpeg" alt="List"></td></tr></tbody></table><h1 id="4-Designing-an-Abstract-Type-设计抽象类型"><a href="#4-Designing-an-Abstract-Type-设计抽象类型" class="headerlink" title="4 Designing an Abstract Type 设计抽象类型"></a>4 Designing an Abstract Type 设计抽象类型</h1><p>设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约 spec.</p><ol><li>Rules of thumb 1 设计简洁、一致的操作</li><li>Rules of thumb 2 要足以支持client对数据所做的所有操作需要，且用操作满足client需要的难度要低</li></ol><h1 id="5-Representation-Independence-表示独立性"><a href="#5-Representation-Independence-表示独立性" class="headerlink" title="5  Representation Independence 表示独立性 "></a>5 <font color="red"> Representation Independence 表示独立性 </font></h1><p><strong>表示独立性</strong>：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。</p><p>抽象类型的使用与其表示（用于实现它的实际数据结构或数据字段）无关，因此表示的更改不会影响抽象类型本身之外的代码。</p><p>除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示——spec规定了client和implementer之间的契约。</p><h1 id="6-Testing-an-Abstract-Data-Type"><a href="#6-Testing-an-Abstract-Data-Type" class="headerlink" title="6 Testing an Abstract Data Type"></a>6 Testing an Abstract Data Type</h1><ul><li>测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；</li><li>测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。</li></ul><h1 id="7-Invariants-不变性"><a href="#7-Invariants-不变性" class="headerlink" title="7 Invariants 不变性"></a>7 Invariants 不变性</h1><p>不变量 Invariant：在任何时候总是true，immutability 就是一个典型的“不变量”（一旦被创建始终表示相同的值），不变量由ADT来负责。</p><p>Invariants：(1) <strong>private</strong>（限制只能在<strong>类中</strong>访问的 fields 和方法）; (2) immutable type; (3) 对于 mutable 外部引用可以直接改变属性的值，所以考虑 copy; (4) final（保证在构造对象后不会重新分配此不可变类型的字段）。当代价很高时，将不变性交给用户（写到规约），但由此引发的bug会很多。</p><p>representation exposure 表示泄露：类以外的代码也能直接地修改表示。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示。</p><p>除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。最好的办法就是使用 immutable 的类型，彻底避免表示泄露（例如用 java.time.ZonedDateTime 而不是 mutable java.util.Date）</p><ul><li>Don’t incorporate mutable parameters into object; make defensive copies</li><li>Return defensive copies of mutable fields…</li><li>Or return unmodifiable view of mutable fields</li><li>Real lesson – use immutable components, to eliminate the need for defensive copying</li></ul><h1 id="8-Rep-Invariant-and-Abstraction-Function-RI-AF"><a href="#8-Rep-Invariant-and-Abstraction-Function-RI-AF" class="headerlink" title="8  Rep Invariant and Abstraction Function (RI AF) "></a>8 <font color="red"> Rep Invariant and Abstraction Function (RI AF) </font></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记五：设计规约</title>
      <link href="/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>规约的强度及其比较</strong> </font></p><p><font color="red"> <strong>如何写出好的规约</strong> </font></p></blockquote><h1 id="Functions-amp-methods-in-programming-languages"><a href="#Functions-amp-methods-in-programming-languages" class="headerlink" title="Functions &amp; methods in programming languages"></a>Functions &amp; methods in programming languages</h1><p>返回值类型是否匹配、参数类型是否匹配，在静态类型检查阶段完成</p><p>使用“方法”的客户端，无需了解方法内部（方法体信息隐藏）具体如何工作—“抽象”。</p><h1 id="2-Specification-Programming-for-communication"><a href="#2-Specification-Programming-for-communication" class="headerlink" title="2 Specification: Programming for communication"></a>2 Specification: Programming for communication</h1><p>API：应用程序编程接口</p><h2 id="Documenting-in-programming"><a href="#Documenting-in-programming" class="headerlink" title="Documenting in programming"></a>Documenting in programming</h2><p>“假设”写什么？变量的数据类型定义、final关键字定义了设计决策-“不可改变”、方法假设策略</p><p>为什么写？：自己记不住、别人不懂</p><p>编程时注意两点目标：代码中蕴含的“设计决策”–给编译器读；注释形式的“设计决策”–给自己和别人读。就是依据假设来进行编程，编程过程需要考虑编译器和读者两部分人。</p><h2 id="Specification-and-Contract-of-a-method"><a href="#Specification-and-Contract-of-a-method" class="headerlink" title="Specification and Contract (of a method)"></a>Specification and Contract (of a method)</h2><p>Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守：输入输出的数据类型、功能和正确性、性能（只讲能做什么，不讲怎么实现）</p><h2 id="Behavioral-equivalence-行为等价性"><a href="#Behavioral-equivalence-行为等价性" class="headerlink" title=" Behavioral equivalence 行为等价性 "></a><font color="red"> Behavioral equivalence 行为等价性 </font></h2><p>怎么判断是否行为等价性：是否可以用一种实现替代另一种实现（站在客户端视角，前置条件和后置条件）</p><p>根据规约判断行为等价性</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144614.jpg" alt="BehaviorEquivalence"></p><h2 id="Specification-structure-pre-condition-and-post-condition"><a href="#Specification-structure-pre-condition-and-post-condition" class="headerlink" title="Specification structure: pre-condition and post-condition"></a>Specification structure: pre-condition and post-condition</h2><p>方法规约包含几个条文：</p><ol><li>Precondition 前置条件：对<strong>客户</strong>端的约束，在使用方法时必须满足的条件（参数），indicated by the keyword <code>requires</code></li><li>Postcondition 后置条件：对<strong>开发者</strong>的约束，方法结束时必须满足的条件（返回值），indicated by the keyword <code>effects</code></li><li>Exceptional behavior 异常行为：如果违反先决条件它会做什么。契约–如果前置条件满足了，后置条件必须满足（可以通过抛出异常、修改或不修改对象等来遵循后置条件）；如果前置条件不满足，则方法可以做任何事。</li></ol><p>Java 的静态类型声明是一种规约，可据此进行静态类型检查static checking。方法前的注释也是一种规约，但需人工判定其是否满足。前置条件前置条件写进参数 <code>@param</code>，后置条件结果<code>@return, @throws</code></p><p>方法的规约不应该谈论方法的局部变量或方法类的私有字段。</p><p>除非在后置条件里声明过，否则方法内部<strong>不应该改变输入参数</strong>，应尽量不改变输入参数，尽量不设计mutating的spec，<strong>应该尽量避免使用mutable的对象</strong>，否则就容易引发bugs、降低可变性、复杂化规约。（多个引用指向同一个对象，任意一个引用修改其他的也会引起变化）。</p><h2 id="Testing-and-verifying-specifications"><a href="#Testing-and-verifying-specifications" class="headerlink" title="Testing and verifying specifications"></a>Testing and verifying specifications</h2><p>依据规约进行黑盒测试（不依赖具体实现，但测试必须遵守契约）。</p><h1 id="Designing-specifications"><a href="#Designing-specifications" class="headerlink" title=" Designing specifications "></a><font color="red"> Designing specifications </font></h1><h2 id="Classifying-specifications"><a href="#Classifying-specifications" class="headerlink" title="Classifying specifications"></a>Classifying specifications</h2><p>规约的确定性（输出）、规约的陈述性（输出什么或怎么得到输出）、规约的强度（合法实现的多少）</p><p><font color="red"> <strong>规约强度越高 (Stronger)，则可以用规约强度高的来代替强度弱的，那么如何比较强度？</strong> </font></p><p>更放松的前置条件+更严格的后置条件</p><p>越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻（输入内容约束更少）。</p><p><em>下面是两个可以比较、不能比较规约强弱的实例</em></p><table><thead><tr><th>无法比较</th><th>后者更强</th></tr></thead><tbody><tr><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144631.jpeg"></td><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144637.jpg" alt="StrongerVSWeakerSpecs2"></td></tr></tbody></table><h2 id="Diagramming-specifications-制图规约"><a href="#Diagramming-specifications-制图规约" class="headerlink" title="Diagramming specifications 制图规约"></a>Diagramming specifications 制图规约</h2><p>某个具体实现，若满足规约，则落在其范围内；否则，在其之外。程序员可以在规约的范围内自由选择实现方式，客户端无需了解具体实现。<strong>更强的规约，表达为更小的区域</strong></p><ul><li>更强的后置条件意味着实现的自由度更低了-&gt;在图中的面积更小</li><li>更弱的前置条件意味着实现时要处理更多的可能输入，实现的自由度低了-&gt;面积更小</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144645.jpg" alt="DiagrammingSpecifications"></p><h2 id="Designing-good-specifications"><a href="#Designing-good-specifications" class="headerlink" title="Designing good specifications"></a>Designing good specifications</h2><ol><li><strong>内聚coherent</strong>：Spec描述的功能应单一、简单、易理解</li><li><strong>strong enough</strong>：太弱的spec，client不放心、不敢用 (因为没有给出足够的承诺)。开发者应尽可能考虑各种特殊情况，在post-condition给出处理措施。</li><li><strong>weak enough</strong>：太强的spec，在很多特殊情况下难以达到，给开发者增加了实现的难度。</li><li><strong>use abstract types</strong>：在规约里使用<strong>抽象类型</strong>，可以给方法的实现体与客户端更大的自由度。在Java中这意味着使用接口类型，像 Map、Reader 而不是具体实现类型像 HashMap、FileReader。</li><li><strong>Precondition or postcondition</strong>：是否使用前置条件取决于(1) check的代价；(2) 方法的使用范围。如果只在类的内部使用该方法(private)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client；如果在其他地方使用该方法(public)，那么必须要使用前置条件，若client端不满足则方法抛出异常。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记四：数据类型与类型检验</title>
      <link href="/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>数据数据类型及定义，检测方式</strong> </font></p><p><font color="red"> <strong>Mutable, Immutable</strong> </font></p><p><font color="red"> <strong>snapshot图解析数据类型</strong> </font></p></blockquote><h1 id="1-Data-type-in-programming-languages-数据类型"><a href="#1-Data-type-in-programming-languages-数据类型" class="headerlink" title="1 Data type in programming languages 数据类型"></a>1 Data type in programming languages 数据类型</h1><p>A type is a <strong>set of values</strong>, along with <strong>operations</strong> that can be performed on those values. 数据类型 = <strong>一组</strong>值 + 可执行操作</p><ul><li>primitive types 基本数据类型：int, long, boolean, double, char</li><li>object types 对象数据类型：String, BigInteger</li><li>Java 约定：基本数据类型是小写字母开头，对象数据类型是大写字母开头</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144329.jpg" alt="PrimitiveObject"></p><p>对象类型层次结构：root is Object, all non-primitives are objects 继承关系</p><h1 id="2-Static-vs-dynamic-data-type-checking"><a href="#2-Static-vs-dynamic-data-type-checking" class="headerlink" title="2 Static vs. dynamic data type checking"></a>2 Static vs. dynamic data type checking</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换向下兼容</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">2</span>; <span class="comment">// a = 2.0(Implicit)</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">18.7</span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></tbody></table></figure><p>Java 是静态类型语言</p><p>变量的类型在编译时（在程序运行之前）已知，因此编译器也可以推断出所有表达式的类型（编译阶段进行类型检查）。</p><p>动态类型语言像 Python，这种检测将推迟到程序运行阶段。</p><h2 id="Static-Checking-and-Dynamic-Checking"><a href="#Static-Checking-and-Dynamic-Checking" class="headerlink" title="Static Checking and Dynamic Checking"></a>Static Checking and Dynamic Checking</h2><ul><li><strong>静态类型检查</strong>：在程序运行前自动发现错误。往往是关于类型的检测，不考虑值。</li><li><strong>动态类型检查</strong>：必须运行程序，通过某种约束条件，对变量的值检测。往往是关于值的检测。</li><li><strong>无检查</strong> </li><li><strong>动态类型检查 &gt;&gt; 静态 &gt;&gt; 无检查</strong>，静态检测能检测就没必要用动态。</li></ul><p>静态类型检查：可在<strong>编译阶段（编译器的工作）</strong>发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。静态类型可以防止一大类错误，例如应用于<strong>错误类型的参数</strong>所导致的错误， “5” * “6” 字符串类型乘法这个错误在编程时被捕获。</p><h3 id="静态类型检测能检测什么？"><a href="#静态类型检测能检测什么？" class="headerlink" title="静态类型检测能检测什么？"></a>静态类型检测能检测什么？</h3><p><strong>考虑编程过程会报哪些错误</strong></p><ul><li>Syntax errors 语法错误</li><li>Wrong names 类名/函数名错误</li><li>Wrong number of arguments 参数数目错误</li><li>Wrong argument types 参数类型错误：例如Type mismatch: cannot convert from int to boolean</li><li>Wrong return types 返回值类型错误</li><li>final变量，不被编译器相信只赋值了一次</li></ul><h3 id="动态类型检测能检测什么？"><a href="#动态类型检测能检测什么？" class="headerlink" title="动态类型检测能检测什么？"></a>动态类型检测能检测什么？</h3><ul><li>Illegal argument values 非法的参数值：例如divide-by-zero</li><li>Unrepresentable return values 非法的返回值，即特定的返回值不能用类型表示</li><li>Out-of-range indexes 越界</li><li>Calling a method on a null object reference. 空指针</li></ul><h1 id="3-Mutability-and-Immutability"><a href="#3-Mutability-and-Immutability" class="headerlink" title=" 3 Mutability and Immutability  "></a><font color="red"> 3 Mutability and Immutability  </font></h1><p>这是一个对”类“的概念，基本数据类型无效</p><ul><li>改变一个变量：将该变量指向另一个值的<strong>存储空间</strong>。</li><li>改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的<strong>值</strong>。</li></ul><p>Immutable types: 一旦被创建，其<strong>值</strong>不能改变。</p><p>Java中基本数据类型一定是Immutable的。如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变。</p><p><strong>final</strong>保证了引用不变性，<strong>immutable</strong>是限制存储空间内容的不变性。</p><p>如果 Java 编译器不相信 final 变量在运行时只会被赋值一次，那么它就会产生一个<strong>编译器</strong>错误。 所以 final 提供了对不可变引用的静态检查。</p><p>尽可能多的用 final 来声明方法输入参数和作为局部变量</p><ul><li>A final <strong>class</strong> declaration cannot be inherited. final class 不能被继承/无法派生</li><li>A final <strong>variable</strong> always contains the same value/reference but cannot be changed. final变量无法改变值/引用</li><li>A final method cannot be overridden by subclasses. final方法无法被子类重写，只能继承</li></ul><p>String 类型是 immutable 类型，StringBuilder 是 mutable 类型</p><table><thead><tr><th>String</th><th>StringBuilder</th></tr></thead><tbody><tr><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144347.jpg" alt="String"></td><td><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144357.jpg" alt="StringBuilder"></td></tr><tr><td>String s = “a”;</td><td>StringBuilder sb = new StringBuilder(“a”);</td></tr><tr><td>s = s.contact(“b”);</td><td>sb.append(“b”);</td></tr></tbody></table><p>当只有一个引用指向该值其实没什么区别，但是多个引用时就体现了区别。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144418.jpg" alt="MulitReferences"></p><p>Immutable 类型，频繁修改会产生大量的临时拷贝(需要垃圾回收)。</p><p>Mutable 类型最少化拷贝以<strong>提高效率性能</strong>。</p><p>Immutable 类型更“<strong>安全</strong>”。</p><p>避免由mutable类型带来的错误：</p><ol><li>defensive copy：防御式拷贝，给客户端返回一个全新对象，可能造成大量的内存浪费</li><li>使用不可变类型，则节省了频繁复制的代价</li></ol><p>安全的使用可变类型：局部变量，不会涉及共享；只有一个引用</p><p>对同一个可变对象如果有多个引用（别名），就非常不安全</p><h1 id="4-Snapshot-diagram-as-a-code-level-run-time-and-moment-view"><a href="#4-Snapshot-diagram-as-a-code-level-run-time-and-moment-view" class="headerlink" title=" 4 Snapshot diagram as a code-level, run-time, and moment view "></a><font color="red"> 4 Snapshot diagram as a code-level, run-time, and moment view </font></h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144443.jpg" alt="SnapshotRule1"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144449.jpg" alt="SnapshotRule2"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144455.jpg" alt="SnapshotRule3"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144505.jpg" alt="SnapshotRule4"></p><p>An immutable/unreassignable reference to a mutable value：引用是不可变的，但指向的值却可以是可变的，例如：final StringBuilder sb</p><p>A mutable/reassignable reference to an immutable value：可变的引用，也可指向不可变的值，例如：String s</p><h1 id="5-Complex-data-types-Arrays-and-Collections"><a href="#5-Complex-data-types-Arrays-and-Collections" class="headerlink" title="5 Complex data types: Arrays and Collections"></a>5 Complex data types: Arrays and Collections</h1><p>List, Set, Map 都是接口</p><p>Iterator as a <strong>mutable</strong> type 迭代器：next()，hasNext()</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144432.jpg" alt="Iterator"></p><p>List和迭代器都属于mutable，上图中用迭代器来循环删除某个对象，后面的对象会向前对齐。</p><p><a href="https://fhdfhd.cn/software-construction/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/">关于迭代和循环</a></p><h1 id="6-Useful-immutable-types"><a href="#6-Useful-immutable-types" class="headerlink" title="6 Useful immutable types"></a>6 Useful immutable types</h1><ul><li>基本类型及其封装对象类型都是不可变的</li><li>Don’t use mutable Date, </li><li>Collections types – List, Set, Map are all mutable.</li><li>包装器来获得 unmodifiable 不可变 collections：例如，<code>List S = Collections.unmodifiableList(t);</code>。这种不可变是在运行阶段获得的，编译阶段无法静态检查，并且只是增加了一个新的相同引用，对<code>t</code>修改也会报错。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashSet</title>
      <link href="/2021/06/29/HashSet/"/>
      <url>/2021/06/29/HashSet/</url>
      
        <content type="html"><![CDATA[<h1 id="HashSet添加元素时如何保证不重复"><a href="#HashSet添加元素时如何保证不重复" class="headerlink" title="HashSet添加元素时如何保证不重复"></a>HashSet添加元素时如何保证不重复</h1><p>调用 <code>add（Object</code> 方法时，首先会调用 Object 的 <code>hashCode</code> 方法判 hashCode 是否已经存在 HashCode 相同的元素，如不存在则直接插入元素；如果已存在，则调用 Object 对象的 equals 方法判断是否返回true， 如果为 true 则说明元素已经存在，如为false则插入元素。</p><p><strong>可以认为HashMap的key是不能重复的，而这里HashSet的元素是作为了map的key，所以也不能重复。</strong></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104050.png" alt="image-20210718104050829"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210914180928.png" alt="image-20210914180921174"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java静态实例方法</title>
      <link href="/2021/06/29/Java%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2021/06/29/Java%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>类可以有两种类型的方法：<strong>实例方法（非静态方法）和类（静态方法）方法</strong>。实例方法用于实现类的实例的行为，只能在类的实例的上下文中调用。类方法用于实现类本身的行为，类方法总是在类的上下文中执行，但也能在类的实例的上下文中调用。</p><p>用静态修饰符(static)定义类方法，若缺少则为实例方法。</p><h1 id="静态方法和实例方法的调用"><a href="#静态方法和实例方法的调用" class="headerlink" title="静态方法和实例方法的调用"></a>静态方法和实例方法的调用</h1><ol><li>外部调用静态方法时：<em>类名.方法名/对象名.方法名</em>；调用实例方法：<em>对象名.方法名</em>，即<strong>调用静态方法不需要创建对象</strong>。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticMethod</span> </span>{</span><br><span class="line">    <span class="comment">// a static method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callStatic</span><span class="params">()</span> </span>{</span><br><span class="line">   　　 System.out.println(<span class="string">"static method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">invokeStaticMethod</span> </span>{</span><br><span class="line">   　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">      　　staticMethod.callStatic(); <span class="comment">// no object</span></span><br><span class="line">      　　staticMethod s = <span class="keyword">new</span> staticMethod();  <span class="comment">// create an object</span></span><br><span class="line">      　　s.callStatic(); <span class="comment">// call the static method through the object</span></span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制,可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记九：面向复用的软件构造技术</title>
      <link href="/2021/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/"/>
      <url>/2021/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="Software-Reuse"><a href="#Software-Reuse" class="headerlink" title="Software Reuse"></a>Software Reuse</h1><p>优点：降低成本和开发时间；经过充分测试，可靠、稳定；标准化，在不同应用中保持一致。</p><p>缺点：开发可复用的软件（性能差，缺少针对性）和使用已有软件进行开发（需要适配）都需要代价。</p><p><strong>measure “reusability”</strong>：复用的机会有多频繁；复用的代价有多大（搜索、获取，适配、扩展，实例化，与软件其他部分的互连的难度）</p><p>最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用（包括需求、规约spec、数据、测试用例、文档等）</p><ul><li><p>Source code level: methods, statements, etc (lowest level)</p></li><li><p>Module level: class and interface</p></li><li><p>Library level: API (Java Library, .jar)</p></li><li><p>Architecture level: framework 框架</p></li><li><p>白盒复用：源代码可见，可修改和扩展（继承）。复制已有代码到正在开发的系统，进行修改；Pro：可定制化程度高；Con：对其修改增加了软件的复杂度，且需要对其内部充分的了解。</p></li><li><p>黑盒复用：源代码不可见，不能修改（委托）。 只能通过API接口来使用，无法修改代码；Pro：简单清晰；Con：适应性差。</p></li></ul><p>框架：一组具体类、抽象类、及其之间的连接关系。开发者根据framework的规约，填充自己的代码进去，形成完整系统。</p><p>Whitebox frameworks 白盒框架，通过代码层面的继承和动态绑定进行框架扩展。</p><p>Blackbox frameworks 黑盒框架，通过实现特定接口/delegation进行框架扩展。</p><h1 id="Designing-reusable-classes"><a href="#Designing-reusable-classes" class="headerlink" title=" Designing reusable classes "></a><font color="red"> Designing reusable classes </font></h1><blockquote><p><font color="red"> <strong>Behavioral subtyping 行为子类型与 Liskov 可替换原则 (LSP)</strong> </font></p><p><font color="red"> <strong>委托与组合</strong> </font></p></blockquote><h2 id="Behavioral-subtyping-and-Liskov-Substitution-Principle-LSP"><a href="#Behavioral-subtyping-and-Liskov-Substitution-Principle-LSP" class="headerlink" title="Behavioral subtyping and Liskov Substitution Principle (LSP)"></a>Behavioral subtyping and Liskov Substitution Principle (LSP)</h2><h3 id="行为子类型"><a href="#行为子类型" class="headerlink" title="行为子类型"></a>行为子类型</h3><p><strong>Compiler-enforced rules in Java (static type checking)</strong></p><ul><li>子类型可以增加方法，但不可删</li><li>子类型需要实现抽象类型中的所有未实现方法</li><li>子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance（协方差）的参数</li><li>子类型中重写的方法必须使用同样类型的参数或者符合contra-variance（反方差）的参数</li><li>子类型中重写的方法不能抛出额外的异常</li></ul><p>指定行为（方法）</p><ul><li>更强的不变量</li><li>更弱的前置条件</li><li>更强的后置条件</li></ul><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144822.jpg" alt="LSP"></p><p>Covariance 协变：父类型-&gt;子类型：越来越具体specific或者不变（返回值类型、异常的类型）。<code>@override</code> </p><p>Contravariance 反协变、逆变：父类型-&gt;子类型：越来越抽象或者不变（参数类型）。目前Java中遇到这种情况，当作<strong>overload</strong>看待。</p><p>Arrays are covariant 协变的：an array of type T[] may contain elements of type T or any subtype of T</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP FinalHomeWork</title>
      <link href="/2021/06/24/CSAPP-FinalHomeWork/"/>
      <url>/2021/06/24/CSAPP-FinalHomeWork/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105653.jpg" alt="image002"></p><h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a><strong>计算机系统</strong></h1><h2 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a><strong>大作业</strong></h2><table><thead><tr><th>题 目</th><th>程序人生-Hello's P2P</th></tr></thead><tbody><tr><td>专 业</td><td>计算机</td></tr><tr><td>学 号</td><td>1190202105</td></tr><tr><td>班 级</td><td>1903002</td></tr><tr><td>学 生</td><td>傅浩东</td></tr><tr><td>指导教师</td><td>郑贵滨</td></tr></tbody></table><h2 id="计算机科学与技术学院"><a href="#计算机科学与技术学院" class="headerlink" title="计算机科学与技术学院"></a><strong>计算机科学与技术学院</strong></h2><p><strong>2021年6月</strong></p><p><strong>摘 要</strong></p><p>摘要是论文内容的高度概括，应具有独立性和自含性，即不阅读论文的全文，就能获得必要的信息。摘要应包括本论文的目的、主要内容、方法、成果及其理论与实际意义。摘要中不宜使用公式、结构式、图表和非公知公用的符号与术语，不标注引用文献编号，同时避免将摘要写成目录式的内容介绍。</p><p><strong>关键词：</strong> hello；程序的一生；预处理；编译；汇编；链接；进程管理；存储管理；I/O管理</p><p>本文在Ubuntu系统下，通过介绍hello程序从编写到最终运行结束的过程来深入了解计算机系统，利用 linux 中的工具进行查看和解析，理解计算机内部机制，加深对计算机系统的理解。hello的一生主要经过预处理，编译，汇编，链接，再结合进程管理，存储管理，I/O管理完成程序的一生。</p><p><strong>目 录</strong></p><p><strong><a href="#_Toc75464192">第 1 章 概述 - 4 -</a></strong></p><p><a href="#_Toc75464193">1.1 Hello简介 - 4 -</a></p><p><a href="#_Toc75464194">1.2 环境与工具 - 4 -</a></p><p><a href="#_Toc75464195">1.3 中间结果 - 4 -</a></p><p><a href="#_Toc75464196">1.4 本章小结 - 5 -</a></p><p><strong><a href="#_Toc75464197">第 2 章 预处理 - 6 -</a></strong></p><p><a href="#_Toc75464198">2.1 预处理的概念与作用 - 6 -</a></p><p><a href="#_Toc75464199">2.2在Ubuntu下预处理的命令 - 6 -</a></p><p><a href="#_Toc75464200">2.3 Hello的预处理结果解析 - 7 -</a></p><p><a href="#_Toc75464201">2.4 本章小结 - 8 -</a></p><p><strong><a href="#_Toc75464202">第 3 章 编译 - 9 -</a></strong></p><p><a href="#_Toc75464203">3.1 编译的概念与作用 - 9 -</a></p><p><a href="#_Toc75464204">3.2 在Ubuntu下编译的命令 - 9 -</a></p><p><a href="#_Toc75464205">3.3 Hello的编译结果解析 - 10 -</a></p><p><em><a href="#_Toc75464206">3.3.1 数据 - 10 -</a></em></p><p><em><a href="#_Toc75464207">3.3.2 赋值 =，逗号操作符，赋初值/不赋初值 - 11 -</a></em></p><p><em><a href="#_Toc75464208">3.3.3 类型转换（隐式或显式） - 11 -</a></em></p><p><em><a href="#_Toc75464209">3.3.4 算术操作 - 11 -</a></em></p><p><em><a href="#_Toc75464210">3.3.5 关系操作 - 11 -</a></em></p><p><em><a href="#_Toc75464211">3.3.6 数组/指针/结构操作- 12 -</a></em></p><p><em><a href="#_Toc75464212">3.3.7 控制转移 - 12 -</a></em></p><p><em><a href="#_Toc75464213">3.3.8 函数操作 - 12 -</a></em></p><p><a href="#_Toc75464214">3.4 本章小结 - 14 -</a></p><p><strong><a href="#_Toc75464215">第 4 章 汇编 - 15 -</a></strong></p><p><a href="#_Toc75464216">4.1 汇编的概念与作用 - 15 -</a></p><p><a href="#_Toc75464217">4.2 在Ubuntu下汇编的命令 - 15 -</a></p><p><a href="#_Toc75464218">4.3 可重定位目标elf格式 - 15 -</a></p><p><a href="#_Toc75464219">4.4 Hello.o的结果解析 - 18 -</a></p><p><a href="#_Toc75464220">4.5 本章小结 - 19 -</a></p><p><strong><a href="#_Toc75464221">第 5 章 链接 - 20 -</a></strong></p><p><a href="#_Toc75464222">5.1 链接的概念与作用 - 20 -</a></p><p><a href="#_Toc75464223">5.2 在Ubuntu下链接的命令 - 20 -</a></p><p><a href="#_Toc75464224">5.3 可执行目标文件hello的格式 - 20 -</a></p><p><a href="#_Toc75464225">5.4 hello的虚拟地址空间 - 23 -</a></p><p><a href="#_Toc75464226">5.5 链接的重定位过程分析 - 24 -</a></p><p><a href="#_Toc75464227">5.6 hello的执行流程 - 25 -</a></p><p><a href="#_Toc75464228">5.7 Hello的动态链接分析 - 26 -</a></p><p><a href="#_Toc75464229">5.8 本章小结 - 27 -</a></p><p><strong><a href="#_Toc75464230">第 6 章 hello进程管理 - 28 -</a></strong></p><p><a href="#_Toc75464231">6.1 进程的概念与作用 - 28 -</a></p><p><a href="#_Toc75464232">6.2 简述壳Shell-bash的作用与处理流程 - 28 -</a></p><p><a href="#_Toc75464233">6.3 Hello的fork进程创建过程 - 29 -</a></p><p><a href="#_Toc75464234">6.4 Hello的execve过程 - 29 -</a></p><p><a href="#_Toc75464235">6.5 Hello的进程执行 - 30 -</a></p><p><a href="#_Toc75464236">6.6 hello的异常与信号处理 - 32 -</a></p><p><a href="#_Toc75464237">6.7本章小结 - 35 -</a></p><p><strong><a href="#_Toc75464238">第 7 章 hello的存储管理 - 36 -</a></strong></p><p><a href="#_Toc75464239">7.1 hello的存储器地址空间 - 36 -</a></p><p><a href="#_Toc75464240">7.2 Intel逻辑地址到线性地址的变换-段式管理 - 36 -</a></p><p><a href="#_Toc75464241">7.3 Hello的线性地址到物理地址的变换-页式管理 - 36 -</a></p><p><a href="#_Toc75464242">7.4 TLB与四级页表支持下的VA到PA的变换 - 37 -</a></p><p><a href="#_Toc75464243">7.5 三级Cache支持下的物理内存访问 - 37 -</a></p><p><a href="#_Toc75464244">7.6 hello进程fork时的内存映射 - 38 -</a></p><p><a href="#_Toc75464245">7.7 hello进程execve时的内存映射 - 38 -</a></p><p><a href="#_Toc75464246">7.8 缺页故障与缺页中断处理 - 39 -</a></p><p><a href="#_Toc75464247">7.9动态存储分配管理 - 40 -</a></p><p><a href="#_Toc75464248">7.10本章小结 - 41 -</a></p><p><strong><a href="#_Toc75464249">第 8 章 hello的IO管理 - 42 -</a></strong></p><p><a href="#_Toc75464250">8.1 Linux的IO设备管理方法 - 42 -</a></p><p><a href="#_Toc75464251">8.2 简述Unix IO接口及其函数 - 42 -</a></p><p><a href="#_Toc75464252">8.3 printf的实现分析 - 43 -</a></p><p><a href="#_Toc75464253">8.4 getchar的实现分析 - 44 -</a></p><p><a href="#_Toc75464254">8.5本章小结 - 44 -</a></p><p><strong><a href="#_Toc75464255">结论 - 45 -</a></strong></p><p><strong><a href="#_Toc75464256">附件 - 46 -</a></strong></p><p><strong><a href="#_Toc75464257">参考文献 - 47 -</a></strong></p><h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>P2P(Program to Process)：首先是编写高级语言程序文件hello.c，文本文件在Linux系统下经过预处理器cpp，编译器ccl，汇编器as，链接器ld的处理转最终形成一个可执行二进制目标文件hello。shell 通过fork子进程，分配内存资源，然后通过exevce函数去加载运行这个进程。</p><p>O2O(0 to 0)：执行该目标文件，首先shell中使用execve加载并执行该程序时，操作系统为程序分配一部分虚拟空间，将程序加载到虚拟空间所映射的物理内存空间中。然后执行目标程序。在程序运行结束后，shell回收创建的进程，释放进程的虚拟空间、删除相关数据结构。</p><h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><p>硬件环境：处理器Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz；16GB RAM；1 TB SSD</p><p>软件环境：Windows 10 21H1；VirtualBox；Ubuntu 20.04 LTS</p><p>开发工具：EDB；GDB；CodeBlocks；vi/vim/gpedit；gcc；Vscode</p><h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><p>列出你为编写本论文，生成的中间结果文件的名字，文件的作用等。</p><table><thead><tr><th><strong>中间结果文件的名字</strong></th><th><strong>文件的作用</strong></th></tr></thead><tbody><tr><td>hello.i</td><td>修改了的源程序（文本）</td></tr><tr><td>hello.s</td><td>汇编程序（文本）</td></tr><tr><td>hello.o</td><td>可重定位目标程序（二进制）</td></tr><tr><td>hello</td><td>可执行目标程序（二进制）</td></tr><tr><td>elf.txt</td><td>可重定位目标ELF格式</td></tr><tr><td>linked_elf.txt</td><td>可执行目标ELF格式</td></tr><tr><td>objdump.txt</td><td>hello.o的反汇编代码</td></tr><tr><td>objdump2.txt</td><td>hello的反汇编代码</td></tr></tbody></table><h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>第一章主要对论文讨论的主要内容，首先对hello过程进行了总体概况，包括P2P、020的整个过程，然后介绍个人使用电脑的硬件环境、软件环境和开发工具，最后介绍了过程中产生的文件及其作用等。</p><h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>预处理概念：预处理一般是指程序在编译系统处理过程中，预处理器(cpp)根据以符号"#"开头的命令，修改原始的C程序代码文本，主要是进行代码文本的替换工作，得到的结果再由编译器(ccl)进一步编译。用于在编译器处理程序之前预扫描代码，完成头文件包含、宏扩展、条件编译、行控制等操作。</p><p>预处理作用：这个过程并不对程序的源代码进行解析,但它把源代码分割或处理成为特定的单位，将预处理指令（以#开头）转化为实际代码中的内容，但只是单纯的替换和展开。例如，读取命令#include中包含的系统头文件并把它插入系统文本中，扩展所有用#define声明指定的宏。预处理过程还会删除程序中的注释和多余的空白字符。</p><h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p>命令行：Linux&amp;gt; cpp hello.c &amp;gt;hello.i</p><p>预处理命令及结果：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105714.png" alt="image003"></p><p>图1：预处理命令</p><p>预处理后源代码部分，注意到此时行数已经到了三千多行：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105725.png" alt="image005"></p><p>图2：预处理结果</p><p>预处理从头文件中插入的文本等：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105733.png" alt="image007"></p><p>图3：预处理插入内容</p><h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>发现预处理之后，程序已经从原来的几十行变为了大约三千六十六行，并且源代码出现在最后，并且#include命令和注释等全都消失不见，推测之前的代码应该就是用头文件stdio.h\unistd.h\stdlib.h中的实际内容代替的对于命令行。其中包括了大量的相对路径、typedef类型创建名、extern关键字函数等。</p><h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>本章主要介绍了C语言的预处理过程，包括预处理的概念和作用，在Linux系统下预处理的命令，以及预处理的结果及生成文件hello.i，还有解析预处理。</p><h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译的概念：编译是编译器（一种计算机程序）运行过程，会将某种编程语言写成的源代码（原始语言）通过词法语法分析之后转换成另一种编程语言（目标语言）。</p><p>编译的作用：编译主要做词法分析、语法分析、语义分析、优化后生成相应的汇编代码。在C语言的编译中，编译器将高级语言C转化为了机器码汇编语言，在这里将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。</p><p>注意：这儿的编译是指从 .i 到 .s 即预处理后的文件到生成汇编语言程序</p><h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>命令行：Linux&amp;gt; gcc -S hello.i -o hello.s</p><p>编译过程截图：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105802.png" alt="image009"></p><p>图4：编译命令</p><p>编译结果部分截图：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105807.png" alt="image011"></p><p>图5：编译结果</p><h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p>此部分是重点，说明编译器是怎么处理C语言的各个数据类型以及各类操作的。应分3.3.1~ 3.3.x等按照类型和操作进行分析， <strong>只要</strong>** hello.s <strong><strong>中出现的属于大作业</strong></strong> PPT <strong><strong>中</strong></strong> P4 <strong><strong>给出的参考</strong></strong> C **<strong>数据与操作，都应解析</strong> 。</p><h3 id="3-3-1-数据"><a href="#3-3-1-数据" class="headerlink" title="3.3.1 数据"></a>3.3.1 数据</h3><ol><li><strong>常量</strong></li></ol><p>首先对于代码 if(argc!=3) printf("Hello %s %s\n",argv[1],argv[2]);中存在常量3、1、2，类似于它们这些常数，被存放在代码段，所以保存在.text中。例如，对于第一句中的3，存放在 cmpl   $3, -20(%rbp) 其他也同理可得。</p><p>对于函数printf("Usage: Hello 1190202105 傅浩东！\n");中的字符串常量存放在.rodata节的.LC0中，printf("Hello %s %s\n",argv[1],argv[2]);中的字符串存放在.rodata节的.LC1中。如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">   .string &amp;quot;Usage: Hello 1190202105\345\202\205\346\265\251\344\270\234\357\274\201&amp;quot;</span><br><span class="line">.LC1:</span><br><span class="line">    .string &amp;quot;Hello %s %s\n&amp;quot;</span><br></pre></td></tr></tbody></table></figure><ol><li><strong>变量</strong></li></ol><p><strong>全局变量：</strong> 已初始化的全局和静态变量在.data节。在本节中，全局变量sleepsecs最开始赋值为2.5，但被隐式地转为int数据类型，所以会变为2 int sleepsecs=2.5; 所以在汇编代码中可以看到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    .data</span><br><span class="line">    .align 4</span><br><span class="line">    .type   sleepsecs, @object</span><br><span class="line">    .size   sleepsecs, 4</span><br><span class="line">sleepsecs:</span><br><span class="line">    .long   2</span><br></pre></td></tr></tbody></table></figure><p><strong>局部变量：</strong> 原始代码中定义了局部变量 int I 储存在寄存器或者栈中，所以汇编代码有如下，循环前值为0的i被保存在 %rsp-4 的位置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.L2:</span><br><span class="line">    movl    $0, -4(%rbp)</span><br><span class="line">    jmp .L3</span><br></pre></td></tr></tbody></table></figure><p><strong>函数参数：</strong> 主函数main的两个参数int argc,char *argv[]分别都存放在栈中，由寄存器的偏移来分别表示。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subq    $32, %rsp</span><br><span class="line">movl    %edi, -20(%rbp)</span><br><span class="line">movq    %rsi, -32(%rbp)</span><br></pre></td></tr></tbody></table></figure><h3 id="赋值-，逗号操作符，赋初值-不赋初值"><a href="#赋值-，逗号操作符，赋初值-不赋初值" class="headerlink" title="赋值=，逗号操作符，赋初值/不赋初值"></a>赋值=，逗号操作符，赋初值/不赋初值</h3><p>在循环最开始有给循环条件变量i赋初值的操作：for(i=0;i&amp;lt;10;i++)</p><p>通过汇编语句 movl   $0, -4(%rbp) 给局部变量 i 赋初值0。</p><h3 id="类型转换（隐式或显式）"><a href="#类型转换（隐式或显式）" class="headerlink" title="类型转换（隐式或显式）"></a>类型转换（隐式或显式）</h3><p>int 类型全局变量 sleepsecs 赋值为 2.5 时进行了隐式类型转换（将浮点数类型转为整型），变量值变为 2：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sleepsecs=2.5;</span><br></pre></td></tr></tbody></table></figure><h3 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h3><p>在循环操作中，实现了i++操作 for(i=0;i&amp;lt;10;i++)</p><p>每次循环结束之后，对i进行一次自加，栈上对应的存储变量i的值加1：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addl    $1, -4(%rbp)</span><br></pre></td></tr></tbody></table></figure><p>addl    $1, -4(%rbp)实现为栈开辟空间；</p><h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>判断 argc 是否是3和循环终止条件用到了关系操作，如下所示，在源代码中有argc!=3和i&amp;lt;10 判断不等和小于。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(argc!=3)</span><br><span class="line">{</span><br><span class="line">    printf(&amp;quot;Usage: Hello 1190202105 傅浩东！\n&amp;quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">}</span><br><span class="line">for(i=0;i\&amp;lt;10;i++)</span><br><span class="line">{</span><br><span class="line">    printf(&amp;quot;Hello %s %s\n&amp;quot;,argv[1],argv[2]);</span><br><span class="line">    sleep(sleepsecs);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它们对映的汇编指令有：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl    $3, -20(%rbp)</span><br><span class="line">je  .L2</span><br></pre></td></tr></tbody></table></figure><p>比较3与%rbp-20位置的数值是否相等，不相等则跳转到.L2处。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpl    $9, -4(%rbp)</span><br><span class="line">jle .L4</span><br></pre></td></tr></tbody></table></figure><p>比较9与%rbp-4的操作数大小，若后者小于前者即9，则跳转到.L4处。</p><h3 id="数组-指针-结构操作"><a href="#数组-指针-结构操作" class="headerlink" title="数组/指针/结构操作"></a>数组/指针/结构操作</h3><p>最开始可以知道，主函数main的参数中有指针数组char *argv[]，源代码中对数组的引用是输出 argv[1]和 argv[2]，利用在栈帧中位置，通过%rbp-16和%rbp-24，分别得到 argv[1]和 argc[2]两个字符串。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    movl    %edi, -20(%rbp)//argc</span><br><span class="line">    movq    %rsi, -32(%rbp)//argv</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">### 控制转移</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>if(argc!=3)<br>for(i=0;i&amp;lt;10;i++)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述原函数中两个部分使用了控制转移，这部分内容在关系操作部分已经提及，就不再赘述。</span><br><span class="line"></span><br><span class="line">### 函数操作</span><br><span class="line"></span><br><span class="line">主要从函数传递（地址/值）、函数调用（）、函数返回return三个方面来对以下函数进行编译结果解析。</span><br><span class="line"></span><br><span class="line">**Main 函数：**</span><br><span class="line"></span><br><span class="line">参数传递：int argc,char \*argv[] 分别储存在寄存器%rdi和%rsi中</span><br><span class="line"></span><br><span class="line">函数调用：被系统函数调用</span><br><span class="line"></span><br><span class="line">函数返回：函数return 0，返回值储存在寄存器%eax中</span><br><span class="line"></span><br><span class="line">**Printf  函数：**</span><br><span class="line"></span><br><span class="line">参数传递：首先对于puts，将.LC0作为参数传递，即只传入了字符串首地址；对于printf，将栈中的两个数据传给printf，即argv[1]和argv[2]的地址，另外还传入了.LC0参数，即字符串首地址。</span><br><span class="line"></span><br><span class="line">函数调用：判断argc!=3，若该不等式成立，则调用printf；在for循环中，即i在范围0到9之间都调用函数printf。但是它们对应汇编指令分别有puts和printf。</span><br><span class="line"></span><br><span class="line">函数返回：暂时未知</span><br><span class="line"></span><br><span class="line">汇编指令：call puts@PLT以及call printf@PLT</span><br><span class="line"></span><br><span class="line">对于第一条 printf(&amp;quot;Usage: Hello 1190202105 傅浩东！\n&amp;quot;);有如下汇编：</span><br></pre></td></tr></tbody></table></figure><pre><code>cmpl    $3, -20(%rbp)je  .L2leaq    .LC0(%rip), %rdicall    puts@PLT</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于printf(&amp;quot;Hello %s %s\n&amp;quot;,argv[1],argv[2]);有：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>.L4:<br>    movq    -32(%rbp), %rax<br>    addq    $16, %rax<br>    movq    (%rax), %rdx<br>    movq    -32(%rbp), %rax<br>    addq    $8, %rax<br>    movq    (%rax), %rax<br>    movq    %rax, %rsi<br>    leaq    .LC1(%rip), %rdi<br>    movl    $0, %eax<br>    call    printf@PLT</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**Exit 函数：**</span><br><span class="line"></span><br><span class="line">参数传递：源代码exit(1);传递的参数为1，从下面的汇编代码可知该参数储存在寄存器%edi之中。</span><br></pre></td></tr></tbody></table></figure><pre><code>movl    $1, %edicall    exit@PLT</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数调用：判断argc!=3，若该不等式成立，则在调用printf之后调用函数exit。</span><br><span class="line"></span><br><span class="line">函数返回：暂时不知</span><br><span class="line"></span><br><span class="line">**Sleep 函数：**</span><br><span class="line"></span><br><span class="line">参数传递：根据源代码易知，将全局变量sleepsecs作为参数传递给了sleep函数，从汇编指令可知应该是将sleepsecs储存在%edi中来传递。</span><br></pre></td></tr></tbody></table></figure><pre><code>movl    sleepsecs(%rip), %eaxmovl    %eax, %edicall    sleep@PLT</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数调用：循环条件成立时，即i在0到9之间，每一次循环都在调用printf之后调用函数sleep。</span><br><span class="line"></span><br><span class="line">函数返回：暂时不知。</span><br><span class="line"></span><br><span class="line">**Getchar 函数：**</span><br><span class="line"></span><br><span class="line">参数传递：无</span><br><span class="line"></span><br><span class="line">函数调用：main函数return 0之前调用。</span><br><span class="line"></span><br><span class="line">函数返回：暂时不知</span><br></pre></td></tr></tbody></table></figure><pre><code>call    getchar@PLT</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.4 本章小结</span><br><span class="line"></span><br><span class="line">本章首先介绍了编译的概念与作用，接着是编译命令和结果，重点在对hello编译结果解析。分别对数据、赋值、隐式类型转换、算术操作、关系操作、数组/指针操作、控制转移、函数操作等多个方面来对编译结果进行了详细的解释，也对 hello.s 其中的语句进行分析，找出指令与源代码的对应情况等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第4章 汇编</span><br><span class="line"></span><br><span class="line">## 4.1 汇编的概念与作用</span><br><span class="line"></span><br><span class="line">**汇编的概念：** 汇编器(as)将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标代码(relocatable object program)的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，包含所有指令的二进制表示，但是还没有填入全局值的地址，如果在文本编辑器中打开 hello.o文件，将看到一堆乱码。</span><br><span class="line"></span><br><span class="line">**汇编的作用：** 汇编就是将.s程序翻译成机器语言指令，并将这些指令打包为可重定位程序格式，保存在二进制文件.o中。便于机器在此后的链接与运行。</span><br><span class="line"></span><br><span class="line">注意：这儿的汇编是指从 .s 到 .o 即编译后的文件到生成机器语言二进制程序的过程。</span><br><span class="line"></span><br><span class="line">## 4.2 在Ubuntu下汇编的命令</span><br><span class="line"></span><br><span class="line">命令行：Linux\&amp;gt; gcc -c hello.s -o hello.o</span><br><span class="line"></span><br><span class="line">汇编过程截图：</span><br><span class="line"></span><br><span class="line">![image013](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105834.png)</span><br><span class="line"></span><br><span class="line">图6：汇编命令</span><br><span class="line"></span><br><span class="line">## 4.3 可重定位目标elf格式</span><br><span class="line"></span><br><span class="line">分析hello.o的ELF格式，用readelf等列出其各节的基本信息，特别是重定位项目分析。</span><br><span class="line"></span><br><span class="line">![image015](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105841.png)</span><br><span class="line"></span><br><span class="line">图7：可重定位目标ELF格式</span><br><span class="line"></span><br><span class="line">命令行：Linux\&amp;gt; readelf -a hello.o \&amp;gt;elf.txt</span><br><span class="line"></span><br><span class="line">![image017](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105850.png)</span><br><span class="line"></span><br><span class="line">图8：ELF命令</span><br><span class="line"></span><br><span class="line">**ELF header**** ：**以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（这里是可重定位）、机器类型（X86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。如下所示：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>  Class:                             ELF64<br>  Data:                              2's complement, little endian<br>  Version:                           1 (current)<br>  OS/ABI:                            UNIX - System V<br>  ABI Version:                       0<br>  Type:                              REL (Relocatable file)<br>  Machine:                           Advanced Micro Devices X86-64<br>  Version:                           0x1<br>  Entry point address:               0x0<br>  Start of program headers:          0 (bytes into file)<br>  Start of section headers:          1240 (bytes into file)<br>  Flags:                             0x0<br>  Size of this header:               64 (bytes)<br>  Size of program headers:           0 (bytes)<br>  Number of program headers:         0<br>  Size of section headers:           64 (bytes)<br>  Number of section headers:         14<br>  Section header string table index: 13</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**节：** 夹在ELF头和节头部表之间的都是节。典型的ELF可重定位目标文件包含如下几个节：.text: 已编译程序的机器代码。.rodata: 只读数据。.data: 已初始化的全局和静态C变量。.bss: 未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。.symtab：符号表，存放程序中定义和引用的函数和全局变量的信息。.rel.text: —个.text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。.rel.data: 被模块引用或定义的所有全局变量的重定位信息。.debug: 个调试符号表，只有以-g选项调用编译器驱动程序时才会得到这张表。.line: 原始C源程序中的行号和.text 节中机器指令之间的映射，以-g选项调用编译器驱动程序时才会得到。.strtab:字符串表，内容包括 .symtab和 .debug节中的符号表，以及节头部中的令名字。如下是节头部表：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 0]                   NULL             0000000000000000  00000000<br>       0000000000000000  0000000000000000           0     0     0<br>  [ 1] .text             PROGBITS         0000000000000000  00000040<br>       0000000000000085  0000000000000000  AX       0     0     1<br>  [ 2] .rela.text        RELA             0000000000000000  00000388<br>       00000000000000c0  0000000000000018   I      11     1     8<br>  [ 3] .data             PROGBITS         0000000000000000  000000c8<br>       0000000000000004  0000000000000000  WA       0     0     4<br>  [ 4] .bss              NOBITS           0000000000000000  000000cc<br>       0000000000000000  0000000000000000  WA       0     0     1<br>  [ 5] .rodata           PROGBITS         0000000000000000  000000d0<br>       0000000000000032  0000000000000000   A       0     0     8<br>  [ 6] .comment          PROGBITS         0000000000000000  00000102<br>       000000000000002b  0000000000000001  MS       0     0     1<br>  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000012d<br>       0000000000000000  0000000000000000           0     0     1<br>  [ 8] .note.gnu.propert NOTE             0000000000000000  00000130<br>       0000000000000020  0000000000000000   A       0     0     8<br>  [ 9] .eh_frame         PROGBITS         0000000000000000  00000150<br>       0000000000000038  0000000000000000   A       0     0     8<br>  [10] .rela.eh_frame    RELA             0000000000000000  00000448<br>       0000000000000018  0000000000000018   I      11     9     8<br>  [11] .symtab           SYMTAB           0000000000000000  00000188<br>       00000000000001b0  0000000000000018          12    10     8<br>  [12] .strtab           STRTAB           0000000000000000  00000338<br>       000000000000004d  0000000000000000           0     0     1<br>  [13] .shstrtab         STRTAB           0000000000000000  00000460<br>       0000000000000074  0000000000000000           0     0     1</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">除此以外，在本例中主要还有如下两个部分：首先是重定位节.rela.text和.rela.eh\_frame，其次就是符号表.symtab。对于重定位节，在链接时需要对其进行修改，通过偏移量等信息计算出正确的地址。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Relocation section '.rela.text' at offset 0x388 contains 8 entries:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>00000000001c  000500000002 R_X86_64_PC32     0000000000000000 .rodata - 4<br>000000000021  000d00000004 R_X86_64_PLT32    0000000000000000 puts - 4<br>00000000002b  000e00000004 R_X86_64_PLT32    0000000000000000 exit - 4<br>000000000054  000500000002 R_X86_64_PC32     0000000000000000 .rodata + 21<br>00000000005e  000f00000004 R_X86_64_PLT32    0000000000000000 printf - 4<br>000000000064  000a00000002 R_X86_64_PC32     0000000000000000 sleepsecs - 4<br>00000000006b  001000000004 R_X86_64_PLT32    0000000000000000 sleep - 4<br>00000000007a  001100000004 R_X86_64_PLT32    0000000000000000 getchar - 4<br>Relocation section '.rela.eh_frame' at offset 0x448 contains 1 entry:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0<br>Symbol table '.symtab' contains 18 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c<br>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1<br>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3<br>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4<br>     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5<br>     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7<br>     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8<br>     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    9<br>     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    6<br>    10: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 sleepsecs<br>    11: 0000000000000000   133 FUNC    GLOBAL DEFAULT    1 main<br>    12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _GLOBAL_OFFSET_TABLE_<br>    13: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts<br>    14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND exit<br>    15: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf<br>    16: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND sleep<br>    17: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND getchar</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4.4 Hello.o的结果解析</span><br><span class="line"></span><br><span class="line">命令行：Linux\&amp;gt; objdump -d -r hello.o \&amp;gt;objdump.s</span><br><span class="line"></span><br><span class="line">分析hello.o的反汇编，与第3章的 hello.s进行对照分析，发现有如下区别：</span><br><span class="line"></span><br><span class="line">1. 分支转移：在.s文件中依靠.L+字段来确定位置的，而反汇编代码中通过间接寻址来跳转到相对偏移地址。</span><br><span class="line">2. 函数调用：hello.s中用 call+函数名来实现对该函数的调用，而反汇编代码中callq使用的是相对偏移地址。但是现在该地址全部为0，将其写在重定位节，链接器后续进行重定位确定真正的地址。</span><br><span class="line">3. 全局变量使用：同样待重定位。</span><br><span class="line">4. 指令表示：在反汇编代码中，省略了许多与字节大小相关的后缀，例如&amp;quot;q&amp;quot;、&amp;quot;l&amp;quot;等；但是call指令又变为了callq（强调这是x86-64版本）。</span><br><span class="line">5. 数据表示：在hello.s文件中数据一般用十进制来表示，而在反汇编代码中是用十六进制来表示的。</span><br><span class="line"></span><br><span class="line">说明机器语言的构成，与汇编语言的映射关系。特别是机器语言中的操作数与汇编语言不一致，特别是分支转移函数调用等。</span><br><span class="line"></span><br><span class="line">## 4.5 本章小结</span><br><span class="line"></span><br><span class="line">本章主要介绍了汇编过程及其结果、可重定位目标ELF格式、以及hello1.o反汇编。经过汇编器汇编语言转化为机器语言指令，打包为二进制可重定位目标文件hello.o。对ELF分析，以及对比hello.s和hello.o反汇编结果，发现汇编过程为链接做了不小的准备，接下来自然要分析链接，进一步了解P2P过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第5章 链接</span><br><span class="line"></span><br><span class="line">## 5.1 链接的概念与作用</span><br><span class="line"></span><br><span class="line">**链接的概念：** 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编，译时（compile time），也就是在源代码被翻译成机器代码时；也可以执行于加栽时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的 程序自动执行的。</span><br><span class="line"></span><br><span class="line">**链接的作用：** 链接在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate compilation）成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。</span><br><span class="line"></span><br><span class="line">注意：这儿的链接是指从 hello.o 到hello生成过程。</span><br><span class="line"></span><br><span class="line">## 5.2 在Ubuntu下链接的命令</span><br><span class="line"></span><br><span class="line">Ld链接命令行：ld -o hello -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib /x86\_64-linux-gnu/crt1.o /usr/lib/x86\_64-linux-gnu/crti.o hello.o /usr/lib/x86\_64-linux -gnu/libc.so /usr/lib/x86\_64-linux-gnu/crtn.o</span><br><span class="line"></span><br><span class="line">过程截图展示：</span><br><span class="line"></span><br><span class="line">![image019](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105907.png)</span><br><span class="line"></span><br><span class="line">图9：ld链接命令</span><br><span class="line"></span><br><span class="line">## 5.3 可执行目标文件hello的格式</span><br><span class="line"></span><br><span class="line">Hello（可执行目标文件）的ELF格式：</span><br><span class="line"></span><br><span class="line">![image021](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105916.png)</span><br><span class="line"></span><br><span class="line">图10：可执行目标文件ELF格式</span><br><span class="line"></span><br><span class="line">命令行：Linux\&amp;gt; readelf -a hello \&amp;gt;linked\_elf.txt</span><br><span class="line"></span><br><span class="line">![image023](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105925.png)</span><br><span class="line"></span><br><span class="line">图11：ELF获取命令</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>ELF header：<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>  Class:                             ELF64<br>  Data:                              2's complement, little endian<br>  Version:                           1 (current)<br>  OS/ABI:                            UNIX - System V<br>  ABI Version:                       0<br>  Type:                              EXEC (Executable file)<br>  Machine:                           Advanced Micro Devices X86-64<br>  Version:                           0x1<br>  Entry point address:               0x4010d0<br>  Start of program headers:          64 (bytes into file)<br>  Start of section headers:          14200 (bytes into file)<br>  Flags:                             0x0<br>  Size of this header:               64 (bytes)<br>  Size of program headers:           56 (bytes)<br>  Number of program headers:         12<br>  Size of section headers:           64 (bytes)<br>  Number of section headers:         27<br>  Section header string table index: 26</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">节头部表（包括各段的起始地址，大小等信息）：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 0]                   NULL             0000000000000000  00000000<br>       0000000000000000  0000000000000000           0     0     0<br>  [ 1] .interp           PROGBITS         00000000004002e0  000002e0<br>       000000000000001c  0000000000000000   A       0     0     1<br>  [ 2] .note.gnu.propert NOTE             0000000000400300  00000300<br>       0000000000000020  0000000000000000   A       0     0     8<br>  [ 3] .note.ABI-tag     NOTE             0000000000400320  00000320<br>       0000000000000020  0000000000000000   A       0     0     4<br>  [ 4] .hash             HASH             0000000000400340  00000340<br>       0000000000000034  0000000000000004   A       6     0     8<br>  [ 5] .gnu.hash         GNU_HASH         0000000000400378  00000378<br>       000000000000001c  0000000000000000   A       6     0     8<br>  [ 6] .dynsym           DYNSYM           0000000000400398  00000398<br>       00000000000000c0  0000000000000018   A       7     1     8<br>  [ 7] .dynstr           STRTAB           0000000000400458  00000458<br>       0000000000000057  0000000000000000   A       0     0     1<br>  [ 8] .gnu.version      VERSYM           00000000004004b0  000004b0<br>       0000000000000010  0000000000000002   A       6     0     2<br>  [ 9] .gnu.version_r    VERNEED          00000000004004c0  000004c0<br>       0000000000000020  0000000000000000   A       7     1     8<br>  [10] .rela.dyn         RELA             00000000004004e0  000004e0<br>       0000000000000030  0000000000000018   A       6     0     8<br>  [11] .rela.plt         RELA             0000000000400510  00000510<br>       0000000000000078  0000000000000018  AI       6    21     8<br>  [12] .init             PROGBITS         0000000000401000  00001000<br>       000000000000001b  0000000000000000  AX       0     0     4<br>  [13] .plt              PROGBITS         0000000000401020  00001020<br>       0000000000000060  0000000000000010  AX       0     0     16<br>  [14] .plt.sec          PROGBITS         0000000000401080  00001080<br>       0000000000000050  0000000000000010  AX       0     0     16<br>  [15] .text             PROGBITS         00000000004010d0  000010d0<br>       0000000000000135  0000000000000000  AX       0     0     16<br>  [16] .fini             PROGBITS         0000000000401208  00001208<br>       000000000000000d  0000000000000000  AX       0     0     4<br>  [17] .rodata           PROGBITS         0000000000402000  00002000<br>       000000000000003a  0000000000000000   A       0     0     8<br>  [18] .eh_frame         PROGBITS         0000000000402040  00002040<br>       00000000000000fc  0000000000000000   A       0     0     8<br>  [19] .dynamic          DYNAMIC          0000000000403e50  00002e50<br>       00000000000001a0  0000000000000010  WA       7     0     8<br>  [20] .got              PROGBITS         0000000000403ff0  00002ff0<br>       0000000000000010  0000000000000008  WA       0     0     8<br>  [21] .got.plt          PROGBITS         0000000000404000  00003000<br>       0000000000000040  0000000000000008  WA       0     0     8<br>  [22] .data             PROGBITS         0000000000404040  00003040<br>       0000000000000008  0000000000000000  WA       0     0     4<br>  [23] .comment          PROGBITS         0000000000000000  00003048<br>       000000000000002a  0000000000000001  MS       0     0     1<br>  [24] .symtab           SYMTAB           0000000000000000  00003078<br>       00000000000004c8  0000000000000018          25    30     8<br>  [25] .strtab           STRTAB           0000000000000000  00003540<br>       0000000000000150  0000000000000000           0     0     1<br>  [26] .shstrtab         STRTAB           0000000000000000  00003690<br>       00000000000000e1  0000000000000000           0     0     1</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其余部分基本就是上述表的具体内容，就不再一一列举。</span><br><span class="line"></span><br><span class="line">## 5.4 hello的虚拟地址空间</span><br><span class="line"></span><br><span class="line">![image025](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105936.png)</span><br><span class="line"></span><br><span class="line">图12：hello虚拟地址空间基本结构</span><br><span class="line"></span><br><span class="line">使用edb加载hello，查看本进程的虚拟地址空间各段信息。</span><br><span class="line"></span><br><span class="line">![image027](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105942.png)</span><br><span class="line"></span><br><span class="line">图13：Memory Regions查看结果</span><br><span class="line"></span><br><span class="line">通过edb中工具Memory Regions查看虚拟空间各段的储存信息，可以知道从0x400000到0x401000只能读，对映节有.interp/.note.gnu.propert/……/.rela.plt；相应的0x401000到0x402000能读和执行，对应节有.init/.plt/.plt.scc/.text/.fini；从0x402000到0x403000只能读，对应节有.rodata/.eh\_frame；从0x403000到0x405000能读写，对应节有.dynamic/.got/.got.plt/.data。如下是0x401000到0x402000部分的对照：</span><br><span class="line"></span><br><span class="line">![image029](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105951.png)</span><br><span class="line"></span><br><span class="line">![image031](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105958.png)</span><br><span class="line"></span><br><span class="line">图14、15：对映节查看</span><br><span class="line"></span><br><span class="line">## 5.5 链接的重定位过程分析</span><br><span class="line"></span><br><span class="line">**命令行** ：Linux\&amp;gt; objdump -d -r hello \&amp;gt;objdump2.s</span><br><span class="line"></span><br><span class="line">**分析比较**** hello ****与**** hello.o ****反汇编结果的不同：**</span><br><span class="line"></span><br><span class="line">1. 函数增加：相较于objdump.s只有main函数，objdump2.s还包含了函数puts ，printf ，getchar，exit，sleep 等等。</span><br><span class="line">2. 节增加：在hello中增加了例如.plt，.plt.sec，.fini等节。</span><br><span class="line">3. 重定位：在hello中发现有lea和call指令的操作数被填充了地址，进行了重定位，其中包括函数的虚拟地址以及储存的字符串的地址（.rodata节的地址与偏移量所决定）和全局变量sleepsecs的虚拟地址。</span><br><span class="line"></span><br><span class="line">**链接的过程** （主要是静态链接）：</span><br><span class="line"></span><br><span class="line">1. 符号解析(symbol resolution)：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即C语言中任何以static属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</span><br><span class="line">2. 重定位（relocation)：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位。</span><br><span class="line"></span><br><span class="line">**分析hello中对重定位项目的重定位方式：**</span><br><span class="line"></span><br><span class="line">一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来。此时，链接器就知道它的输人目标模块中的代码节和数据节的确切大小。</span><br><span class="line"></span><br><span class="line">1. 重定位节和符号定义。链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输人模块定义的每个节，以及赋给输人模块定义的每个符号。这样，程序中的每条指令和全局变量都有唯一的运行时内存地址了。</span><br><span class="line">2. 重定位节中的符号引用。链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。</span><br><span class="line"></span><br><span class="line">## 5.6 hello的执行流程</span><br><span class="line"></span><br><span class="line">使用edb执行hello截图：</span><br><span class="line"></span><br><span class="line">![image033](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110012.png)</span><br><span class="line"></span><br><span class="line">图16：edb执行hello结果</span><br><span class="line"></span><br><span class="line">说明从加载hello到\_start，到call main,以及程序终止的所有过程其调用与跳转的各个子程序名或程序地址，如下所示：</span><br><span class="line"></span><br><span class="line">| **程序地址** | **程序名** |</span><br><span class="line">| --- | --- |</span><br><span class="line">| 0x00000000004010d0 | \_start |</span><br><span class="line">| 0x00007efda717bfc0 | \_\_libc\_start\_main |</span><br><span class="line">| 0x0000000000401190 | \_\_libc\_csu\_init |</span><br><span class="line">| 0x0000000000401000 | \_init |</span><br><span class="line">| 0x0000000000401105 | Main |</span><br><span class="line">| 0x0000000000401080 | puts@plt |</span><br><span class="line">| 0x00000000004010b0 | Exit@plt |</span><br><span class="line">| 0x0000000000401090 | printf@plt |</span><br><span class="line">| 0x00000000004010c0 | sleep@plt |</span><br><span class="line">| 0x00000000004010a0 | getchar@plt |</span><br><span class="line">| 0x0000000000401200 | \_\_libc\_csu\_fini |</span><br><span class="line">| 0x0000000000401208 | \_fini |</span><br><span class="line"></span><br><span class="line">## 5.7 Hello的动态链接分析</span><br><span class="line"></span><br><span class="line">首先可以找到.got和.got.plt两个节起始地址偏移量等。</span><br><span class="line"></span><br><span class="line">![image035](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110020.png)</span><br><span class="line"></span><br><span class="line">通过edb调试，在dl\_init前后，有如下变化：</span><br><span class="line"></span><br><span class="line">![image037](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110036.png)</span><br><span class="line"></span><br><span class="line">图17：dl\_init前</span><br><span class="line"></span><br><span class="line">![image039](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110045.png)</span><br><span class="line"></span><br><span class="line">图18：dl\_init后</span><br><span class="line"></span><br><span class="line">在形成可执行程序时，发现引用了一个外部的函数，检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。</span><br><span class="line"></span><br><span class="line">初始时每个got条目都指向对应plt条目的第二条指令。当库函数被调用后，链接器修改got。下一次调用plt时，指向的就是正确的内存地址。plt就能跳转到正确的区域。</span><br><span class="line"></span><br><span class="line">## 5.8 本章小结</span><br><span class="line"></span><br><span class="line">本章介绍了hello.o到hello的链接过程。主要包括链接的概念和作用；链接过程（虚拟地址空间、链接具体流程、还介绍了动态链接过程）；以及链接结果（可执行目标文件hello的ELF格式以及与hello.o的区别、了解了和hello的执行流程等）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第6章 hello进程管理</span><br><span class="line"></span><br><span class="line">## 6.1 进程的概念与作用</span><br><span class="line"></span><br><span class="line">**进程概念：** 程序是指令、数据及其组织形式的描述，进程是程序的实体。进程的经典定义就是一个执行中程序的实例。</span><br><span class="line"></span><br><span class="line">**进程作用：** 在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中 当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。</span><br><span class="line"></span><br><span class="line">## 6.2 简述壳Shell-bash的作用与处理流程</span><br><span class="line"></span><br><span class="line">**壳的作用：** Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口，Shell 是一种命令行解释器，其读取用户输入的字符串命令，解释并把它们送到内核。它是一种特殊的应用程序，介于系统调用/库和应用程序之间，提供了运行其他程序的接口。</span><br><span class="line"></span><br><span class="line">**壳的处理流程：**</span><br><span class="line"></span><br><span class="line">shell 先分词，判断命令是否为内部命令，如果不是，则寻找可执行文件进行执行，重复这个流程：</span><br><span class="line"></span><br><span class="line">1. Shell 首先从命令行中找出特殊字符（元字符），在将元字符翻译成间隔符 号。元字符将命令行划分成小块 tokens。Shell 中的元字符如下所示：SPACE , TAB , NEWLINE , &amp;amp; , ; , ( , ) ,\&amp;lt; , \&amp;gt; , |</span><br><span class="line">2. 程序块 tokens 被处理，检查看他们是否是 shell 中所引用到的关键字。</span><br><span class="line">3. 当程序块 tokens 被确定以后，shell 根据 aliases 文件中的列表来检查命令的第一个单词。如果这个单词出现在 aliases 表中，执行替换操作并且处理过程回到第一步重新分割程序块 tokens。</span><br><span class="line">4. Shell 对~符号进行替换。</span><br><span class="line">5. Shell 对所有前面带有$符号的变量进行替换。</span><br><span class="line">6. Shell 将命令行中的内嵌命令表达式替换成命令；他们一般都采用 $(command)标记法。</span><br><span class="line">7. Shell 计算采用$(expression)标记的算术表达式。</span><br><span class="line">8. Shell 将命令字符串重新划分为新的块 tokens。这次划分的依据是栏位分割符号，称为 IFS。缺省的 IFS 变量包含有：SPACE , TAB 和换行符号。</span><br><span class="line">9. Shell 执行通配符\* ? []的替换。</span><br><span class="line">10. Shell 把所有处理的结果中用到的注释删除，並且按照下面的顺序实 行命令的检查：</span><br><span class="line"></span><br><span class="line">I. 内建的命令</span><br><span class="line"></span><br><span class="line">II. shell 函数（由用户自己定义的）</span><br><span class="line"></span><br><span class="line">III. 可执行的脚本文件（需要寻找文件和 PATH 路径）</span><br><span class="line"></span><br><span class="line">1. 在执行前的最后一步是初始化所有的输入输出重定向。</span><br><span class="line">2. 最后，执行命令。</span><br><span class="line"></span><br><span class="line">## 6.3 Hello的fork进程创建过程</span><br><span class="line"></span><br><span class="line">父进程通过调用 fork 函数创建一个新的运行的子进程。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。具体过程如下：</span><br><span class="line"></span><br><span class="line">1. 给新进程分配一个标识符</span><br><span class="line">2. 在内核中分配一个PCB,将其挂在PCB表上</span><br><span class="line">3. 复制它的父进程的环境（PCB中大部分的内容）</span><br><span class="line">4. 为其分配资源（程序、数据、栈等）</span><br><span class="line">5. 复制父进程地址空间里的内容（代码共享，数据写时拷贝）</span><br><span class="line">6. 将进程置成就绪状态，并将其放入就绪队列，等待CPU调度。</span><br><span class="line"></span><br><span class="line">## 6.4 Hello的execve过程</span><br><span class="line"></span><br><span class="line">execve函数在当前进程的上下文中加载并运行一个新程序。</span><br><span class="line"></span><br><span class="line">execve函数加载并运行可执行目标文件hello，且带参数列表argv和环境变量 列表envp。只有当出现错误时，例如找不到hello，才会返回到调用程序。所以，与fork一次调用返回两次不同，execve调用一次并从不返回。</span><br><span class="line"></span><br><span class="line">在execve加载了hello之后调用启动代码，启动代码设置栈，并=将控制传递给新程序的主函数，该主函数如下原型：int main(int argc, char \*\*argv, char \* \*\*envp)或是等价的int main(int argc, char \*argv[], char \*\*envp[])。</span><br><span class="line"></span><br><span class="line">当main开始执行时，用户栈的组织结构如图所示。让我们从栈底（高地址）往栈顶（低地址）依次看一看。首先是参数和环境字符串。栈往上紧随其后的是以null结尾的指针数组，其中每个指针都指向找中的一个环境变量字符串。全局变量environ指向这些指针中的第一个envp[0]。紧随环境变量数组之后的是以null 结尾的 argv[]数组，其中每个元素都指向钱中的一个参数字符串。在找的顶部是系统启动函数libc\_start\_main的栈帧。</span><br><span class="line"></span><br><span class="line">![image041](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110059.png)</span><br><span class="line"></span><br><span class="line">图19：用户栈的组织结构</span><br><span class="line"></span><br><span class="line">## 6.5 Hello的进程执行</span><br><span class="line"></span><br><span class="line">结合进程上下文信息、进程时间片，阐述进程调度的过程，用户态与核心态转换等等。</span><br><span class="line"></span><br><span class="line">**进程上下文信息：** 内核为每个进程维持一个上下文（context）。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</span><br><span class="line"></span><br><span class="line">**进程时间片：** 时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</span><br><span class="line"></span><br><span class="line">**进程调度的过程：** 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度( scheduling)，是由内核中称为调度器(scheduler)的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换1)保存当前进程的上下文，2)恢复某个先前被抢占的进程被保存的上下文，3)将控制传递给这个新恢复的进程。</span><br><span class="line"></span><br><span class="line">当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个read系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</span><br><span class="line"></span><br><span class="line">中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每1毫秒或每10毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。</span><br><span class="line"></span><br><span class="line">![image043](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110107.png)</span><br><span class="line"></span><br><span class="line">图20：进程切换</span><br><span class="line"></span><br><span class="line">**用户态与核心态转换：** 从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。</span><br><span class="line"></span><br><span class="line">## 6.6 hello的异常与信号处理</span><br><span class="line"></span><br><span class="line">hello执行过程中会出现中断、陷进、故障、终止四类异常。</span><br><span class="line"></span><br><span class="line">![image045](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110115.png)</span><br><span class="line"></span><br><span class="line">图21：异常类型</span><br><span class="line"></span><br><span class="line">处理方式：</span><br><span class="line"></span><br><span class="line">![image047](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110124.png)</span><br><span class="line"></span><br><span class="line">![image049](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110133.png)</span><br><span class="line"></span><br><span class="line">![image051](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110141.png)</span><br><span class="line"></span><br><span class="line">![image053](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110150.png)</span><br><span class="line"></span><br><span class="line">图22-24：四种异常处理过程</span><br><span class="line"></span><br><span class="line">程序运行过程中不停乱按，包括回车：</span><br><span class="line"></span><br><span class="line">![image055](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110159.png)</span><br><span class="line"></span><br><span class="line">图25：运行过程乱按</span><br><span class="line"></span><br><span class="line">按Ctrl-C截图</span><br><span class="line"></span><br><span class="line">![image057](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110205.png)</span><br><span class="line"></span><br><span class="line">图26：按Ctrl+C</span><br><span class="line"></span><br><span class="line">按Ctrl-Z之后，运行ps jobs pstree fg kill 等命令，运行截屏如下：</span><br><span class="line"></span><br><span class="line">![image059](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110212.png)</span><br><span class="line"></span><br><span class="line">![image061](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110221.png)</span><br><span class="line"></span><br><span class="line">![image063](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110228.png)</span><br><span class="line"></span><br><span class="line">图27、28：Ctrl+Z之后各种指令结果</span><br><span class="line"></span><br><span class="line">说明异常与信号的处理：</span><br><span class="line"></span><br><span class="line">运行过程中乱按，输入被写入缓存区，不会对运行造成太大影响（除开某些特殊按键）。按Ctrl+C进程收到SIGINT信号，结束。按Ctrl+Z进程收到SIGSTP信号，进程被挂起，通过ps、jobs查看状态，使用fg命令将其调回前台，pstree命令以树状图显示进程间的关系。</span><br><span class="line"></span><br><span class="line">## 6.7本章小结</span><br><span class="line"></span><br><span class="line">本章主要介绍了进程的执行过程。具体包括概念与作用、Shell的作用与处理流程， fork和exccvc的执行过程，也从进程时间片、上下文切换用户模式和内核模式等方面介结了hello程序执行时的调度问题，异常与信号处理等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第7章 hello的存储管理</span><br><span class="line"></span><br><span class="line">## 7.1 hello的存储器地址空间</span><br><span class="line"></span><br><span class="line">**逻辑地址：** 一个项目（[存储单元](https://en.wikipedia.org/wiki/Computer_data_storage)、存储元件、网络主机）从正在执行的[应用程序](https://en.wikipedia.org/wiki/Application_program)的角度看来驻留的地址。是指由程序hello 产生的与段相关的偏移地址部分。</span><br><span class="line"></span><br><span class="line">**线性地址：** 是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。</span><br><span class="line"></span><br><span class="line">**虚拟地址：** 在支持[虚拟内存](https://en.wikipedia.org/wiki/Virtual_memory)的系统中，在尝试访问之前，实际上可能没有任何物理内存映射到逻辑地址。访问触发操作系统的特殊功能，该功能重新编程 MMU 以将地址映射到某个物理内存，可能将该内存的旧内容写入磁盘并从磁盘读回内存应在新逻辑地址处包含的内容。在这种情况下，逻辑地址可以称为[虚拟地址](https://en.wikipedia.org/wiki/Virtual_address)。</span><br><span class="line"></span><br><span class="line">**物理地址：** 出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。CPU通过地址总线的寻址，找到真实的物理内存对应地址。</span><br><span class="line"></span><br><span class="line">## 7.2 Intel逻辑地址到线性地址的变换-段式管理</span><br><span class="line"></span><br><span class="line">在Intel平台下，逻辑地址（logical address）是selector:offset这种形式，selector 是CS寄存器的值，offset是EIP寄存器的值。如果用selector去GDT（全局描述符表）里拿到segment base address（段基址）然后加上offset（段内偏移），这就得到了linear address。我们把这个过程称作 **段式内存管理** 。</span><br><span class="line"></span><br><span class="line">一个逻辑地址由两部分组成：段标识符和段内偏移量。段标识符是多位长的字段组成，称为段选择符，其中前面部分是一个索引号，后面部分可以从段描述符表中选择一个具体的段。程序过来一个逻辑地址，使用其段选择符的Index字段去索引段描述符表。将段描述符中的索引号对应的描述符字段和逻辑地址中的offset合并即得到了线性地址。</span><br><span class="line"></span><br><span class="line">## 7.3 Hello的线性地址到物理地址的变换-页式管理</span><br><span class="line"></span><br><span class="line">如果再把 linear address 切成四段，用前三段分别作为索引去PGD、PMD、Page Table里查表，最终就会得到一个页表项（Page Table Entry），那里面的值就是一页物理内存的起始地址，把它加上 linear address 切分之后第四段的内容（又叫页内偏移）就得到了最终的 physical address。我们把这个过程称作 **页式内存管理** 。</span><br><span class="line"></span><br><span class="line">先将线性地址分为 VPN+VPO 的形式， 然后再将VPN拆分成TLBT+TLBI 索引然后去TLB缓存里找所对应的PPN（物理页号），如果发生缺页情况则直接查找对应的PPN，找到PPN之后，将其与VPO组合变为PPN+VPO就是生成的物理地址了。</span><br><span class="line"></span><br><span class="line">## 7.4 TLB与四级页表支持下的VA到PA的变换</span><br><span class="line"></span><br><span class="line">一级页表中的每个PTE负责映射虚拟地址空间中一个片（chunk），这里每一 片都是由连续的页面组成的。如果片i中的每个页面都未被分配，那么一级 PTEi 就为空。依次类推，对二级到三级，三级到四级页表基本上也是如此。四级页表中的每个PTE都负责映射一个虚拟内存页面。具体步骤如下所示：</span><br><span class="line"></span><br><span class="line">开始时，MMU从虚拟地址中抽取出VPN，并且检查TLB，看它是否因为前面的某个内存引用缓存了PTE的一个副本。TLB从VPN中抽取出TLB索引和TLB 标记，查看组中是否有条目可以有效匹配，若有则命中，然后将缓存的PPN返回给MMU。如果TLB不命中，那么MMU就需要从主存中取出相应的PTE。现在，MMU有了形成物理地址所需要的所有东西，通过将来自PTE的PPN和来自虚拟地址的VPO连接起来，就形成了物理地址。</span><br><span class="line"></span><br><span class="line">如果TLB不命中，那么MMU必须从页表中的PTE中取出PPN，如果得到的 PTE是无效的，那么就产生一个缺页，内核必须调入合适的页面，重新运行这条加载指令。还有其他情况就不一一赘述了。</span><br><span class="line"></span><br><span class="line">![image065](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110241.png)</span><br><span class="line"></span><br><span class="line">图29：地址翻译过程</span><br><span class="line"></span><br><span class="line">## 7.5 三级Cache支持下的物理内存访问</span><br><span class="line"></span><br><span class="line">MMU发送物理地址给缓存，缓存从物理地址中抽取出缓存偏移CO、缓存组索引CI以及缓存标记CT。若CI组中存在标记与CT相匹配，则表示缓存命中，读出在偏移量CO处的数据字节，并将它返回给MMU。随后 MMU 将它传递回 CPU。如果不命中就依次去第二三级高级缓存去取相关数据或代码所在的块。</span><br><span class="line"></span><br><span class="line">## 7.6 hello进程fork时的内存映射</span><br><span class="line"></span><br><span class="line">当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的mm\_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</span><br><span class="line"></span><br><span class="line">当fork在新进程中返回时，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</span><br><span class="line"></span><br><span class="line">## 7.7 hello进程execve时的内存映射</span><br><span class="line"></span><br><span class="line">execve函数在当前进程中加载并运行包含在可执行目标文件filename中的程序，用filename程序有效地替代了当前程序。加载并运行filename需要以下几个步骤:</span><br><span class="line"></span><br><span class="line">1. 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</span><br><span class="line">2. 映射私有区域。为新程序的代码、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为filename文件中的.text和.data区。bss区域是请求二进制零的，映射到匿名文件，其大小包含在filename中。栈和堆区域也是请求二进制零的，初始长度为零。</span><br><span class="line">3. 映射共享区域。如果filename程序与共享对象（或目标）链接，比如标准 C库libc.so那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</span><br><span class="line">4. 设置程序计数器（PC)。execve做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的人口点。</span><br><span class="line"></span><br><span class="line">下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</span><br><span class="line"></span><br><span class="line">![image067](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110249.png)</span><br><span class="line"></span><br><span class="line">图30：内存映射结果</span><br><span class="line"></span><br><span class="line">## 7.8 缺页故障与缺页中断处理</span><br><span class="line"></span><br><span class="line">![image069](https://gitee.com/ifu18/blog-image/raw/master/2021/20210718110258.png)</span><br><span class="line"></span><br><span class="line">图31：缺页故障处理</span><br><span class="line"></span><br><span class="line">处理缺页要求硬件和操作系统内核协作完成：</span><br><span class="line"></span><br><span class="line">1. 处理器生成一个虚拟地址，并把它传送给MMU。</span><br><span class="line">2. MMU生成PTE地址，并从高速缓存/主存请求得到它。</span><br><span class="line">3. 高速缓存/主存向MMU返回PTE。</span><br><span class="line">4. PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</span><br><span class="line">5. 缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</span><br><span class="line">6. 缺页处理程序页面调人新的页面，并更新内存中的PTE。</span><br><span class="line">7. 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中。</span><br><span class="line"></span><br><span class="line">## 7.9动态存储分配管理</span><br><span class="line"></span><br><span class="line">动态内存分配器维护着一个进程的虚拟内存区域，称为堆。分配器将堆视为一组不同大小的块的集合来维护。每个块就是一个连续的虚拟内存片，要么是已分配的，要么是空闲的。已分配的块显式地保留位供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。</span><br><span class="line"></span><br><span class="line">**隐式空闲链表：**</span><br><span class="line"></span><br><span class="line">任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。</span><br><span class="line"></span><br><span class="line">一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是 8 的倍数，且块大小的最低3位总是零。因此，我们只需要内存大小的高位，释放剩余的3位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。头部后面就是应用调用malloc时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。</span><br><span class="line"></span><br><span class="line">**显式空闲链表：**</span><br><span class="line"></span><br><span class="line">把堆组织成一个双向空闲链表，在每个空闲块中，都包含一个pred（前驱）和succ（后继）指针。</span><br><span class="line"></span><br><span class="line">使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性 时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的， 也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略，后进先出（LIFO）的顺序、地址顺序等。</span><br><span class="line"></span><br><span class="line">**分离的空闲链表：**</span><br><span class="line"></span><br><span class="line">分离存储，即维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为n的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。两种基本的分离存储方法：简单分离存储和分离适配。</span><br><span class="line"></span><br><span class="line">## 7.10本章小结</span><br><span class="line"></span><br><span class="line">本章是关于储存管理的一章内容。主要从以下几个方面介绍储存形式以及读写过程等：hello的存储器地址空间、intel的段式管理、hello的页式管理，VA到PA的变换、物理内存访问、hello进程fork时的内存映射、execve时的内存映射、缺页故障与缺页中断处理、动态存储分配管理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第8章 hello的IO管理</span><br><span class="line"></span><br><span class="line">## 8.1 Linux的IO设备管理方法</span><br><span class="line"></span><br><span class="line">**设备的模型化：文件**</span><br><span class="line"></span><br><span class="line">所有的 I/O 设备(例如网络、磁盘和终端)都被模型化为文件，而所有的输入和输出都被当 作对相应文件的读和写来执行。</span><br><span class="line"></span><br><span class="line">**设备管理：unix io 接口**</span><br><span class="line"></span><br><span class="line">这种将设备优雅地映射为文件的方式，允许 Linux 内核引 出一个简单、低级的应用接口，称为 Unix I/O, 这使得所有的输人和输出都能以一种统 一且一致的方式来执行：打开文件；Linux shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误；改变当前的文件位置；读写文件；关闭文件。</span><br><span class="line"></span><br><span class="line">## 8.2 简述Unix IO接口及其函数</span><br><span class="line"></span><br><span class="line">**Unix IO 接口：**</span><br><span class="line"></span><br><span class="line">打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。</span><br><span class="line"></span><br><span class="line">Linux shell创建的每个进程开始时都有三个打开的文件：标准输入、标准输出和标准错误。头文件\&amp;lt; unistd.h\&amp;gt; 定义了常量 STDIN\_ FILENO、STDOUT\_FILENO 和 STDERR\_FILENO，它们可用来代替显式的描述符值。</span><br><span class="line"></span><br><span class="line">改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek操作，显式地设置文件的当前位置为是。</span><br><span class="line"></span><br><span class="line">读写文件。一个读操作就是从文件复制n\&amp;gt;0个字节到内存，从当前文件位置是开始，然后将k增加到k+n。给定一个大小为m字节的文件，当k≥m时执行读操作会触发一个称为 end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的 &amp;quot;EOF符号&amp;quot;。</span><br><span class="line"></span><br><span class="line">关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。</span><br><span class="line"></span><br><span class="line">**函数：**</span><br><span class="line"></span><br><span class="line">1. 打开和关闭文件</span><br><span class="line"></span><br><span class="line">进程是通过调用open函数来打开一个已存在的文件或者创建一个新文件，进程通过调用close函数关闭一个打开的文件。</span><br><span class="line"></span><br><span class="line">1. 读和写文件</span><br><span class="line"></span><br><span class="line">应用程序是通过分别调用read和write函数来执行输入和输出的。read函数从描述符为fd的当前文件位置复制最多n个字节到内存位置 buf。返回值-1表示一个错误，而返回值0表示EOF。否则，返回值表示的是实际传送的字节数量。write 函数从内存位置buf复制至多n个字节到描述符fd的当前文件位置。</span><br><span class="line"></span><br><span class="line">1. 用RIO包健壮地读写</span><br><span class="line"></span><br><span class="line">通过调用rio\_readn和rio\_writen函数，应用程序可以在内存和文件之间直接传送数据。</span><br><span class="line"></span><br><span class="line">1. 读取文件元数据</span><br><span class="line"></span><br><span class="line">应用程序能够通过调用stat和fstat函数，检索到关于文件的信息（有时也称为文件的元数据（metadata））。</span><br><span class="line"></span><br><span class="line">1. 读取目录内容</span><br><span class="line"></span><br><span class="line">应用程序可以用readdir系列函数来读取目录的内容。函数opendir以路径名为参数，返回指向目录流（directory stream）的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。函数closedir关闭流并释放其所有的资源。</span><br><span class="line"></span><br><span class="line">## 8.3 printf的实现分析</span><br><span class="line"></span><br><span class="line">[https://www.cnblogs.com/pianist/p/3315801.html](https://www.cnblogs.com/pianist/p/3315801.html)</span><br><span class="line"></span><br><span class="line">首先，printf函数的函数体如下表示：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>int printf(const char *fmt, …) {<br>    int i;<br>    char buf[256];<br>    va_list arg = (va_list)((char*)(&amp;fmt) + 4);<br>    i = vsprintf(buf, fmt, arg);<br>    write(buf, i);<br>    return i;<br>}</p><pre><code>从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall.字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。该函数接受一个格式字符串是fmt，之后是一个变参列表。后面每一个参数都对应这格式字符串中的一个格式符。调用了两个函数：vsprintf和write。vsprintf程序按照格式fmt结合参数args生成格式化之后的字符串，并返回字串的长度。在printf中调用系统函数write(buf,i)将长度为i的buf输出。所以printf的实现就是：用参数匹配格式字符串，然后用vsprintf将结果字符串整理，最后用write函数输出。## 8.4 getchar的实现分析getchar()是最简单的一次读一个字符的函数，每次调用时从文本流中读入下一个字符，并将其作为结果值返回，返回值是int型。在没有输入或者输入字符有错的时候，getchar()函数将返回一个特殊值EOF。异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。## 8.5本章小结本章介绍了Linux的IO设备管理方法，UNIX的IO接口及其函数，还介绍了printf和getchar两个函数的实现方法。Linux提供了少量的基于Unix I/O模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行I/O重定向。# 结论Hello的一生独白：1. 预处理：将hello.c变为文本文档hello.i文件2. 编译：将hello.i编译成为汇编文件hello.s3. 汇编：将hello.s会变成为可重定位目标文件 hello.o4. 链接：将hello.o与可重定位目标文件和动态链接库链接成为可执行目标程序 hello5. 创建子进程：shell进程调用fork为其创建子进程6. 运行程序：shell调用execve函数，加载运行当前进程的上下文中，execve调用启动加载器，映射虚拟内存，然后进入main函数。7. 结束：shell父进程回收子进程，内核删除为这个进程创建的所有数据结构。对计算机系统的设计与实现的深切感悟，你的创新理念，如新的设计与实现方法。用一种不同的方式向学生介绍计算机。排除了诸如硬件加法器和总线设计这样的主题。虽然谈及了机器语言，但是重点并不在于如何手工编写汇编语言，而是关注C语言编译器是如何将C语言的结构翻译成机器代码的，包括编译器是如何翻译指针、循环、过程调用以及开关（switch) 语句的。更进一步地，我们将更广泛和全盘地看待系统，包括硬件和系统软件，涵盖了包括链接、加载、进程、信号、性能优化、虚拟内存、I/O 以及网络与并发编程等在内的主题。# 附件所有的中间产物的文件名，及其作用。| **中间结果文件的名字** | **文件的作用** || --- | --- || hello.i | 修改了的源程序（文本） || hello.s | 汇编程序（文本） || hello.o | 可重定位目标程序（二进制） || hello | 可执行目标程序（二进制） || elf.txt | 可重定位目标ELF格式 || linked\_elf.txt | 可执行目标ELF格式 || objdump.txt | hello.o的反汇编代码 || objdump2.txt | hello的反汇编代码 |# 参考文献[1] https://bbs.pediy.com/thread-249833.htm[2] https://zh.wikipedia.org/wiki/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8[3] Randal E. Bryant, David R. O&amp;#39;Hallaron. 深入理解计算机系统[M]. 北京：机械工业出版社，2016.[4] https://www.cnblogs.com/losing-1216/p/4884483.html[5] [https://www.cnblogs.com/pianist/p/3315801.html](https://www.cnblogs.com/pianist/p/3315801.html)[6] [https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80](https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80)[7] [https://www.jianshu.com/p/8b37d10bc504](https://www.jianshu.com/p/8b37d10bc504)[8] https://www.zhihu.com/question/29918252/answer/163114415</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Chapter09</title>
      <link href="/2021/06/13/CSAPP-Chapter09/"/>
      <url>/2021/06/13/CSAPP-Chapter09/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>虚拟内存</strong>是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。</p><p>本章的前一部分描述<strong>虚拟内存工作原理</strong>，后一部分描述<strong>应用程序如何使用和管理虚拟内存</strong>。</p></blockquote><h1 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h1><p>**物理寻址 (physical addressing)**：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address, PA).</p><p><strong>物理地址应用</strong>：早期的PC，而诸如数字信号处理器、嵌入式微控制器（汽车、电梯、数字图像帧等）以及Cray超级计算机仍然继续使用这种寻址方式。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104257.jpg" alt="PhysicalAddressing"></p><p>**虚拟寻址 (virtual addressing)**：CPU 通过生成一个虚拟地址 (Virtual Address, VA)来访问主存，这<br>个虚拟地址在被送到内存之前先转换成适当的物理地址。</p><p>**地址翻译 (address translation)**：个虚拟地址转换为物理地址</p><p>**内存管理单元 (Memory Management Unit, MMU)**：利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104330.jpg" alt="VirtualAddressing"></p><h1 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h1><ul><li>**地址空间 (address space)**：非负整数地址的有序集合 $$ { 0, 1, 2, … } $$</li><li>**线性地址空间 (linear address space)**：地址空间中的整数是连续的</li><li>**虚拟地址空间 (virtual address space)**：$$ N = 2^n $$ 个虚拟地址的集合，现代系统通常支持32位或者64位虚拟地址空间<br>$$ { 0, 1, 2, … ,  N-1 } $$</li><li>**物理地址空间 (physical address space)**：$$ M = 2^m $$ 个（不要求，但假设）物理地址的集合<br>$$ { 0, 1, 2, … ,  M-1 } $$</li></ul><p><strong>虚拟地址思想</strong>：允许每个数据对象有多个独立的地址，每个地址都选自一个不同的地址空间。</p><hr><h1 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h1><p>虚拟内存被组织为一个由存放在<strong>磁盘</strong>上的 N 个连续的字节大小的单元组成的<strong>数组</strong>。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被<strong>缓存在主存</strong>中。</p><p>VM 系统通过将虚拟内存分割为称为<strong>虚拟页</strong> (Virtual Page, VP)的大小固定的块来作为磁盘（低层）和主存（高层）之间的<strong>传输单元</strong>，页面大小 $$ P = 2^p 字节 $$<br>相似地，物理内存也分为<strong>物理页</strong> (Physical Page, PP)，大小也为 $$ P 字节 $$ 物理页也被称为<strong>页帧</strong>。</p><table>  <tbody><tr>    <td colspan="2">虚拟页面三种状态</td>  </tr>  <tr>    <td>未分配</td>     <td>VM 系统还未分配(或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间（虚拟页也是根据需要创建的）。</td>  </tr>  <tr>    <td>已缓存</td>     <td>当前已缓存在物理内存中的已分配页。</td>  </tr>  <tr>    <td>未缓存</td>     <td>当未缓存在物理内存中的已分配页。</td>  </tr></tbody></table><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104426.jpg" alt="example1"></p><p><strong>使用虚拟内存优点</strong></p><ul><li>有效使用主存：使用DRAM作为作为部分虚拟地址空间的缓存</li><li>简化内存管理：每个进程都使用统一的线性地址空间</li><li>独立空间地址：一个进程不能影响其他进程内存，用户程序无法获得特权内核信息和代码</li></ul><h2 id="9-3-1-DRAM-缓存的组织结构"><a href="#9-3-1-DRAM-缓存的组织结构" class="headerlink" title="9.3.1 DRAM 缓存的组织结构"></a>9.3.1 DRAM 缓存的组织结构</h2><p>DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100000多倍。</p><p>由于大的不命中处罚和访问第一个字节开销：<strong>虚拟页尺寸</strong>通常是4KB~4MB</p><p>由于大的不命中处罚，<strong>DRAM 缓存全相联</strong><br>任何虚拟页都可以放置在任何的物理页中。？？？？？？？？？？？？？<br>需要一个更大的映射函数，不同于硬件对SRAM缓存</p><p>硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。</p><p>DRAM 缓存总是<strong>使用写回，而不是直写</strong>。</p><h2 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h2><p>虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</p><p><strong>页表将虚拟页映射到物理页</strong>：页表就是一个页表条目 (Page Table Entry, PTE)的数组，将虚拟页地址映射到物理页地址。每个页在页表中一个固定偏移量处都有一个 PTE。</p><p>我们将假设每个 PTE 是由一个<strong>有效位 (valid bit)<strong>和一个</strong>n位地址</strong>字段组成的。<strong>有效位</strong>表明了该虚拟页当前<em>是否被缓存在 DRAM</em> 中。</p><ul><li>有效位1，地址字段表示 DRAM 中相应的物理页的起始位置，<strong>这个物理页中缓存了该虚拟页</strong>。</li><li>有效位0，那么一个空地址表示这个虚拟页还未被分配。</li><li>有效位0，地址不为空，这个地址就指向该虚拟页在磁盘上的起始位置。</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105342.jpg" alt="PageTable"></p><p>$$ PTE数量 = 2^n \div P $$ 其中，n 为虚拟地址大小，P 为页大小。</p><h2 id="9-3-3-页命中-Page-Hit"><a href="#9-3-3-页命中-Page-Hit" class="headerlink" title="9.3.3 页命中 Page Hit"></a>9.3.3 页命中 Page Hit</h2><p><strong>页命中</strong>：虚拟内存中的一个字存在于物理内存中 (DRAM缓存命中)。虚拟地址 <strong>-&gt;</strong> 定位PTE <strong>-&gt;</strong> 从内存读取</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104837.jpg" alt="PageHit"></p><h2 id="9-3-4-缺页-Page-Fault"><a href="#9-3-4-缺页-Page-Fault" class="headerlink" title="9.3.4 缺页 Page Fault"></a>9.3.4 缺页 Page Fault</h2><p><strong>缺页</strong>：引用虚拟内存中的字，不在物理内存中 (DRAM 缓存不命中)。</p><p><strong>缺页处理</strong>：关键是按需<em>页面调度/交换</em>，当有不命中时页从磁盘<em>换入</em>（或者页面<em>调入</em>）DRAM 和从 DRAM <em>换出</em>（或者页面<em>调出</em>）磁盘。</p><ol><li>从有效位判断未缓存，触发缺页异常</li><li>调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，牺牲页如果已经被修改则复制回磁盘。</li><li>内核从磁盘复制 VP 到内存中的 PP, 更新 PTE，随后返回</li><li>重新启动导致缺页的指令，命中！</li></ol><table><thead><tr><th><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104858.jpg" alt="PageFault1"></th><th><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104910.jpg" alt="PageFault2"></th></tr></thead></table><h2 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h2><p>操作系统分配一个新的虚拟页面（如malloc结果），内核在磁盘上分配 VP5，将 PTE5 指向这个新创建的页面。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104927.jpg" alt="AllocatePage"></p><h2 id="9-3-6-局部性"><a href="#9-3-6-局部性" class="headerlink" title="9.3.6 局部性"></a>9.3.6 局部性</h2><ul><li>虚拟内存看上去效率低，但是工作相当好，归功于“局部性”。</li><li>程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个<strong>较小的活动页面(active page)集合</strong>上工作，这个集合叫做**工作集(working set)或者常驻集合(resident set)**。程序的局部性越好，工作集越小。</li><li><strong>工作集大小 &lt; 物理内存大小</strong>：初始开销，即将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。</li><li><strong>工作集大小 &gt; 物理内存大小</strong>：**抖动（thrashing)**页面不断换进换出，导致程序性能暴跌。</li></ul><hr><h1 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h1><p><strong>核心思想</strong>：每个进程都拥有独立的虚拟地址空间。</p><ul><li><strong>简化链接</strong><ul><li>每个程序都有相似的虚拟地址空间</li><li>代码、数据和堆都使用相同的起始地址</li><li>每个进程的内存映像使用相同的基本格式，这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</li></ul></li><li><strong>简化加载</strong><ul><li>Linux 加载器 (execve)为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的）将页表条目指向目标文件中适当的位置。</li><li>每个页面被初次引用时，虚拟内存系统会按照需要自动的调入数据页。</li></ul></li><li><strong>简化内存分配</strong><ul><li>当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc），操作系统分配一个适当数字，如k个连<strong>续的虚拟内存页面</strong>，并且将它们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配是个连续的物理内存页面。物理页面可以随机地分散在物理内存中。</li><li>每个虚拟内存页面都要映射到一个物理页面</li><li>一个虚拟内存页面每次可以分配到不同的物理页面</li></ul></li><li><strong>简化共享</strong><ul><li>不同的虚拟页面映射到相同的物理页面</li><li>一般来讲还是需要进程共享代码和数据，而不是给每个进程创建完全私有的代码、数据、堆以及栈区域</li></ul></li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105003.jpg" alt="Management"></p><hr><h1 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h1><p>在PTE（页表条目）上扩展<strong>许可位</strong>来控制对一个虚拟页面内容的访问，内存管理单元 (MMU) 每次访问数据都要检查许可位。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105024.jpg" alt="Protection"></p><p>如图所示三个许可位：SUP 位表示进程是否必须运行在内核(超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。</p><hr><h1 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105038.jpg" alt="symbols"></p><p>地址翻译是一个 iV 元素的虚拟地址空间（VAS)中的元素和一个 M 元素的物理地址空间(PAS)中元素之间的映射:<br>$$<br>MAP:VAS \rightarrow PAS \bigcup \emptyset<br>$$</p><p>$$<br>MAP(A)=\left{<br>  \begin{matrix}<br>    A’, 虚拟地址A处的数据在PAS的物理地址A’处 \<br>    \emptyset, 虚拟地址A处的数据不在物理内存中<br>  \end{matrix}<br>  \right.<br>$$</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105055.jpg" alt="AddressTranslationBasedOnPageTable"></p><p>CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register, PTBR)指向当前页表。n 位的虚拟地址包含两个部分：一个 p 位的<strong>虚拟页面偏移</strong>(Virtual Page Offset，VPO)和一个(n-p)位的<strong>虚拟页号</strong>(Virtual Page Number, VPN)。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0, VPN 1选择 PTE 1，以此类推。将页表条目中<strong>物理页号</strong>(Physical Page Number, PPN)和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。注意，因为<em>物理和虚拟页面都是 P 字节</em>的，所以物理页面偏移(Physical Page Offset, PPO)和 VPO 是相同的。</p><p><strong>地址翻译：页面命中</strong></p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。<ul><li>PTE 地址(PTEA)：**%CR3 + 页号 * 字节数**</li></ul></li><li>高速缓存/主存向 MMU 返回 PTE。</li><li>MMU 构造物理地址，并把它传送给高速缓存/主存。</li><li>高速缓存/主存返回所请求的数据字给处理器。</li></ol><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105258.jpeg"></p><p><strong>地址翻译：缺页异常</strong></p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU。</li><li>MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。<ul><li>PTE 地址(PTEA)：**%CR3 + 页号 * 字节数**</li></ul></li><li>高速缓存/主存向 MMU 返回 PTE。</li><li>PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘（写回策略）。</li><li>缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li><li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令。</li></ol><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105244.jpg" alt="TranslationPageFault"></p><h2 id="9-6-1-结合高速缓存和虚拟内存"><a href="#9-6-1-结合高速缓存和虚拟内存" class="headerlink" title="9.6.1 结合高速缓存和虚拟内存"></a>9.6.1 结合高速缓存和虚拟内存</h2><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105123.jpg" alt="CacheAndMemory"></p><h2 id="9-6-2-利用-TLB-加速地址翻译"><a href="#9-6-2-利用-TLB-加速地址翻译" class="headerlink" title="9.6.2 利用 TLB 加速地址翻译"></a>9.6.2 利用 <strong>TLB</strong> 加速地址翻译</h2><p>页表条目 (PTEs) 与其他内存数据字一样缓存在 L1中。每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址。</p><ul><li>PTE可能被其他数据引用所替换/驱逐，导致不命中，从内存多取一次数据，代价是几十到几百个周期。</li><li>PTE 碰巧缓存在 L1 中（Cache 命中），那么开销仍需要 1~2 个周期。</li></ul><p><strong>翻译后备缓冲器 (Translation Lookaside Buffer, TLB)<strong>：MMU中一个小的具有</strong>高相联度</strong>的存储集合。</p><p>用于<strong>组选择和行匹配</strong>的索引和标记字段是从虚拟地址中的<strong>虚拟页号</strong>中提取出来的。如果 TLB 有： $$ T = 2^t $$ 个组，那么 TLB 索引(TLBI)是由 VPN 的 t 个最低位组成的，而 TLB 标记(TLBT)是由 VPN 中剩余的位组成的。</p><ol><li><p>CPU 产生一个虚拟地址.</p></li><li><p>MMU 根据 VPN 标记索引</p></li><li><p>从 TLB 中取出相应的 PTE</p></li></ol><p>  <img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105203.jpg" alt="VPNTLBPTE"></p><ol start="4"><li><p>MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</p></li><li><p>高速缓存/主存将所请求的数据字返回给 CPU。</p></li></ol><p>当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。因为局部性，TLB不命中很少发生。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105220.jpg" alt="TLB"></p><h2 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记三：软件构造过程与配置管理</title>
      <link href="/2021/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2021/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><font color="red"><strong>重点掌握：软件开发过程与版本控制工具</strong></font></p><h1 id="Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）"><a href="#Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）" class="headerlink" title="Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）"></a>Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）</h1><p>从无到有，从有到好。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144052.jpg" alt="SDLC"></p><hr><h1 id="Traditional-Software-Process-Models"><a href="#Traditional-Software-Process-Models" class="headerlink" title="Traditional Software Process Models"></a>Traditional Software Process Models</h1><blockquote><p><strong>要求</strong></p><p>区别不同开发过程模型的异同</p><p>根据不同<em>场景</em>给出相应<em>模型</em></p></blockquote><ul><li><strong>线性过程 Linear</strong>：顺序，要求一点要明确，难以更改</li><li><strong>迭代过程 Iterative</strong>：每个阶段给用户反馈，用户需求不明确</li></ul><p><strong>选择合适模型依据</strong>：用户参与程度，适应变化能力，开发效率，管理复杂段，开发出的软件质量</p><h2 id="瀑布过程-Waterfall-Linear-non-interative"><a href="#瀑布过程-Waterfall-Linear-non-interative" class="headerlink" title="瀑布过程 Waterfall (Linear, non-interative)"></a>瀑布过程 Waterfall (Linear, non-interative)</h2><p>线性推进、阶段划分清楚、整体推进、无迭代、管理简单</p><p>$$<br>\begin{aligned} conception \Rightarrow initiation \Rightarrow analysis \Rightarrow design \Rightarrow construction \Rightarrow testing \Rightarrow implementation \Rightarrow verification \Rightarrow maintenance \end{aligned}<br>$$</p><p><strong>无法适应需求增加/变化(prohibitively costly)</strong></p><p>用户只在最后一个阶段看到？？</p><h2 id="增量过程-Incremental-non-iterative"><a href="#增量过程-Incremental-non-iterative" class="headerlink" title="增量过程 Incremental (non-iterative)"></a>增量过程 Incremental (non-iterative)</h2><p>线性推进、<strong>增量式（多个瀑布的串行</strong>、无迭代、比较容易适应需求的增加</p><p>系统切成小模块，每个模块/增量Waterfall，每个模块都要能运行，模块之间不影响，模块接口要简单，要求比较稳定。</p><h2 id="V字模型-V-Model-for-verification-and-validation"><a href="#V字模型-V-Model-for-verification-and-validation" class="headerlink" title="V字模型 V-Model (for verification and validation)"></a>V字模型 V-Model (for verification and validation)</h2><p><strong>瀑布模型的扩展开发，强调每个阶段测试</strong></p><p>瀑布阶段在code阶段之后向上弯曲，对 Life Cycle 的每个阶段及相关阶段进行测试。</p><h2 id="原型过程-Prototyping-iterative"><a href="#原型过程-Prototyping-iterative" class="headerlink" title="原型过程 Prototyping (iterative)"></a>原型过程 Prototyping (iterative)</h2><p><strong>迭代</strong>：开发出来之后由<strong>用户试用/评审</strong>，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。在这个过程中，<strong>用户需求不明确</strong>，循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。</p><h2 id="螺旋模型-Spiral-iterative"><a href="#螺旋模型-Spiral-iterative" class="headerlink" title="螺旋模型 Spiral (iterative)"></a>螺旋模型 Spiral (iterative)</h2><ul><li><strong>适用于非常复杂的过程</strong></li><li><strong>多轮迭代基本遵循瀑布模式</strong> </li><li>每轮迭代有明确的目标，遵循“原型”过程，进行<strong>严格的风险分析</strong>，方可进入下一轮迭代</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144113.jpg" alt="Spiral"></p><hr><h1 id="Agile-Development-敏捷开发"><a href="#Agile-Development-敏捷开发" class="headerlink" title="Agile Development 敏捷开发"></a>Agile Development 敏捷开发</h1><blockquote><p>敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。短周期迭代。</p></blockquote><p>将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。</p><p><strong>敏捷宣言 Agile Manifesto</strong></p><ul><li>个人和交互高于过程和工具</li><li>工作软件高于全面的文档（不需要文档）</li><li>客户合作高于合同谈判（客户参与）</li><li>应对变化高于遵循计划（快速适应变化）</li></ul><p>比原型模型更适应于满足客户需求，风险较低</p><p>$$<br>Agile = 增量 + 迭代 （每次迭代处理一个小规模增量）<br>$$</p><p><strong>极限编程 (XP, eXtreme Programming)</strong></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144130.jpg" alt="XP"></p><p>协作编程（两人编程）、测试驱动、测试与编程绑定</p><p>极限编程关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。</p><hr><h1 id="Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统"><a href="#Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统" class="headerlink" title="Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统"></a>Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统</h1><p>SCM 软件配置管理：追踪和控制软件的变化。</p><p>SCI (Software Configuration Item) 软件配置项: 软件中发生变化的基本单元（如文件）。</p><p>基线：软件持续变化过程中的“<strong>稳定</strong>时刻”（例如：对外发布的版本）。</p><p>CMDB：配置管理数据库（存储软件的各配置项随时间发生变化的信息+基线），分为<strong>本地和远程</strong></p><p><em>版本</em>：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”</p><h2 id="Why-version-control-is-required"><a href="#Why-version-control-is-required" class="headerlink" title="Why version control is required"></a>Why version control is required</h2><ul><li>for individuals<ol><li>Reverting to a past version 回滚到上一个版本</li><li>Comparing two different versions 比较两个版本的差异</li><li>Pushing full version history to another location 备份软件版本历史</li><li>Pulling history back from that location 获取备份</li><li>Merging versions that are offshoots of the same earlier version 合并</li></ol></li><li>for teamwork<ol><li>Communications and share/merge works among multiple developers 在多个开发者之间<strong>共享和协作</strong></li><li>Logging individualized works of different developers for auditing 记录每个开发者的动作，便于“审计”</li></ol></li></ul><h2 id="Version-control-terminology-版本控制术语"><a href="#Version-control-terminology-版本控制术语" class="headerlink" title="Version control terminology 版本控制术语"></a>Version control terminology 版本控制术语</h2><ul><li><strong>Repository</strong>: a local or remote store of the <strong>versions</strong> in a project 仓库：即于SCM（软件配置管理）中的CMDB（配置管理数据库）</li><li><strong>Working copy</strong>: a local, editable copy of a project that we can work on 工作拷贝：在<strong>开发者本地</strong>机器上的一份项目拷贝</li><li>File: a single file in the project 文件：一个独立的配置项</li><li>Version or revision: a record of the contents of the project at a point in time 版本：在某个特定时间点的所有文件的共同状态</li><li>Change or diff: the difference between two versions 变化：即code churn，两个版本之间的差异</li><li>Head: the current version <strong>HEAD</strong>：程序员正在其上工作的版本</li></ul><h2 id="Version-Control-System-VCS"><a href="#Version-Control-System-VCS" class="headerlink" title="Version Control System (VCS)"></a>Version Control System (VCS)</h2><p><strong>三类版本控制系统</strong></p><ul><li>Local VCS 本地版本控制系统</li><li><ul><li>仓库存储于开发者<strong>本地</strong>机器无法共享和协作。</li></ul></li><li>Centralized VCS（集中式版本控制系统）</li><li><ul><li>仓库存储于<strong>独立的服务器</strong>，支持多开发者之间的协作</li></ul></li><li>Distributed VCS（分布式版本控制系统）</li><li><ul><li>仓库存储于<strong>独立的服务器+每个开发者的本地</strong>机器</li></ul></li></ul><hr><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote><p>版本图 <strong>&lt;–&gt;</strong> git命令</p><p>git文件状态 <strong>–&gt;</strong> 目录</p></blockquote><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144148.jpg" alt="gitManagement"></p><h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><blockquote><p><strong>创建</strong>本地仓库：git init</p><p>文件<strong>添加</strong>到本地仓库：git add <file></file></p><p>文件<strong>提交</strong>到本地仓库：git commit -m “commit message”</p><p>查看工作区状态：git status</p><p>比较差异修改：git diff</p><p>回到上一个版本：git reset –hard HEAD^</p><p>穿越到指定提交：git reset –hard <commit></commit></p><p>清空暂存区：git rm –cached</p><p>丢弃工作区更改: git checkout – <file></file></p><p>丢弃暂存区更改: git reset HEAD <file></file></p><p>丢弃本地版本库更改: git reset –hard HEAD^</p><p>添加远程仓库<strong>关联</strong>：git remote add origin <url></url></p><p>创建分支：git branch <branch name=""></branch></p><p>切换到分支：git checkout <branch name=""></branch></p><p>创建并切换分支：git checkout -b <branch name=""></branch></p><p>合并指定分支到当前分支：git merge <branch name="">: 如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的<strong>指针移到做过更改分支的指针的位置</strong>。如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的<strong>更改都放在一起</strong>，在工作分支上形成一个<strong>新的节点</strong>。</branch></p><p>删除分支：git branch -d <branch name="">: 只是删除分支指针，没有删除在该分支上的commit</branch></p></blockquote><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144223.jpg" alt="gitBranch1"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144207.jpg" alt="gitBranch2"></p><blockquote><p>clone: git clone -b <btanch name=""> <url></url></btanch></p><p>git push -u origin master</p><p>git push <remote name=""> <branch name="">：远程端若更改后要先与本地端合并后才能push</branch></remote></p><p>git pull <remote name=""> <branch name="">: 从远程获取最新版本并merge到本地</branch></remote></p><p>git fetch <remote name=""> <branch name="">: 从远程获取最新版本到本地，不会自动merge</branch></remote></p></blockquote><h2 id="Git-repository"><a href="#Git-repository" class="headerlink" title="Git repository"></a>Git repository</h2><ul><li><strong>.git</strong> directory: <strong>本地</strong>的 CMDB（配置管理数据库）</li><li>Working directory 工作目录：本地文件系统</li><li>Staging area 暂存区：隔离工作目录和Git仓库</li></ul><ul><li>已修改 Modified: different between file in <strong>working directory</strong> and file in <strong>git directory</strong></li><li>已暂存 Staged: file added into staging area</li><li>已提交 Committed: file keep <strong>same in working directory and git directory</strong></li></ul><h2 id="Git-Object-Graph"><a href="#Git-Object-Graph" class="headerlink" title="Git Object Graph"></a>Git Object Graph</h2><p><strong>Object Graph: 版本演化关系图，是一个有向无环图。</strong></p><p><strong>A-&gt;B</strong>: 在版本B的基础上作出变化，形成了版本A</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144238.jpg" alt="ObjectGraph"></p><p>一个父对象可以有多个子对象（<strong>创建了分支</strong>）；除了initial commit没有父对象，一个子对象的父对象最多两个（<strong>合并分支</strong>）。</p><p>branch: a name that points to a commit</p><p>HEAD: pointing to the current commit</p><p>Git Object Graph 储单个文件的每个版本一次，并允许多次提交来共享该副本。若文件没有变化，则后续多个版本始终指向同一个文件；若文件发生变化了，存储两份不同的文件，两个版本指向不同的文件。</p><p>每个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。</p><ul><li>传统VCS：存储版本之间的变化（行）。优点：存储空间较小。缺点：由于存储的是变化情况，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。</li><li>Git：存储发生变化的文件（而非代码行），不变化的文件不重复存储，这样易于取出特定版本文件、易于创建分支（创建分支时，需要进行叠加来获得当前版本）。缺点：空间复杂度增加。</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144247.jpg" alt="VCS"></p><hr><h1 id="General-process-of-software-construction"><a href="#General-process-of-software-construction" class="headerlink" title="General process of software construction"></a><em>General</em> process of software construction</h1><p>$$<br>\begin{aligned} General process of software construction 广义软件构造过程: Design \Rightarrow Programming/refactoring \Rightarrow Debugging \Rightarrow Testing \Rightarrow Build \Rightarrow Release \end{aligned}<br>$$</p><p>$$<br>\begin{aligned} Narrow-sense process of software construction (Build) 狭义软件构造过程build: Validate \Rightarrow Compile \Rightarrow Link \Rightarrow Test \Rightarrow Package \Rightarrow Install \Rightarrow Deploy \end{aligned}<br>$$</p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ul><li><strong>Construction Languages</strong></li><li><strong>purpose 用途上划分</strong><ol><li>Programming languages (e.g., C, C++, Java, Python) 编程语言</li><li>Modeling languages (e.g., UML) 建模语言</li><li>Configuration languages (e.g., XML) 配置语言</li><li>Build languages (e.g., XML) 构建语言</li></ol></li><li><strong>form 形态上划分</strong><ol><li>Linguistic-based 基于语言学的构造语言</li><li>Mathematics-based (formal) 基于数学的形式化构造语言</li><li>Graphics-based (visual) 基于图形的可视化构造语言</li></ol></li></ul><h3 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h3><p><strong>IDE 集成开发环境</strong>包括</p><ul><li><strong>Source code editor</strong> with intelligent code completion, code refactoring tool 源代码编辑器：智能代码补全工具、代码重构工具</li><li>File management tool 文件管理</li><li>Library management tool 库管理</li><li>Class browser, object browser, class hierarchy diagram 软件逻辑实体可视化</li><li>Graphical User Interface (<strong>GUI</strong>) builder 图形化用户界面构造器</li><li>Compiler, interpreter 编译器、解释器</li><li>Build automation tools 自动化build工具</li><li>Version control system 版本控制系统</li><li>Extensible by more external third-party tools 外部的第三方工具</li></ul><h3 id="Modeling-Languages"><a href="#Modeling-Languages" class="headerlink" title="Modeling Languages"></a>Modeling Languages</h3><p>目的：可视化、推理、验证和交流系统的设计。</p><p>e.g. UML (Unified Modeling Language)</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144300.jpg" alt="UMLClassDiagram"></p><h3 id="Configuration-Languages"><a href="#Configuration-Languages" class="headerlink" title="Configuration Languages"></a>Configuration Languages</h3><p>e.g. XML, YAML, JSON</p><h2 id="Review-and-static-code-analysis"><a href="#Review-and-static-code-analysis" class="headerlink" title="Review and static code analysis"></a>Review and <em>static</em> code analysis</h2><h2 id="Dynamic-code-analysis-profiling-性能测试"><a href="#Dynamic-code-analysis-profiling-性能测试" class="headerlink" title="Dynamic code analysis/ profiling 性能测试"></a>Dynamic code analysis/ profiling 性能测试</h2><h2 id="Debugging-and-Testing"><a href="#Debugging-and-Testing" class="headerlink" title="Debugging and Testing"></a>Debugging and Testing</h2><h2 id="Refactoring-重构：不改变功能的前提下优化代码"><a href="#Refactoring-重构：不改变功能的前提下优化代码" class="headerlink" title="Refactoring 重构：不改变功能的前提下优化代码"></a>Refactoring 重构：不改变功能的前提下优化代码</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记二：软件测试与测试优先编程</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>IMPORTANCE 本章重点</strong> </font></p><p><font color="red"> <strong>什么是测试</strong> </font></p><p><font color="red"> <strong>白盒测试与黑盒测试</strong> </font></p><p><font color="red"> <strong>按阶段、分步骤测试</strong> </font></p></blockquote><h1 id="1-Software-Testing"><a href="#1-Software-Testing" class="headerlink" title="1. Software Testing"></a>1. Software Testing</h1><h2 id="What-is-Testing"><a href="#What-is-Testing" class="headerlink" title="What is Testing"></a>What is Testing</h2><p>软件测试：为涉众提供有关被测试产品或服务的<strong>质量信息</strong>而进行的调查，是<strong>提高软件质量的重要手段</strong>，但是软件质量取决于设计而不是testing。</p><ul><li>寻找bug，确认是否达到可用级别(用户需求)</li><li>关注系统的某一侧面的<strong>质量特性</strong></li></ul><p>测试无法达到100%的无错误，never completely prove the absence of errors。</p><p>residual defect rates 残留缺陷率（bugs left over after the software has shipped）。对于大的系统来说，即使残留缺陷率很低，残留的bug也可能很多。</p><ul><li>1-10 defects/kloc(1000 Lines of Code)：Typical industry software</li><li>– 0.1-1 defects/kloc: High-quality validation.(Java Libraries)</li><li>0.01-0.1 defects/kloc: The very best, safety-critical validation.(NASA, Praxis)</li></ul><p>测试的目标与其他开发流程目标相反：to find errors（破坏、证错、“负能量”）</p><p>good testing： 能发现错误、不冗余、最佳特性、别太复杂也别太简单</p><h2 id="Testing-Level"><a href="#Testing-Level" class="headerlink" title="Testing Level"></a>Testing Level</h2><ul><li>Unit testing 单元测试：代码部分功能测试</li><li>Integration testing 集成测试：类、包、组件、子系统的组合执行</li><li>System testing 系统测试：完全集成的系统</li><li>Regression testing 回归测试：发现错误，改正后，前面的重新测试（自动化）</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143914.jpg" alt="TestLevel"></p><h2 id="Static-vs-Dynamic-Testing"><a href="#Static-vs-Dynamic-Testing" class="headerlink" title="Static vs. Dynamic Testing"></a>Static vs. Dynamic Testing</h2><ol><li><strong>静态测试 Static testing</strong>：without actually executing programs, 靠眼睛看，隐式的静态程序分析，review、walkthroughs、inspections</li><li><strong>动态测试 Dynamic testing</strong>：给定测试用例执行</li></ol><h2 id="Testing-vs-Debugging"><a href="#Testing-vs-Debugging" class="headerlink" title="Testing vs. Debugging"></a>Testing vs. Debugging</h2><ol><li><strong>测试</strong>：发现是否存在错误 (errors)</li><li><strong>调试</strong>：识别错误根源，消除错误 (causes of errors)</li></ol><h2 id="White-box-vs-black-box-testing"><a href="#White-box-vs-black-box-testing" class="headerlink" title=" White-box vs. black-box testing "></a><font color="red"> White-box vs. black-box testing </font></h2><ol><li><strong>白盒测试</strong>：对程序<strong>内部代码</strong>结构的测试，程序执行情况，by seeing the source code</li><li><strong>黑盒测试</strong>：对程序<strong>外部表现</strong>出来的行为的测试。just input and output，程序完成之前可以确定，用于<strong>检查代码的功能，不关心内部实现细节</strong></li></ol><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143931.jpg" alt="WhiteVSBlack-box-testing"></p><hr><h1 id="2-Test-Case"><a href="#2-Test-Case" class="headerlink" title="2. Test Case"></a>2. Test Case</h1><p><strong>测试用例：输入＋执行条件+期望结果</strong></p><p><em>E.g.</em> test cases: {2,4}, {0,0}, {-2,4} for program y=x^2</p><h1 id="3-Test-First-Programming"><a href="#3-Test-First-Programming" class="headerlink" title="3. Test-First Programming"></a>3. Test-First Programming</h1><p><strong>TDD Test-driven development</strong>：先写<strong>spec</strong> -&gt; 再写符合spec的<strong>测试用例</strong> -&gt; 写<strong>代码</strong>、<strong>执行测试</strong>、有问题再改、再执行测试用例，直到通过它</p><p>Testing First Saves a lot of time.避免将缺陷插入代码然后，减少检测到缺陷代码并删除缺陷的时间量</p><h1 id="4-Unit-Testing（单元测试）"><a href="#4-Unit-Testing（单元测试）" class="headerlink" title="4. Unit Testing（单元测试）"></a>4. Unit Testing（单元测试）</h1><p>针对软件的<strong>最小</strong>单元模型开展测试，隔离各个**模块(the software component or module)**，容易定位错误和调试。</p><h1 id="5-Automated-Unit-Testing-with-JUnit"><a href="#5-Automated-Unit-Testing-with-JUnit" class="headerlink" title="5. Automated Unit Testing with JUnit"></a>5. Automated Unit Testing with JUnit</h1><p><strong>annotation</strong>: @Test </p><p><strong>assertion methods</strong> like assertEquals, assertTrue, and assertFalse.</p><hr><h1 id="6-black-box-Testing"><a href="#6-black-box-Testing" class="headerlink" title="6.  black-box Testing "></a>6. <font color="red"> black-box Testing </font></h1><p><strong>only from the specification, not the implementation of the function</strong></p><p>黑盒测试用例根据<strong>规约</strong>、要求、设计参数来形成的。</p><p>用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。</p><h2 id="6-1-Choosing-Test-Cases-by-Partitioning-划分"><a href="#6-1-Choosing-Test-Cases-by-Partitioning-划分" class="headerlink" title="6.1 Choosing Test Cases by Partitioning 划分"></a>6.1 Choosing Test Cases by Partitioning 划分</h2><p><font color="red"> <strong>Equivalence Partitioning 等价类划分</strong> </font></p><ul><li>被测函数的<strong>输入域划分为等价类</strong>，从等价类中导出测试用例（衍生）</li><li>如果一组对象可以通过<strong>对称、传递和自反</strong>的关系链接，则存在等价类。</li><li>每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合</li></ul><p><strong>基于假设</strong>：相似的输入，将会展示相似的行为，可从每个等价类中选一个代表作为测试用例即可，可以降低测试用例数量。</p><p>等价类划分所选用例要<strong>覆盖全部类</strong>，还要考虑一些<strong>特殊情况（边界值等）</strong>：</p><ul><li>限定了数值范围：one valid and two invalid</li><li>指明了特定的值：one valid and one invalid</li><li>确定了一组数值：one valid and one invalid</li><li>输入数据是Boolean：one valid and one invalid</li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143948.jpg" alt="EquivalencPartitioningExample"></p><h2 id="Include-Boundaries-in-the-Partition"><a href="#Include-Boundaries-in-the-Partition" class="headerlink" title="Include Boundaries in the Partition"></a>Include Boundaries in the Partition</h2><p>Boundary Value Analysis (BVA) 边界测试</p><p>大量的错误发生在输入域的“边界”而非中央</p><p>边界值分析方法是对等价类划分方法的补充</p><p><strong>在等价类划分时，将边界作为等价类之一加入考虑</strong></p><h2 id="笛卡尔积：全覆盖-覆盖每个取值：最少1次即可"><a href="#笛卡尔积：全覆盖-覆盖每个取值：最少1次即可" class="headerlink" title="笛卡尔积：全覆盖/覆盖每个取值：最少1次即可"></a>笛卡尔积：全覆盖/覆盖每个取值：最少1次即可</h2><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144003.jpg" alt="BVAExample"></p><p>以此为例：</p><ol><li><strong>笛卡尔积全覆盖</strong>：3 × 5 × 5 = 75 test cases, but some combinations are impossible, such as <strong>a&lt;b, a=0, b=0</strong>（多维度多取值，组合每个维度都要有取值，但是并非所有组合情况都可能）</li><li><strong>Cover each part 覆盖每个取值最少1次即可</strong>：每个维度的每个取值至少被1个测试用例覆盖一次即可，如下。</li></ol><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144010.jpg" alt="BVAExampleAnswer"></p><p>笛卡尔积全覆盖测试完备，但用例数量多，测试代价高；后者方法测试用例少，代价低，但测试覆盖度未必高。Often we strike some compromise between these two extremes，两个极端之间做出一些<strong>妥协</strong>（出于谨慎、受白盒测试和代码覆盖工具的影响）。</p><h1 id="7-White-box-Testing"><a href="#7-White-box-Testing" class="headerlink" title="7 White-box Testing"></a>7 White-box Testing</h1><p><strong>白盒测试要考虑内部实现细节</strong>，开发人员去实现，<strong>尽量走全代码</strong>。</p><p>根据<strong>程序执行路径</strong>设计测试用例，只测试实现功能（不能测试缺失功能），不是根据需求选择的测试用例。</p><p>白盒测试可以在 unit, integration and system levels 执行，一般较早执行。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144020.jpg" alt="BlackBoxTest"></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144027.jpeg"></p><p>独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径（例如循环只需执行1次），设计测试用例使每一条<strong>基本路径被至少覆盖1次</strong>。</p><h1 id="8-Coverage-of-Testing"><a href="#8-Coverage-of-Testing" class="headerlink" title="8 Coverage of Testing"></a>8 Coverage of Testing</h1><p>Code coverage 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序（百分比衡量覆盖度）</p><p>代码覆盖度越低，测试越不充分；但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高。</p><p><strong>测试效果（难度）：路径覆盖&gt;分支覆盖&gt;语句覆盖（条件覆盖和分支覆盖没有可比性）</strong></p><p>最彻底的白盒测试是覆盖程序中的每一条路径（<strong>路径覆盖</strong>），但由于一般存在循环，路径数量巨大，难以全覆盖。</p><p> a code coverage tool EclEmma</p><p>实际中，根据预先设定的覆盖度标准，<strong>逐步增加测试用例</strong>的数量，直到覆盖度达到标准</p><h1 id="9-Automated-Testing-and-Regression-Testing"><a href="#9-Automated-Testing-and-Regression-Testing" class="headerlink" title="9 Automated Testing and Regression Testing"></a>9 Automated Testing and Regression Testing</h1><p><strong>Automated testing</strong>： 自动调用被测函数、自动判定测试结果、自动计算覆盖度。只是“测试用例的自动执行”，并非“自动生成测试用例”。A good testing framework, like <strong>JUnit</strong>, helps you build automated test suites, make  it easy to run the tests, not create test cases.</p><p><strong>Regression testing 回归测试</strong>：一旦程序被<strong>修改</strong>，重新执行之前的<strong>所有</strong>测试。</p><p>a test is good if it elicits a bug.</p><p>Automated regression testing 自动化回归测试（above 2 testing methods combined）：一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库</p><h1 id="10-Documenting-Your-Testing-Strategy"><a href="#10-Documenting-Your-Testing-Strategy" class="headerlink" title="10 Documenting Your Testing Strategy"></a>10 Documenting Your Testing Strategy</h1><p>测试策略（根据什么来选择测试用例）非常重要，需要在程序中显式记录下来。</p><p>目的：在代码评审过程中，其他人可以理解你的测试，并评判你的测试是否足够充分</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记一：软件构造的多维视图和质量目标</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="多维视图和质量目标"><a href="#多维视图和质量目标" class="headerlink" title="多维视图和质量目标"></a>多维视图和质量目标</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143514.jpg" alt="MultiDimensionalSoftwareViews"></p><hr><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143536.jpg" alt="ThreeDimension"></p><h2 id="Build-time-Views"><a href="#Build-time-Views" class="headerlink" title="Build-time Views"></a>Build-time Views</h2><p><strong>Build-time（构造阶段）</strong>：idea <strong>-&gt;</strong> requirement <strong>-&gt;</strong> design <strong>-&gt;</strong> code <strong>-&gt;</strong> installable / executable package</p><blockquote><p><strong>Code-level view（代码的逻辑组织）</strong>：source code – how source code are <em>logically</em> organized by basic program blocks such as functions（函数）, classes（类）, methods（方法）, interfaces（接口）.</p><p><strong>Component-level view（代码的物理组织）</strong>：architecture – how source code are <em>physically</em> organized by files（文件）, directories（目录）, packages（包）, libraries（库）.</p><p><strong>Moment view</strong>：what do source code and component look like <em>in a specific time</em></p><p><strong>Period view</strong>： how do they evolve/change <em>along with time</em></p></blockquote><h3 id="Build-time-moment-and-code-level-view"><a href="#Build-time-moment-and-code-level-view" class="headerlink" title="Build-time, moment, and code-level view"></a>Build-time, moment, and code-level view</h3><ul><li><strong>词汇层面</strong>：Lexical-oriented source code</li><li><strong>语法层面</strong>：Syntax-oriented program structure: e.g. Abstract Syntax Tree (AST)</li><li><strong>语义层面</strong>：Semantics-oriented program structure: e.g. Class Diagram</li></ul><p><strong>AST：</strong>彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改.</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143552.png" alt="AST"></p><p>**Class Diagram (UML)**：describe interfaces, classes, attributes, methods, and relationships among them.</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143602.jpg" alt="UML"></p><h3 id="Build-time-period-and-code-level-view"><a href="#Build-time-period-and-code-level-view" class="headerlink" title="Build-time, period, and code-level view"></a>Build-time, period, and code-level view</h3><ul><li><strong>Code churm（代码变化）</strong></li></ul><h3 id="Build-time-moment-and-component-level-view"><a href="#Build-time-moment-and-component-level-view" class="headerlink" title="Build-time, moment, and component-level view"></a>Build-time, moment, and component-level view</h3><ul><li><strong>file, package, library</strong></li><li><strong>Static linking</strong></li><li><strong>Test Case</strong></li><li>build sript(component diagram) 构建脚本（组件图）</li></ul><p>Source code (physically organize)<strong>-&gt;</strong> files (organized by directories/ encapsulated) <strong>-&gt;</strong> packages <strong>-&gt;</strong> logically components and sub-systems（组件和子系统）.</p><p>Reusable modules（可重用模块） are in the form of libraries（库）.<strong>Libraries</strong> are stored in disk files（磁盘文件）.<strong>Sources of libraries</strong>: OS pre-installed set/ language SDK/ third-party sources/ developers’ own published libraries.</p><p>When a program is edited, built and installed, a list of libraries to search must be provided.（编程、build和安装时，需要提供库路径）。Two approaches integrating a library into program: Static or Dynamic linking.</p><p><strong>Static linking</strong>：静态链接发生在构造阶段(build time), 库被拷贝进入代码形成整体，执行的时候无需提供库文件.</p><p><strong>Dynamic linking</strong>：build time 仅仅做出标记，<strong>Runtime</strong>根据标记转载至内存与主程序关联。</p><h3 id="Build-time-period-and-component-level-view"><a href="#Build-time-period-and-component-level-view" class="headerlink" title="Build-time, period, and component-level view"></a>Build-time, period, and component-level view</h3><p>How files/packeages/components/libraries change.</p><ul><li>Software Configuration Item (<strong>SCI</strong>，配置项)</li><li><strong>Version</strong> (版本)</li></ul><hr><h2 id="Runtime-views"><a href="#Runtime-views" class="headerlink" title="Runtime views"></a>Runtime views</h2><p><strong>Runtime（运行阶段）</strong>: 程序被载入目标机器以及目标机器所需磁盘文件</p><blockquote><p><strong>Code-level view</strong>: 代码层面 – 逻辑实体（程序）在<strong>内存</strong>中如何呈现，程序单元（函数、对象等）交互情况</p><p><strong>Component-level view</strong>: 构件层面 – 物理实体在<strong>物理硬件环境</strong>中如何呈现和交互？</p><p><strong>Moment view</strong>: 逻辑/物理实体在内存/硬件环境中<strong>特定时刻</strong>的形态如何？</p><p><strong>Period view</strong>: 逻辑/物理实体在内存/硬件环境中的形态随时间如何<strong>变化</strong>？</p></blockquote><h3 id="High-level-concepts-of-run-time-software"><a href="#High-level-concepts-of-run-time-software" class="headerlink" title="High-level concepts of run-time software"></a>High-level concepts of run-time software</h3><ul><li>**Executable programs (可执行程序)**：CPU执行的机器可读指令</li><li><strong>Libraries</strong></li><li><strong>Configuration and data files (配置和数据文件)</strong> that the program can load from disk</li><li>**Distributed programs (分布式程序)**：多进程</li><li><strong>Native Machine Code (原生机器码)</strong></li><li><strong>Full Program Interpretation (程序完全解释执行)</strong></li><li><strong>Interpreted Byte Codes (解释型字节码)</strong></li></ul><h3 id="Run-time-moment-and-code-level-view"><a href="#Run-time-moment-and-code-level-view" class="headerlink" title="Run-time, moment, and code-level view"></a>Run-time, moment, and code-level view</h3><ul><li><strong>Code Snapshot</strong></li><li><strong>Memory dump (内存信息转储)</strong></li></ul><p><font color="red"><strong>Snapshot Diagram</strong>：程序运行时内存里变量层面的状态。</font></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143632.jpg" alt="SnapshotDiagram1"></p><h3 id="Run-time-period-and-code-level-view"><a href="#Run-time-period-and-code-level-view" class="headerlink" title="Run-time, period and code-level view"></a>Run-time, period and code-level view</h3><ul><li>**Execution tracing (执行跟踪)**：用日志方式记录程序执行的调用次序。</li><li><strong>Concurrent multi-threads (并发多线程)</strong></li></ul><h3 id="Run-time-moment-and-component-level-view"><a href="#Run-time-moment-and-component-level-view" class="headerlink" title="Run-time, moment, and component-level view"></a>Run-time, moment, and component-level view</h3><h3 id="Run-time-period-and-component-level-view"><a href="#Run-time-period-and-component-level-view" class="headerlink" title="Run-time, period, and component-level view"></a>Run-time, period, and component-level view</h3><ul><li><strong>Event log (事件日志)</strong></li><li><strong>Multi-processes (多进程)</strong></li><li><strong>Distributed processes (分布式进程)</strong></li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143651.jpg" alt="EventLogAndExecutionTracing"></p><hr><h1 id="Transformation-between-views"><a href="#Transformation-between-views" class="headerlink" title="Transformation between views"></a>Transformation between views</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143712.jpg" alt="TransformationBetweenViews"></p><p>$$ \begin{aligned} \emptyset \Rightarrow Code\end{aligned} $$ 类、属性、方法</p><p>  Programming / Coding (ADT抽象数据类型 /OOP面向对象的程序设计)</p><p>  Review, static analysis/checking</p><p>$$ \begin{aligned} Code \Rightarrow Component \end{aligned} $$ 模块化</p><p>  Design (ADT/OOP; Reusability; Maintainability)</p><p>  Build: compile, static link, package, install, etc</p><p>$$ \begin{aligned} Build-time \Rightarrow Run-time \end{aligned} $$ 创建于运行</p><p>  Install / deploy</p><p>  Debug, unit/integration testing (Robustness and Correctness) 测试</p><p>$$ \begin{aligned} Moment \Rightarrow Perioid \end{aligned} $$ 瞬时与周期</p><p>  Version control</p><p>  Loading, dynamic linking, execution (dumping, profiling, logging)</p><p>  Concurrent threads</p><hr><h1 id="Quality-properties-of-software-systems-软件系统的质量"><a href="#Quality-properties-of-software-systems-软件系统的质量" class="headerlink" title="Quality properties of software systems (软件系统的质量)"></a>Quality properties of software systems (软件系统的质量)</h1><blockquote><p>External quality factors affect users. <strong>外部质量影响用户</strong></p><p>Internal quality factors affect the software itself and its developers. <strong>内部质量因素 影响 软件本身和它的开发者</strong></p><p>External quality results from internal quality. <strong>外部质量取决于内部质量，最终外部质量才最重要</strong></p></blockquote><h2 id="外部质量因素"><a href="#外部质量因素" class="headerlink" title="外部质量因素"></a>外部质量因素</h2><p><strong>外部质量因素：速度或易用性等质量，被用户检查</strong></p><ol><li><p><strong>Correctness (正确性)</strong>: 输入输出正确，按定义的规约 (specification)执行，这是软件开发<strong>最重要</strong>的因素。</p><ul><li>测试和调试 (Testing and debugging)：发现不正确、消除不正确</li><li>防御式编程 (Defensive programming)：在写程序的时候就确保正确性 (e.g. typing and assertions)</li><li>形式化方法 (Formal approach)：通过形式化验证发现问题</li></ul></li><li><p><strong>Robustness (健壮性)</strong>: 健壮性是针对异常情况的处理，<strong>出现异常(abnormal conditions)时不要“崩溃”</strong></p><ul><li>未被specification覆盖的情况即为”异常情况”</li><li>“narmal”和”abnormal”是主观而非客观的</li><li>产生错误信息，干净终止执行，进入“优雅”模式</li><li>出现规约定义之外的情形的时候，软件要做出恰当的反应</li></ul><p> <img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143734.jpg" alt="RobustnessVSCorrectness"></p></li><li><p><strong>Extendibility (可扩展性)</strong>: 适应规约变化的容易程度。<br>要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），降低未来修改软件时的成本。</p><ul><li><strong>Design simplicity (简约主义设计)</strong></li><li>**Decentralization (分离主义设计)**：模块化</li><li>$$ \Rightarrow ADT and OOP/ Modularity and adaptability $$</li></ul></li><li><p><strong>Reusability (可复用性)</strong>: 一次开发，多次使用，寻找共性，未来直接使用现在的这段代码。</p></li><li><p><strong>Compatibility (兼容性)</strong>: 不同的软件系统之间相互可容易的集成。</p><ul><li>保持设计的同构性</li><li>兼容性的关键是<strong>标准化</strong>，特别是标准协议。</li></ul></li><li><p><strong>Efficiency (性能)</strong>: 。</p><ul><li>性能毫无意义，除非有足够的正确性</li><li>对性能的关注要与其他质量属性进行折中</li><li>过度的优化导致软件不再适应变化和复用</li><li>不要过早的优化，性能在没有正确性保障的条件下是没有意义的</li><li>性能和其他质量目标冲突，折中处理</li></ul></li><li><p><strong>Portability (可移植性)</strong>: 软件可方便地在不同的技术环境之间移植。</p><ul><li>硬件、操作系统</li></ul></li><li><p><strong>Ease of use (易用性)</strong>: 容易学、安装、操作、监控，给用户提供详细的指南。</p><ul><li><strong>Structural simplicity (结构简单)</strong>: 易于学习使用</li><li><strong>Know the user</strong>: understand the system’s intended user community</li></ul></li><li><p><strong>Functionality (功能性)</strong>: 功能过多程序复杂、不灵活、占用过多的磁盘空间，会导致易用性的降低。</p><ul><li>每增加一小点功能，都确保其他质量属性不受到损失</li><li>主要功能要首要提升质量<br><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143749.jpg" alt="OsmondCurves"></li></ul></li><li><p> <strong>Timeliness (及时性)</strong>: 软件要能够在用户需要甚至之前，能及时地设计出来。</p></li><li><p> <strong>Other qualities</strong>: Verifiability (可验证性), Integrity (完整性), Repairability (可修复性), Economy (经济性)。</p></li></ol><hr><h2 id="内部质量因素"><a href="#内部质量因素" class="headerlink" title="内部质量因素"></a>内部质量因素</h2><p><strong>内部质量因素：软件产品品质，如模块化和可读性，开发人员才能察觉</strong></p><ul><li>代码行数 (LOC)、圈复杂度 (Cyclomatic <strong>Complexity</strong>)</li><li><ul><li>Complexity 是外部因素的 enemy</li></ul></li><li>构架相关因素：耦合 (coupling)、内聚 (cohesion)</li><li>可读性 (Readability)</li><li>可理解性 (Understandability)</li><li>整洁度 (Clearness)</li><li>大小 (Size)</li></ul><h2 id="Tradeoff-between-quality-properties-折中、妥协"><a href="#Tradeoff-between-quality-properties-折中、妥协" class="headerlink" title="Tradeoff between quality properties (折中、妥协)"></a>Tradeoff between quality properties (折中、妥协)</h2><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143812.jpg" alt="tradeoff"></p><p>以上这些质量属性之间往往不能兼得，需要权衡，某些特定要求下可以放弃优化其他项而优化另一项。</p><p>正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来。</p><p><em><strong>正确性是绝不能与其他质量因素折中的.</strong></em></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143822.jpg" alt="OOPimprovesQuality">五个关键的质量指标</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143843.jpg" alt="FiveKeyQualityObjectives"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造：实验二总结</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%EF%BC%9A%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%EF%BC%9A%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="循环判断删除list元素"><a href="#循环判断删除list元素" class="headerlink" title="循环判断删除list元素"></a>循环判断删除list元素</h1><h2 id="错误演示增强for循环"><a href="#错误演示增强for循环" class="headerlink" title="错误演示增强for循环"></a>错误演示增强for循环</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String deleteString = <span class="string">"del"</span>;</span><br><span class="line">lists.add(<span class="string">"del"</span>);</span><br><span class="line">lists.add(<span class="string">"fhd"</span>);</span><br><span class="line">lists.add(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : lists)</span><br><span class="line">    <span class="keyword">if</span> (s.equals(deleteString))</span><br><span class="line">        lists.remove(s);</span><br></pre></td></tr></tbody></table></figure><p>删除元素后继续循环会报错误信息ConcurrentModificationException，如下图所示：</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143350.jpg" alt="增强forError"></p><p><strong>直接原因：</strong><code>modCount != expectedModCount</code></p><ul><li><code>modCount</code>表示List的<code>add</code>或者<code>remove</code>方法次数</li><li><code>expectedModCount</code>是指 Iterator现在期望这个 List被修改的次数 </li></ul><p><strong>分析</strong> ：java的增强for循环根据list对象创建一个Iterator迭代对象，创建的时候modCount被赋值给了expectedModCount，但是调用<code>remove</code>方法的时候<code>modCount++</code>，但是expectedModCount没有改变，两个Count值不相等，由此抛出异常。所以不必赘述，使用iterator遍历删除的话，也会出现相同的错误。</p><h3 id="特别地"><a href="#特别地" class="headerlink" title="特别地"></a>特别地</h3><p>根据经验判断只有删除倒数第二个元素的时候不会抛出异常，删除其他元素都会抛出异常，此处就不再去追究原因。如下代码演示（将上述代码中deleteString从”del”换成”fhd”）以及结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteString = <span class="string">"fhd"</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143414.jpg" alt="forLast2delete"></p><h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><h3 id="创建一个作为条件判断的List"><a href="#创建一个作为条件判断的List" class="headerlink" title="创建一个作为条件判断的List"></a>创建一个作为条件判断的List</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s : lists)</span><br><span class="line">    res.add(s);</span><br><span class="line"><span class="keyword">for</span> (String s : res) {</span><br><span class="line">    <span class="keyword">if</span> (s.equals(deleteString))</span><br><span class="line">        lists.remove(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用removeIf方法"><a href="#使用removeIf方法" class="headerlink" title="使用removeIf方法"></a>使用<code>removeIf</code>方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists.removeIf(string-&gt;string.equals(<span class="string">"deleteString"</span>));</span><br></pre></td></tr></tbody></table></figure><p>其中 <strong>-&gt;</strong> 后面的是判断条件，符合条件的<code>string</code>就删除。 </p><hr><h1 id="关于HashMap方法的总结"><a href="#关于HashMap方法的总结" class="headerlink" title="关于HashMap方法的总结"></a>关于HashMap方法的总结</h1><h2 id="java-HashMap-插入重复key"><a href="#java-HashMap-插入重复key" class="headerlink" title="java HashMap 插入重复key"></a>java HashMap 插入重复key</h2><p>在解释插入重复key会发生什么之前，不妨先了解一下HashMap是怎么储存和运行的。</p><p><strong>储存</strong> ：首先对于一对key和value，调用key的<code>hashCode()</code>方法得到对应的bucket位置，相同hashcode的Key就储存在同一个bucket中。但HashMap并不是直接储存，而是每一个bucket都对应一个LinkedList or as Entry，如下所示。由此，相同hashcode的key放在同一LinkedList上。</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143425.png" alt="HashMap"></p><p><strong><code>put()</code>方法的实现</strong> ：首先得到待插入key的hashcode，根据此找到插入位置所在的LinkedList，之后会通过<code>equals(key)</code>方法判断是否存在键值对。对于重复的key和value，会用new value覆盖value，并返回old value；若之前不存在相应key，则返回<code>null</code>，这样就实现了key的唯一性。</p><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><ul><li><strong>浅拷贝</strong> ：HashMap的浅拷贝结果映射到与原始HashMap相同的key和value对象。</li><li><strong>深拷贝</strong> ：HashMap的深拷贝可以深入复制所有映射，为所有key、value和映射创建新对象。</li></ul><h3 id="shallow-copy-examples"><a href="#shallow-copy-examples" class="headerlink" title="shallow copy examples"></a>shallow copy examples</h3><p><strong>1.HashMap clone() method</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = originalMap.clone();</span><br></pre></td></tr></tbody></table></figure><p><strong>2.putAll() method</strong> shallow-copies all of the mappings in one step.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">shallowCopy.putAll(originalMap); </span><br></pre></td></tr></tbody></table></figure><p><strong>3.put() method</strong>  by iterating over each entry and calling the put() method on another map.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = <span class="keyword">new</span> HashMap&lt;String, <span class="keyword">int</span>&gt;();</span><br><span class="line">Set&lt;Entry&lt;String, <span class="keyword">int</span>&gt;&gt; entries = originalMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>&gt; mapEntry : entries) {</span><br><span class="line">    shallowCopy.put(mapEntry.getKey(), mapEntry.getValue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="deep-copy-examples"><a href="#deep-copy-examples" class="headerlink" title="deep copy examples"></a>deep copy examples</h3><p><strong>serialization–java序列化</strong></p><p>Use Google Gson library/ Alibaba to serialize the HashMap and deserialize.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
