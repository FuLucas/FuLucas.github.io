<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件构造笔记</title>
      <link href="/2022/01/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="多维视图和质量目标"><a href="#多维视图和质量目标" class="headerlink" title="多维视图和质量目标"></a>多维视图和质量目标</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143514.jpg" alt="MultiDimensionalSoftwareViews"></p><hr><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143536.jpg" alt="ThreeDimension"></p><h2 id="Build-time-Views"><a href="#Build-time-Views" class="headerlink" title="Build-time Views"></a>Build-time Views</h2><p><strong>Build-time（构造阶段）</strong>：idea <strong>-&gt;</strong> requirement <strong>-&gt;</strong> design <strong>-&gt;</strong> code <strong>-&gt;</strong> installable / executable package</p><blockquote><p><strong>Code-level view（代码的逻辑组织）</strong>：source code – how source code are <em>logically</em> organized by basic program blocks such as functions（函数）, classes（类）, methods（方法）, interfaces（接口）.</p><p><strong>Component-level view（代码的物理组织）</strong>：architecture – how source code are <em>physically</em> organized by files（文件）, directories（目录）, packages（包）, libraries（库）.</p><p><strong>Moment view</strong>：what do source code and component look like <em>in a specific time</em></p><p><strong>Period view</strong>： how do they evolve/change <em>along with time</em></p></blockquote><h3 id="Build-time-moment-and-code-level-view"><a href="#Build-time-moment-and-code-level-view" class="headerlink" title="Build-time, moment, and code-level view"></a>Build-time, moment, and code-level view</h3><ul><li><strong>词汇层面</strong>：Lexical-oriented source code</li><li><strong>语法层面</strong>：Syntax-oriented program structure: e.g. Abstract Syntax Tree (AST)</li><li><strong>语义层面</strong>：Semantics-oriented program structure: e.g. Class Diagram</li></ul><p><strong>AST：</strong>彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改.</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143552.png" alt="AST"></p><p>**Class Diagram (UML)**：describe interfaces, classes, attributes, methods, and relationships among them.</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143602.jpg" alt="UML"></p><h3 id="Build-time-period-and-code-level-view"><a href="#Build-time-period-and-code-level-view" class="headerlink" title="Build-time, period, and code-level view"></a>Build-time, period, and code-level view</h3><ul><li><strong>Code churm（代码变化）</strong></li></ul><h3 id="Build-time-moment-and-component-level-view"><a href="#Build-time-moment-and-component-level-view" class="headerlink" title="Build-time, moment, and component-level view"></a>Build-time, moment, and component-level view</h3><ul><li><strong>file, package, library</strong></li><li><strong>Static linking</strong></li><li><strong>Test Case</strong></li><li>build sript(component diagram) 构建脚本（组件图）</li></ul><p>Source code (physically organize)<strong>-&gt;</strong> files (organized by directories/ encapsulated) <strong>-&gt;</strong> packages <strong>-&gt;</strong> logically components and sub-systems（组件和子系统）.</p><p>Reusable modules（可重用模块） are in the form of libraries（库）.<strong>Libraries</strong> are stored in disk files（磁盘文件）.<strong>Sources of libraries</strong>: OS pre-installed set/ language SDK/ third-party sources/ developers’ own published libraries.</p><p>When a program is edited, built and installed, a list of libraries to search must be provided.（编程、build和安装时，需要提供库路径）。Two approaches integrating a library into program: Static or Dynamic linking.</p><p><strong>Static linking</strong>：静态链接发生在构造阶段(build time), 库被拷贝进入代码形成整体，执行的时候无需提供库文件.</p><p><strong>Dynamic linking</strong>：build time 仅仅做出标记，<strong>Runtime</strong>根据标记转载至内存与主程序关联。</p><h3 id="Build-time-period-and-component-level-view"><a href="#Build-time-period-and-component-level-view" class="headerlink" title="Build-time, period, and component-level view"></a>Build-time, period, and component-level view</h3><p>How files/packeages/components/libraries change.</p><ul><li>Software Configuration Item (<strong>SCI</strong>，配置项)</li><li><strong>Version</strong> (版本)</li></ul><hr><h2 id="Runtime-views"><a href="#Runtime-views" class="headerlink" title="Runtime views"></a>Runtime views</h2><p><strong>Runtime（运行阶段）</strong>: 程序被载入目标机器以及目标机器所需磁盘文件</p><blockquote><p><strong>Code-level view</strong>: 代码层面 – 逻辑实体（程序）在<strong>内存</strong>中如何呈现，程序单元（函数、对象等）交互情况</p><p><strong>Component-level view</strong>: 构件层面 – 物理实体在<strong>物理硬件环境</strong>中如何呈现和交互？</p><p><strong>Moment view</strong>: 逻辑/物理实体在内存/硬件环境中<strong>特定时刻</strong>的形态如何？</p><p><strong>Period view</strong>: 逻辑/物理实体在内存/硬件环境中的形态随时间如何<strong>变化</strong>？</p></blockquote><h3 id="High-level-concepts-of-run-time-software"><a href="#High-level-concepts-of-run-time-software" class="headerlink" title="High-level concepts of run-time software"></a>High-level concepts of run-time software</h3><ul><li>**Executable programs (可执行程序)**：CPU执行的机器可读指令</li><li><strong>Libraries</strong></li><li><strong>Configuration and data files (配置和数据文件)</strong> that the program can load from disk</li><li>**Distributed programs (分布式程序)**：多进程</li><li><strong>Native Machine Code (原生机器码)</strong></li><li><strong>Full Program Interpretation (程序完全解释执行)</strong></li><li><strong>Interpreted Byte Codes (解释型字节码)</strong></li></ul><h3 id="Run-time-moment-and-code-level-view"><a href="#Run-time-moment-and-code-level-view" class="headerlink" title="Run-time, moment, and code-level view"></a>Run-time, moment, and code-level view</h3><ul><li><strong>Code Snapshot</strong></li><li><strong>Memory dump (内存信息转储)</strong></li></ul><p><font color="red"><strong>Snapshot Diagram</strong>：程序运行时内存里变量层面的状态。</font></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143632.jpg" alt="SnapshotDiagram1"></p><h3 id="Run-time-period-and-code-level-view"><a href="#Run-time-period-and-code-level-view" class="headerlink" title="Run-time, period and code-level view"></a>Run-time, period and code-level view</h3><ul><li>**Execution tracing (执行跟踪)**：用日志方式记录程序执行的调用次序。</li><li><strong>Concurrent multi-threads (并发多线程)</strong></li></ul><h3 id="Run-time-moment-and-component-level-view"><a href="#Run-time-moment-and-component-level-view" class="headerlink" title="Run-time, moment, and component-level view"></a>Run-time, moment, and component-level view</h3><h3 id="Run-time-period-and-component-level-view"><a href="#Run-time-period-and-component-level-view" class="headerlink" title="Run-time, period, and component-level view"></a>Run-time, period, and component-level view</h3><ul><li><strong>Event log (事件日志)</strong></li><li><strong>Multi-processes (多进程)</strong></li><li><strong>Distributed processes (分布式进程)</strong></li></ul><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143651.jpg" alt="EventLogAndExecutionTracing"></p><hr><h1 id="Transformation-between-views"><a href="#Transformation-between-views" class="headerlink" title="Transformation between views"></a>Transformation between views</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143712.jpg" alt="TransformationBetweenViews"></p><p>$$ \begin{aligned} \emptyset \Rightarrow Code\end{aligned} $$ 类、属性、方法</p><p>  Programming / Coding (ADT抽象数据类型 /OOP面向对象的程序设计)</p><p>  Review, static analysis/checking</p><p>$$ \begin{aligned} Code \Rightarrow Component \end{aligned} $$ 模块化</p><p>  Design (ADT/OOP; Reusability; Maintainability)</p><p>  Build: compile, static link, package, install, etc</p><p>$$ \begin{aligned} Build-time \Rightarrow Run-time \end{aligned} $$ 创建于运行</p><p>  Install / deploy</p><p>  Debug, unit/integration testing (Robustness and Correctness) 测试</p><p>$$ \begin{aligned} Moment \Rightarrow Perioid \end{aligned} $$ 瞬时与周期</p><p>  Version control</p><p>  Loading, dynamic linking, execution (dumping, profiling, logging)</p><p>  Concurrent threads</p><hr><h1 id="Quality-properties-of-software-systems-软件系统的质量"><a href="#Quality-properties-of-software-systems-软件系统的质量" class="headerlink" title="Quality properties of software systems (软件系统的质量)"></a>Quality properties of software systems (软件系统的质量)</h1><blockquote><p>External quality factors affect users. <strong>外部质量影响用户</strong></p><p>Internal quality factors affect the software itself and its developers. <strong>内部质量因素 影响 软件本身和它的开发者</strong></p><p>External quality results from internal quality. <strong>外部质量取决于内部质量，最终外部质量才最重要</strong></p></blockquote><h2 id="外部质量因素"><a href="#外部质量因素" class="headerlink" title="外部质量因素"></a>外部质量因素</h2><p><strong>外部质量因素：速度或易用性等质量，被用户检查</strong></p><ol><li><p><strong>Correctness (正确性)</strong>: 输入输出正确，按定义的规约 (specification)执行，这是软件开发<strong>最重要</strong>的因素。</p><ul><li>测试和调试 (Testing and debugging)：发现不正确、消除不正确</li><li>防御式编程 (Defensive programming)：在写程序的时候就确保正确性 (e.g. typing and assertions)</li><li>形式化方法 (Formal approach)：通过形式化验证发现问题</li></ul></li><li><p><strong>Robustness (健壮性)</strong>: 健壮性是针对异常情况的处理，<strong>出现异常(abnormal conditions)时不要“崩溃”</strong></p><ul><li>未被specification覆盖的情况即为”异常情况”</li><li>“narmal”和”abnormal”是主观而非客观的</li><li>产生错误信息，干净终止执行，进入“优雅”模式</li><li>出现规约定义之外的情形的时候，软件要做出恰当的反应</li></ul><p> <img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143734.jpg" alt="RobustnessVSCorrectness"></p></li><li><p><strong>Extendibility (可扩展性)</strong>: 适应规约变化的容易程度。<br>要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），降低未来修改软件时的成本。</p><ul><li><strong>Design simplicity (简约主义设计)</strong></li><li>**Decentralization (分离主义设计)**：模块化</li><li>$$ \Rightarrow ADT and OOP/ Modularity and adaptability $$</li></ul></li><li><p><strong>Reusability (可复用性)</strong>: 一次开发，多次使用，寻找共性，未来直接使用现在的这段代码。</p></li><li><p><strong>Compatibility (兼容性)</strong>: 不同的软件系统之间相互可容易的集成。</p><ul><li>保持设计的同构性</li><li>兼容性的关键是<strong>标准化</strong>，特别是标准协议。</li></ul></li><li><p><strong>Efficiency (性能)</strong>: 。</p><ul><li>性能毫无意义，除非有足够的正确性</li><li>对性能的关注要与其他质量属性进行折中</li><li>过度的优化导致软件不再适应变化和复用</li><li>不要过早的优化，性能在没有正确性保障的条件下是没有意义的</li><li>性能和其他质量目标冲突，折中处理</li></ul></li><li><p><strong>Portability (可移植性)</strong>: 软件可方便地在不同的技术环境之间移植。</p><ul><li>硬件、操作系统</li></ul></li><li><p><strong>Ease of use (易用性)</strong>: 容易学、安装、操作、监控，给用户提供详细的指南。</p><ul><li><strong>Structural simplicity (结构简单)</strong>: 易于学习使用</li><li><strong>Know the user</strong>: understand the system’s intended user community</li></ul></li><li><p><strong>Functionality (功能性)</strong>: 功能过多程序复杂、不灵活、占用过多的磁盘空间，会导致易用性的降低。</p><ul><li>每增加一小点功能，都确保其他质量属性不受到损失</li><li>主要功能要首要提升质量<br><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143749.jpg" alt="OsmondCurves"></li></ul></li><li><p><strong>Timeliness (及时性)</strong>: 软件要能够在用户需要甚至之前，能及时地设计出来。</p></li><li><p><strong>Other qualities</strong>: Verifiability (可验证性), Integrity (完整性), Repairability (可修复性), Economy (经济性)。</p></li></ol><hr><h2 id="内部质量因素"><a href="#内部质量因素" class="headerlink" title="内部质量因素"></a>内部质量因素</h2><p><strong>内部质量因素：软件产品品质，如模块化和可读性，开发人员才能察觉</strong></p><ul><li>代码行数 (LOC)、圈复杂度 (Cyclomatic <strong>Complexity</strong>)</li><li><ul><li>Complexity 是外部因素的 enemy</li></ul></li><li>构架相关因素：耦合 (coupling)、内聚 (cohesion)</li><li>可读性 (Readability)</li><li>可理解性 (Understandability)</li><li>整洁度 (Clearness)</li><li>大小 (Size)</li></ul><h2 id="Tradeoff-between-quality-properties-折中、妥协"><a href="#Tradeoff-between-quality-properties-折中、妥协" class="headerlink" title="Tradeoff between quality properties (折中、妥协)"></a>Tradeoff between quality properties (折中、妥协)</h2><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143812.jpg" alt="tradeoff"></p><p>以上这些质量属性之间往往不能兼得，需要权衡，某些特定要求下可以放弃优化其他项而优化另一项。</p><p>正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来。</p><p><em><strong>正确性是绝不能与其他质量因素折中的.</strong></em></p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143822.jpg" alt="OOPimprovesQuality">五个关键的质量指标</p><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718143843.jpg" alt="FiveKeyQualityObjectives"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
