<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件构造笔记六：ADT抽象数据类型</title>
      <link href="/2021/07/04/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
      <url>/2021/07/04/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>抽象数据类型</strong> </font></p><p><font color="red"> <strong>表示泄露</strong> </font></p><p><font color="red"> <strong>AF</strong> </font></p><p><font color="red"> <strong>RI</strong> </font></p></blockquote><h1 id="Abstraction-and-User-Defined-Types-抽象和用户定义的类型"><a href="#Abstraction-and-User-Defined-Types-抽象和用户定义的类型" class="headerlink" title="Abstraction and User-Defined Types 抽象和用户定义的类型"></a>Abstraction and User-Defined Types 抽象和用户定义的类型</h1><p>抽象类型：强调“作用于数据上的操作”，程序员和client<strong>无需关心数据如何具体存储</strong>的，只需设计/使用<strong>操作</strong>即可。</p><p>ADT是由操作定义的，与其内部如何实现无关！</p><h1 id="2-Classifying-Types-and-Operations-分类类型和操作"><a href="#2-Classifying-Types-and-Operations-分类类型和操作" class="headerlink" title="2 Classifying Types and Operations 分类类型和操作"></a>2 Classifying Types and Operations 分类类型和操作</h1><p>可变类型的对象：提供了可改变其内部数据的值的操作。不变数据类型： 其操作不改变内部值，而是<strong>构造新的对象</strong></p><ul><li><font color="red"> Creator 构造器 </font> 可以将对象作为参数，但是不能把对象类型作为构造对象。(t* -&gt; T)</li><li><font color="red"> Producer 生产器 </font> 例如 String 的 contact 方法，将两个两个字符串连接为一个新的字符串。(T+, t* -&gt; T)</li><li><font color="red"> Observer 观察器 </font> 参看数据，例如 size() 方法。(T+, t* -&gt; t)</li><li><font color="red"> Mutator 变值器 </font> 改变对象属性的方法，例如 List 的 add() 方法。(T+, t* -&gt; void | t | T)</li></ul><p>其中T代表抽象类型，t代表其他类型。</p><h2 id="creator-构造器"><a href="#creator-构造器" class="headerlink" title="creator 构造器"></a>creator 构造器</h2><p>A creator is either implemented as a <strong>constructor</strong> , like new ArrayList(), or simply <strong>a static method</strong> instead, like Arrays.asList(), List.of(). 构造器：可能实现为构造函数或静态函数。</p><p>factory method 工厂方法：a creator implemented as a static method.</p><h2 id="mutator-变值器"><a href="#mutator-变值器" class="headerlink" title="mutator 变值器"></a>mutator 变值器</h2><p>变值器通常返回 void，变值器也可能返回非空类型。</p><h1 id="3-Abstract-Data-Type-Examples"><a href="#3-Abstract-Data-Type-Examples" class="headerlink" title="3 Abstract Data Type Examples"></a>3 Abstract Data Type Examples</h1><p><strong>只有 mutable 数据类型才有 mutator（这改变具体的对象）</strong></p><table><thead><tr><th>数据类型</th><th>Operations</th></tr></thead><tbody><tr><td>int(immutable)</td><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144710.jpg" alt="int"></td></tr><tr><td>String(immutable)</td><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144754.jpg" alt="String"></td></tr><tr><td>List(mutable)</td><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144741.jpeg" alt="List"></td></tr></tbody></table><h1 id="4-Designing-an-Abstract-Type-设计抽象类型"><a href="#4-Designing-an-Abstract-Type-设计抽象类型" class="headerlink" title="4 Designing an Abstract Type 设计抽象类型"></a>4 Designing an Abstract Type 设计抽象类型</h1><p>设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约 spec.</p><ol><li>Rules of thumb 1 设计简洁、一致的操作</li><li>Rules of thumb 2 要足以支持client对数据所做的所有操作需要，且用操作满足client需要的难度要低</li></ol><h1 id="5-Representation-Independence-表示独立性"><a href="#5-Representation-Independence-表示独立性" class="headerlink" title="5  Representation Independence 表示独立性 "></a>5 <font color="red"> Representation Independence 表示独立性 </font></h1><p><strong>表示独立性</strong>：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。</p><p>抽象类型的使用与其表示（用于实现它的实际数据结构或数据字段）无关，因此表示的更改不会影响抽象类型本身之外的代码。</p><p>除非ADT的操作指明了具体的pre-和post-condition，否则不能改变ADT的内部表示——spec规定了client和implementer之间的契约。</p><h1 id="6-Testing-an-Abstract-Data-Type"><a href="#6-Testing-an-Abstract-Data-Type" class="headerlink" title="6 Testing an Abstract Data Type"></a>6 Testing an Abstract Data Type</h1><ul><li>测试creators, producers, and mutators：调用observers来观察这些operations的结果是否满足spec；</li><li>测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。</li></ul><h1 id="7-Invariants-不变性"><a href="#7-Invariants-不变性" class="headerlink" title="7 Invariants 不变性"></a>7 Invariants 不变性</h1><p>不变量 Invariant：在任何时候总是true，immutability 就是一个典型的“不变量”（一旦被创建始终表示相同的值），不变量由ADT来负责。</p><p>Invariants：(1) <strong>private</strong>（限制只能在<strong>类中</strong>访问的 fields 和方法）; (2) immutable type; (3) 对于 mutable 外部引用可以直接改变属性的值，所以考虑 copy; (4) final（保证在构造对象后不会重新分配此不可变类型的字段）。当代价很高时，将不变性交给用户（写到规约），但由此引发的bug会很多。</p><p>representation exposure 表示泄露：类以外的代码也能直接地修改表示。不仅影响不变性，也影响了表示独立性：无法在不影响客户端的情况下改变其内部表示。</p><p>除非迫不得已，否则不要把希望寄托于客户端上，ADT有责任保证自己的invariants，并避免“表示泄露”。最好的办法就是使用 immutable 的类型，彻底避免表示泄露（例如用 java.time.ZonedDateTime 而不是 mutable java.util.Date）</p><ul><li>Don’t incorporate mutable parameters into object; make defensive copies</li><li>Return defensive copies of mutable fields…</li><li>Or return unmodifiable view of mutable fields</li><li>Real lesson – use immutable components, to eliminate the need for defensive copying</li></ul><h1 id="8-Rep-Invariant-and-Abstraction-Function-RI-AF"><a href="#8-Rep-Invariant-and-Abstraction-Function-RI-AF" class="headerlink" title="8  Rep Invariant and Abstraction Function (RI AF) "></a>8 <font color="red"> Rep Invariant and Abstraction Function (RI AF) </font></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记五：设计规约</title>
      <link href="/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
      <url>/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>规约的强度及其比较</strong> </font></p><p><font color="red"> <strong>如何写出好的规约</strong> </font></p></blockquote><h1 id="Functions-amp-methods-in-programming-languages"><a href="#Functions-amp-methods-in-programming-languages" class="headerlink" title="Functions &amp; methods in programming languages"></a>Functions &amp; methods in programming languages</h1><p>返回值类型是否匹配、参数类型是否匹配，在静态类型检查阶段完成</p><p>使用“方法”的客户端，无需了解方法内部（方法体信息隐藏）具体如何工作—“抽象”。</p><h1 id="2-Specification-Programming-for-communication"><a href="#2-Specification-Programming-for-communication" class="headerlink" title="2 Specification: Programming for communication"></a>2 Specification: Programming for communication</h1><p>API：应用程序编程接口</p><h2 id="Documenting-in-programming"><a href="#Documenting-in-programming" class="headerlink" title="Documenting in programming"></a>Documenting in programming</h2><p>“假设”写什么？变量的数据类型定义、final关键字定义了设计决策-“不可改变”、方法假设策略</p><p>为什么写？：自己记不住、别人不懂</p><p>编程时注意两点目标：代码中蕴含的“设计决策”–给编译器读；注释形式的“设计决策”–给自己和别人读。就是依据假设来进行编程，编程过程需要考虑编译器和读者两部分人。</p><h2 id="Specification-and-Contract-of-a-method"><a href="#Specification-and-Contract-of-a-method" class="headerlink" title="Specification and Contract (of a method)"></a>Specification and Contract (of a method)</h2><p>Spec给“供需双方”都确定了责任，在调用的时候双方都要遵守：输入输出的数据类型、功能和正确性、性能（只讲能做什么，不讲怎么实现）</p><h2 id="Behavioral-equivalence-行为等价性"><a href="#Behavioral-equivalence-行为等价性" class="headerlink" title=" Behavioral equivalence 行为等价性 "></a><font color="red"> Behavioral equivalence 行为等价性 </font></h2><p>怎么判断是否行为等价性：是否可以用一种实现替代另一种实现（站在客户端视角，前置条件和后置条件）</p><p>根据规约判断行为等价性</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144614.jpg" alt="BehaviorEquivalence"></p><h2 id="Specification-structure-pre-condition-and-post-condition"><a href="#Specification-structure-pre-condition-and-post-condition" class="headerlink" title="Specification structure: pre-condition and post-condition"></a>Specification structure: pre-condition and post-condition</h2><p>方法规约包含几个条文：</p><ol><li>Precondition 前置条件：对<strong>客户</strong>端的约束，在使用方法时必须满足的条件（参数），indicated by the keyword <code>requires</code></li><li>Postcondition 后置条件：对<strong>开发者</strong>的约束，方法结束时必须满足的条件（返回值），indicated by the keyword <code>effects</code></li><li>Exceptional behavior 异常行为：如果违反先决条件它会做什么。契约–如果前置条件满足了，后置条件必须满足（可以通过抛出异常、修改或不修改对象等来遵循后置条件）；如果前置条件不满足，则方法可以做任何事。</li></ol><p>Java 的静态类型声明是一种规约，可据此进行静态类型检查static checking。方法前的注释也是一种规约，但需人工判定其是否满足。前置条件前置条件写进参数 <code>@param</code>，后置条件结果<code>@return, @throws</code></p><p>方法的规约不应该谈论方法的局部变量或方法类的私有字段。</p><p>除非在后置条件里声明过，否则方法内部<strong>不应该改变输入参数</strong>，应尽量不改变输入参数，尽量不设计mutating的spec，<strong>应该尽量避免使用mutable的对象</strong>，否则就容易引发bugs、降低可变性、复杂化规约。（多个引用指向同一个对象，任意一个引用修改其他的也会引起变化）。</p><h2 id="Testing-and-verifying-specifications"><a href="#Testing-and-verifying-specifications" class="headerlink" title="Testing and verifying specifications"></a>Testing and verifying specifications</h2><p>依据规约进行黑盒测试（不依赖具体实现，但测试必须遵守契约）。</p><h1 id="Designing-specifications"><a href="#Designing-specifications" class="headerlink" title=" Designing specifications "></a><font color="red"> Designing specifications </font></h1><h2 id="Classifying-specifications"><a href="#Classifying-specifications" class="headerlink" title="Classifying specifications"></a>Classifying specifications</h2><p>规约的确定性（输出）、规约的陈述性（输出什么或怎么得到输出）、规约的强度（合法实现的多少）</p><p><font color="red"> <strong>规约强度越高 (Stronger)，则可以用规约强度高的来代替强度弱的，那么如何比较强度？</strong> </font></p><p>更放松的前置条件+更严格的后置条件</p><p>越强的规约，意味着implementor的自由度和责任越重，而client的责任越轻（输入内容约束更少）。</p><p><em>下面是两个可以比较、不能比较规约强弱的实例</em></p><table><thead><tr><th>无法比较</th><th>后者更强</th></tr></thead><tbody><tr><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144631.jpeg"></td><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144637.jpg" alt="StrongerVSWeakerSpecs2"></td></tr></tbody></table><h2 id="Diagramming-specifications-制图规约"><a href="#Diagramming-specifications-制图规约" class="headerlink" title="Diagramming specifications 制图规约"></a>Diagramming specifications 制图规约</h2><p>某个具体实现，若满足规约，则落在其范围内；否则，在其之外。程序员可以在规约的范围内自由选择实现方式，客户端无需了解具体实现。<strong>更强的规约，表达为更小的区域</strong></p><ul><li>更强的后置条件意味着实现的自由度更低了-&gt;在图中的面积更小</li><li>更弱的前置条件意味着实现时要处理更多的可能输入，实现的自由度低了-&gt;面积更小</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144645.jpg" alt="DiagrammingSpecifications"></p><h2 id="Designing-good-specifications"><a href="#Designing-good-specifications" class="headerlink" title="Designing good specifications"></a>Designing good specifications</h2><ol><li><strong>内聚coherent</strong>：Spec描述的功能应单一、简单、易理解</li><li><strong>strong enough</strong>：太弱的spec，client不放心、不敢用 (因为没有给出足够的承诺)。开发者应尽可能考虑各种特殊情况，在post-condition给出处理措施。</li><li><strong>weak enough</strong>：太强的spec，在很多特殊情况下难以达到，给开发者增加了实现的难度。</li><li><strong>use abstract types</strong>：在规约里使用<strong>抽象类型</strong>，可以给方法的实现体与客户端更大的自由度。在Java中这意味着使用接口类型，像 Map、Reader 而不是具体实现类型像 HashMap、FileReader。</li><li><strong>Precondition or postcondition</strong>：是否使用前置条件取决于(1) check的代价；(2) 方法的使用范围。如果只在类的内部使用该方法(private)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client；如果在其他地方使用该方法(public)，那么必须要使用前置条件，若client端不满足则方法抛出异常。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记四：数据类型与类型检验</title>
      <link href="/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
      <url>/2021/07/03/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>数据数据类型及定义，检测方式</strong> </font></p><p><font color="red"> <strong>Mutable, Immutable</strong> </font></p><p><font color="red"> <strong>snapshot图解析数据类型</strong> </font></p></blockquote><h1 id="1-Data-type-in-programming-languages-数据类型"><a href="#1-Data-type-in-programming-languages-数据类型" class="headerlink" title="1 Data type in programming languages 数据类型"></a>1 Data type in programming languages 数据类型</h1><p>A type is a <strong>set of values</strong>, along with <strong>operations</strong> that can be performed on those values. 数据类型 = <strong>一组</strong>值 + 可执行操作</p><ul><li>primitive types 基本数据类型：int, long, boolean, double, char</li><li>object types 对象数据类型：String, BigInteger</li><li>Java 约定：基本数据类型是小写字母开头，对象数据类型是大写字母开头</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144329.jpg" alt="PrimitiveObject"></p><p>对象类型层次结构：root is Object, all non-primitives are objects 继承关系</p><h1 id="2-Static-vs-dynamic-data-type-checking"><a href="#2-Static-vs-dynamic-data-type-checking" class="headerlink" title="2 Static vs. dynamic data type checking"></a>2 Static vs. dynamic data type checking</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换向下兼容</span></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">2</span>; <span class="comment">// a = 2.0(Implicit)</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">18.7</span>; <span class="comment">// ERROR</span></span><br></pre></td></tr></tbody></table></figure><p>Java 是静态类型语言</p><p>变量的类型在编译时（在程序运行之前）已知，因此编译器也可以推断出所有表达式的类型（编译阶段进行类型检查）。</p><p>动态类型语言像 Python，这种检测将推迟到程序运行阶段。</p><h2 id="Static-Checking-and-Dynamic-Checking"><a href="#Static-Checking-and-Dynamic-Checking" class="headerlink" title="Static Checking and Dynamic Checking"></a>Static Checking and Dynamic Checking</h2><ul><li><strong>静态类型检查</strong>：在程序运行前自动发现错误。往往是关于类型的检测，不考虑值。</li><li><strong>动态类型检查</strong>：必须运行程序，通过某种约束条件，对变量的值检测。往往是关于值的检测。</li><li><strong>无检查</strong> </li><li><strong>动态类型检查 &gt;&gt; 静态 &gt;&gt; 无检查</strong>，静态检测能检测就没必要用动态。</li></ul><p>静态类型检查：可在<strong>编译阶段（编译器的工作）</strong>发现错误，避免了将错误带入到运行阶段，可提高程序正确性/健壮性。静态类型可以防止一大类错误，例如应用于<strong>错误类型的参数</strong>所导致的错误， “5” * “6” 字符串类型乘法这个错误在编程时被捕获。</p><h3 id="静态类型检测能检测什么？"><a href="#静态类型检测能检测什么？" class="headerlink" title="静态类型检测能检测什么？"></a>静态类型检测能检测什么？</h3><p><strong>考虑编程过程会报哪些错误</strong></p><ul><li>Syntax errors 语法错误</li><li>Wrong names 类名/函数名错误</li><li>Wrong number of arguments 参数数目错误</li><li>Wrong argument types 参数类型错误：例如Type mismatch: cannot convert from int to boolean</li><li>Wrong return types 返回值类型错误</li><li>final变量，不被编译器相信只赋值了一次</li></ul><h3 id="动态类型检测能检测什么？"><a href="#动态类型检测能检测什么？" class="headerlink" title="动态类型检测能检测什么？"></a>动态类型检测能检测什么？</h3><ul><li>Illegal argument values 非法的参数值：例如divide-by-zero</li><li>Unrepresentable return values 非法的返回值，即特定的返回值不能用类型表示</li><li>Out-of-range indexes 越界</li><li>Calling a method on a null object reference. 空指针</li></ul><h1 id="3-Mutability-and-Immutability"><a href="#3-Mutability-and-Immutability" class="headerlink" title=" 3 Mutability and Immutability  "></a><font color="red"> 3 Mutability and Immutability  </font></h1><p>这是一个对”类“的概念，基本数据类型无效</p><ul><li>改变一个变量：将该变量指向另一个值的<strong>存储空间</strong>。</li><li>改变一个变量的值：将该变量当前指向的值的存储空间中写入一个新的<strong>值</strong>。</li></ul><p>Immutable types: 一旦被创建，其<strong>值</strong>不能改变。</p><p>Java中基本数据类型一定是Immutable的。如果是引用类型，也可以是不变的：一旦确定其指向的对象，不能再被改变。</p><p><strong>final</strong>保证了引用不变性，<strong>immutable</strong>是限制存储空间内容的不变性。</p><p>如果 Java 编译器不相信 final 变量在运行时只会被赋值一次，那么它就会产生一个<strong>编译器</strong>错误。 所以 final 提供了对不可变引用的静态检查。</p><p>尽可能多的用 final 来声明方法输入参数和作为局部变量</p><ul><li>A final <strong>class</strong> declaration cannot be inherited. final class 不能被继承/无法派生</li><li>A final <strong>variable</strong> always contains the same value/reference but cannot be changed. final变量无法改变值/引用</li><li>A final method cannot be overridden by subclasses. final方法无法被子类重写，只能继承</li></ul><p>String 类型是 immutable 类型，StringBuilder 是 mutable 类型</p><table><thead><tr><th>String</th><th>StringBuilder</th></tr></thead><tbody><tr><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144347.jpg" alt="String"></td><td><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144357.jpg" alt="StringBuilder"></td></tr><tr><td>String s = “a”;</td><td>StringBuilder sb = new StringBuilder(“a”);</td></tr><tr><td>s = s.contact(“b”);</td><td>sb.append(“b”);</td></tr></tbody></table><p>当只有一个引用指向该值其实没什么区别，但是多个引用时就体现了区别。</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144418.jpg" alt="MulitReferences"></p><p>Immutable 类型，频繁修改会产生大量的临时拷贝(需要垃圾回收)。</p><p>Mutable 类型最少化拷贝以<strong>提高效率性能</strong>。</p><p>Immutable 类型更“<strong>安全</strong>”。</p><p>避免由mutable类型带来的错误：</p><ol><li>defensive copy：防御式拷贝，给客户端返回一个全新对象，可能造成大量的内存浪费</li><li>使用不可变类型，则节省了频繁复制的代价</li></ol><p>安全的使用可变类型：局部变量，不会涉及共享；只有一个引用</p><p>对同一个可变对象如果有多个引用（别名），就非常不安全</p><h1 id="4-Snapshot-diagram-as-a-code-level-run-time-and-moment-view"><a href="#4-Snapshot-diagram-as-a-code-level-run-time-and-moment-view" class="headerlink" title=" 4 Snapshot diagram as a code-level, run-time, and moment view "></a><font color="red"> 4 Snapshot diagram as a code-level, run-time, and moment view </font></h1><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144443.jpg" alt="SnapshotRule1"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144449.jpg" alt="SnapshotRule2"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144455.jpg" alt="SnapshotRule3"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144505.jpg" alt="SnapshotRule4"></p><p>An immutable/unreassignable reference to a mutable value：引用是不可变的，但指向的值却可以是可变的，例如：final StringBuilder sb</p><p>A mutable/reassignable reference to an immutable value：可变的引用，也可指向不可变的值，例如：String s</p><h1 id="5-Complex-data-types-Arrays-and-Collections"><a href="#5-Complex-data-types-Arrays-and-Collections" class="headerlink" title="5 Complex data types: Arrays and Collections"></a>5 Complex data types: Arrays and Collections</h1><p>List, Set, Map 都是接口</p><p>Iterator as a <strong>mutable</strong> type 迭代器：next()，hasNext()</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144432.jpg" alt="Iterator"></p><p>List和迭代器都属于mutable，上图中用迭代器来循环删除某个对象，后面的对象会向前对齐。</p><p><a href="https://fhdfhd.cn/software-construction/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/">关于迭代和循环</a></p><h1 id="6-Useful-immutable-types"><a href="#6-Useful-immutable-types" class="headerlink" title="6 Useful immutable types"></a>6 Useful immutable types</h1><ul><li>基本类型及其封装对象类型都是不可变的</li><li>Don’t use mutable Date, </li><li>Collections types – List, Set, Map are all mutable.</li><li>包装器来获得 unmodifiable 不可变 collections：例如，<code>List S = Collections.unmodifiableList(t);</code>。这种不可变是在运行阶段获得的，编译阶段无法静态检查，并且只是增加了一个新的相同引用，对<code>t</code>修改也会报错。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashSet</title>
      <link href="/2021/06/29/HashSet/"/>
      <url>/2021/06/29/HashSet/</url>
      
        <content type="html"><![CDATA[<h1 id="HashSet添加元素时如何保证不重复"><a href="#HashSet添加元素时如何保证不重复" class="headerlink" title="HashSet添加元素时如何保证不重复"></a>HashSet添加元素时如何保证不重复</h1><p>调用 <code>add（Object</code> 方法时，首先会调用 Object 的 <code>hashCode</code> 方法判 hashCode 是否已经存在 HashCode 相同的元素，如不存在则直接插入元素；如果已存在，则调用 Object 对象的 equals 方法判断是否返回true， 如果为 true 则说明元素已经存在，如为false则插入元素。</p><p><strong>可以认为HashMap的key是不能重复的，而这里HashSet的元素是作为了map的key，所以也不能重复。</strong></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718104050.png" alt="image-20210718104050829"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210914180928.png" alt="image-20210914180921174"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java静态实例方法</title>
      <link href="/2021/06/29/Java%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2021/06/29/Java%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h1><p>类可以有两种类型的方法：<strong>实例方法（非静态方法）和类（静态方法）方法</strong>。实例方法用于实现类的实例的行为，只能在类的实例的上下文中调用。类方法用于实现类本身的行为，类方法总是在类的上下文中执行，但也能在类的实例的上下文中调用。</p><p>用静态修饰符(static)定义类方法，若缺少则为实例方法。</p><h1 id="静态方法和实例方法的调用"><a href="#静态方法和实例方法的调用" class="headerlink" title="静态方法和实例方法的调用"></a>静态方法和实例方法的调用</h1><ol><li>外部调用静态方法时：<em>类名.方法名/对象名.方法名</em>；调用实例方法：<em>对象名.方法名</em>，即<strong>调用静态方法不需要创建对象</strong>。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticMethod</span> </span>{</span><br><span class="line">    <span class="comment">// a static method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callStatic</span><span class="params">()</span> </span>{</span><br><span class="line">   　　 System.out.println(<span class="string">"static method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">invokeStaticMethod</span> </span>{</span><br><span class="line">   　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">      　　staticMethod.callStatic(); <span class="comment">// no object</span></span><br><span class="line">      　　staticMethod s = <span class="keyword">new</span> staticMethod();  <span class="comment">// create an object</span></span><br><span class="line">      　　s.callStatic(); <span class="comment">// call the static method through the object</span></span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制,可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记九：面向复用的软件构造技术</title>
      <link href="/2021/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/"/>
      <url>/2021/06/29/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B9%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="Software-Reuse"><a href="#Software-Reuse" class="headerlink" title="Software Reuse"></a>Software Reuse</h1><p>优点：降低成本和开发时间；经过充分测试，可靠、稳定；标准化，在不同应用中保持一致。</p><p>缺点：开发可复用的软件（性能差，缺少针对性）和使用已有软件进行开发（需要适配）都需要代价。</p><p><strong>measure “reusability”</strong>：复用的机会有多频繁；复用的代价有多大（搜索、获取，适配、扩展，实例化，与软件其他部分的互连的难度）</p><p>最主要的复用是在代码层面，但软件构造过程中的任何实体都可能被复用（包括需求、规约spec、数据、测试用例、文档等）</p><ul><li><p>Source code level: methods, statements, etc (lowest level)</p></li><li><p>Module level: class and interface</p></li><li><p>Library level: API (Java Library, .jar)</p></li><li><p>Architecture level: framework 框架</p></li><li><p>白盒复用：源代码可见，可修改和扩展（继承）。复制已有代码到正在开发的系统，进行修改；Pro：可定制化程度高；Con：对其修改增加了软件的复杂度，且需要对其内部充分的了解。</p></li><li><p>黑盒复用：源代码不可见，不能修改（委托）。 只能通过API接口来使用，无法修改代码；Pro：简单清晰；Con：适应性差。</p></li></ul><p>框架：一组具体类、抽象类、及其之间的连接关系。开发者根据framework的规约，填充自己的代码进去，形成完整系统。</p><p>Whitebox frameworks 白盒框架，通过代码层面的继承和动态绑定进行框架扩展。</p><p>Blackbox frameworks 黑盒框架，通过实现特定接口/delegation进行框架扩展。</p><h1 id="Designing-reusable-classes"><a href="#Designing-reusable-classes" class="headerlink" title=" Designing reusable classes "></a><font color="red"> Designing reusable classes </font></h1><blockquote><p><font color="red"> <strong>Behavioral subtyping 行为子类型与 Liskov 可替换原则 (LSP)</strong> </font></p><p><font color="red"> <strong>委托与组合</strong> </font></p></blockquote><h2 id="Behavioral-subtyping-and-Liskov-Substitution-Principle-LSP"><a href="#Behavioral-subtyping-and-Liskov-Substitution-Principle-LSP" class="headerlink" title="Behavioral subtyping and Liskov Substitution Principle (LSP)"></a>Behavioral subtyping and Liskov Substitution Principle (LSP)</h2><h3 id="行为子类型"><a href="#行为子类型" class="headerlink" title="行为子类型"></a>行为子类型</h3><p><strong>Compiler-enforced rules in Java (static type checking)</strong></p><ul><li>子类型可以增加方法，但不可删</li><li>子类型需要实现抽象类型中的所有未实现方法</li><li>子类型中重写的方法必须有相同或子类型的返回值或者符合co-variance（协方差）的参数</li><li>子类型中重写的方法必须使用同样类型的参数或者符合contra-variance（反方差）的参数</li><li>子类型中重写的方法不能抛出额外的异常</li></ul><p>指定行为（方法）</p><ul><li>更强的不变量</li><li>更弱的前置条件</li><li>更强的后置条件</li></ul><h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144822.jpg" alt="LSP"></p><p>Covariance 协变：父类型-&gt;子类型：越来越具体specific或者不变（返回值类型、异常的类型）。<code>@override</code> </p><p>Contravariance 反协变、逆变：父类型-&gt;子类型：越来越抽象或者不变（参数类型）。目前Java中遇到这种情况，当作<strong>overload</strong>看待。</p><p>Arrays are covariant 协变的：an array of type T[] may contain elements of type T or any subtype of T</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记三：软件构造过程与配置管理</title>
      <link href="/2021/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2021/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><font color="red"><strong>重点掌握：软件开发过程与版本控制工具</strong></font></p><h1 id="Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）"><a href="#Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）" class="headerlink" title="Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）"></a>Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）</h1><p>从无到有，从有到好。</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144052.jpg" alt="SDLC"></p><hr><h1 id="Traditional-Software-Process-Models"><a href="#Traditional-Software-Process-Models" class="headerlink" title="Traditional Software Process Models"></a>Traditional Software Process Models</h1><blockquote><p><strong>要求</strong></p><p>区别不同开发过程模型的异同</p><p>根据不同<em>场景</em>给出相应<em>模型</em></p></blockquote><ul><li><strong>线性过程 Linear</strong>：顺序，要求一点要明确，难以更改</li><li><strong>迭代过程 Iterative</strong>：每个阶段给用户反馈，用户需求不明确</li></ul><p><strong>选择合适模型依据</strong>：用户参与程度，适应变化能力，开发效率，管理复杂段，开发出的软件质量</p><h2 id="瀑布过程-Waterfall-Linear-non-interative"><a href="#瀑布过程-Waterfall-Linear-non-interative" class="headerlink" title="瀑布过程 Waterfall (Linear, non-interative)"></a>瀑布过程 Waterfall (Linear, non-interative)</h2><p>线性推进、阶段划分清楚、整体推进、无迭代、管理简单</p><p>$$<br>\begin{aligned} conception \Rightarrow initiation \Rightarrow analysis \Rightarrow design \Rightarrow construction \Rightarrow testing \Rightarrow implementation \Rightarrow verification \Rightarrow maintenance \end{aligned}<br>$$</p><p><strong>无法适应需求增加/变化(prohibitively costly)</strong></p><p>用户只在最后一个阶段看到？？</p><h2 id="增量过程-Incremental-non-iterative"><a href="#增量过程-Incremental-non-iterative" class="headerlink" title="增量过程 Incremental (non-iterative)"></a>增量过程 Incremental (non-iterative)</h2><p>线性推进、<strong>增量式（多个瀑布的串行</strong>、无迭代、比较容易适应需求的增加</p><p>系统切成小模块，每个模块/增量Waterfall，每个模块都要能运行，模块之间不影响，模块接口要简单，要求比较稳定。</p><h2 id="V字模型-V-Model-for-verification-and-validation"><a href="#V字模型-V-Model-for-verification-and-validation" class="headerlink" title="V字模型 V-Model (for verification and validation)"></a>V字模型 V-Model (for verification and validation)</h2><p><strong>瀑布模型的扩展开发，强调每个阶段测试</strong></p><p>瀑布阶段在code阶段之后向上弯曲，对 Life Cycle 的每个阶段及相关阶段进行测试。</p><h2 id="原型过程-Prototyping-iterative"><a href="#原型过程-Prototyping-iterative" class="headerlink" title="原型过程 Prototyping (iterative)"></a>原型过程 Prototyping (iterative)</h2><p><strong>迭代</strong>：开发出来之后由<strong>用户试用/评审</strong>，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。在这个过程中，<strong>用户需求不明确</strong>，循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。</p><h2 id="螺旋模型-Spiral-iterative"><a href="#螺旋模型-Spiral-iterative" class="headerlink" title="螺旋模型 Spiral (iterative)"></a>螺旋模型 Spiral (iterative)</h2><ul><li><strong>适用于非常复杂的过程</strong></li><li><strong>多轮迭代基本遵循瀑布模式</strong> </li><li>每轮迭代有明确的目标，遵循“原型”过程，进行<strong>严格的风险分析</strong>，方可进入下一轮迭代</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144113.jpg" alt="Spiral"></p><hr><h1 id="Agile-Development-敏捷开发"><a href="#Agile-Development-敏捷开发" class="headerlink" title="Agile Development 敏捷开发"></a>Agile Development 敏捷开发</h1><blockquote><p>敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。短周期迭代。</p></blockquote><p>将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。</p><p><strong>敏捷宣言 Agile Manifesto</strong></p><ul><li>个人和交互高于过程和工具</li><li>工作软件高于全面的文档（不需要文档）</li><li>客户合作高于合同谈判（客户参与）</li><li>应对变化高于遵循计划（快速适应变化）</li></ul><p>比原型模型更适应于满足客户需求，风险较低</p><p>$$<br>Agile = 增量 + 迭代 （每次迭代处理一个小规模增量）<br>$$</p><p><strong>极限编程 (XP, eXtreme Programming)</strong></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144130.jpg" alt="XP"></p><p>协作编程（两人编程）、测试驱动、测试与编程绑定</p><p>极限编程关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。</p><hr><h1 id="Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统"><a href="#Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统" class="headerlink" title="Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统"></a>Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统</h1><p>SCM 软件配置管理：追踪和控制软件的变化。</p><p>SCI (Software Configuration Item) 软件配置项: 软件中发生变化的基本单元（如文件）。</p><p>基线：软件持续变化过程中的“<strong>稳定</strong>时刻”（例如：对外发布的版本）。</p><p>CMDB：配置管理数据库（存储软件的各配置项随时间发生变化的信息+基线），分为<strong>本地和远程</strong></p><p><em>版本</em>：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”</p><h2 id="Why-version-control-is-required"><a href="#Why-version-control-is-required" class="headerlink" title="Why version control is required"></a>Why version control is required</h2><ul><li>for individuals<ol><li>Reverting to a past version 回滚到上一个版本</li><li>Comparing two different versions 比较两个版本的差异</li><li>Pushing full version history to another location 备份软件版本历史</li><li>Pulling history back from that location 获取备份</li><li>Merging versions that are offshoots of the same earlier version 合并</li></ol></li><li>for teamwork<ol><li>Communications and share/merge works among multiple developers 在多个开发者之间<strong>共享和协作</strong></li><li>Logging individualized works of different developers for auditing 记录每个开发者的动作，便于“审计”</li></ol></li></ul><h2 id="Version-control-terminology-版本控制术语"><a href="#Version-control-terminology-版本控制术语" class="headerlink" title="Version control terminology 版本控制术语"></a>Version control terminology 版本控制术语</h2><ul><li><strong>Repository</strong>: a local or remote store of the <strong>versions</strong> in a project 仓库：即于SCM（软件配置管理）中的CMDB（配置管理数据库）</li><li><strong>Working copy</strong>: a local, editable copy of a project that we can work on 工作拷贝：在<strong>开发者本地</strong>机器上的一份项目拷贝</li><li>File: a single file in the project 文件：一个独立的配置项</li><li>Version or revision: a record of the contents of the project at a point in time 版本：在某个特定时间点的所有文件的共同状态</li><li>Change or diff: the difference between two versions 变化：即code churn，两个版本之间的差异</li><li>Head: the current version <strong>HEAD</strong>：程序员正在其上工作的版本</li></ul><h2 id="Version-Control-System-VCS"><a href="#Version-Control-System-VCS" class="headerlink" title="Version Control System (VCS)"></a>Version Control System (VCS)</h2><p><strong>三类版本控制系统</strong></p><ul><li>Local VCS 本地版本控制系统</li><li><ul><li>仓库存储于开发者<strong>本地</strong>机器无法共享和协作。</li></ul></li><li>Centralized VCS（集中式版本控制系统）</li><li><ul><li>仓库存储于<strong>独立的服务器</strong>，支持多开发者之间的协作</li></ul></li><li>Distributed VCS（分布式版本控制系统）</li><li><ul><li>仓库存储于<strong>独立的服务器+每个开发者的本地</strong>机器</li></ul></li></ul><hr><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote><p>版本图 <strong>&lt;–&gt;</strong> git命令</p><p>git文件状态 <strong>–&gt;</strong> 目录</p></blockquote><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144148.jpg" alt="gitManagement"></p><h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><blockquote><p><strong>创建</strong>本地仓库：git init</p><p>文件<strong>添加</strong>到本地仓库：git add <file></file></p><p>文件<strong>提交</strong>到本地仓库：git commit -m “commit message”</p><p>查看工作区状态：git status</p><p>比较差异修改：git diff</p><p>回到上一个版本：git reset –hard HEAD^</p><p>穿越到指定提交：git reset –hard <commit></commit></p><p>清空暂存区：git rm –cached</p><p>丢弃工作区更改: git checkout – <file></file></p><p>丢弃暂存区更改: git reset HEAD <file></file></p><p>丢弃本地版本库更改: git reset –hard HEAD^</p><p>添加远程仓库<strong>关联</strong>：git remote add origin <url></url></p><p>创建分支：git branch <branch name=""></branch></p><p>切换到分支：git checkout <branch name=""></branch></p><p>创建并切换分支：git checkout -b <branch name=""></branch></p><p>合并指定分支到当前分支：git merge <branch name="">: 如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的<strong>指针移到做过更改分支的指针的位置</strong>。如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的<strong>更改都放在一起</strong>，在工作分支上形成一个<strong>新的节点</strong>。</branch></p><p>删除分支：git branch -d <branch name="">: 只是删除分支指针，没有删除在该分支上的commit</branch></p></blockquote><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144223.jpg" alt="gitBranch1"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144207.jpg" alt="gitBranch2"></p><blockquote><p>clone: git clone -b <btanch name=""> <url></url></btanch></p><p>git push -u origin master</p><p>git push <remote name=""> <branch name="">：远程端若更改后要先与本地端合并后才能push</branch></remote></p><p>git pull <remote name=""> <branch name="">: 从远程获取最新版本并merge到本地</branch></remote></p><p>git fetch <remote name=""> <branch name="">: 从远程获取最新版本到本地，不会自动merge</branch></remote></p></blockquote><h2 id="Git-repository"><a href="#Git-repository" class="headerlink" title="Git repository"></a>Git repository</h2><ul><li><strong>.git</strong> directory: <strong>本地</strong>的 CMDB（配置管理数据库）</li><li>Working directory 工作目录：本地文件系统</li><li>Staging area 暂存区：隔离工作目录和Git仓库</li></ul><ul><li>已修改 Modified: different between file in <strong>working directory</strong> and file in <strong>git directory</strong></li><li>已暂存 Staged: file added into staging area</li><li>已提交 Committed: file keep <strong>same in working directory and git directory</strong></li></ul><h2 id="Git-Object-Graph"><a href="#Git-Object-Graph" class="headerlink" title="Git Object Graph"></a>Git Object Graph</h2><p><strong>Object Graph: 版本演化关系图，是一个有向无环图。</strong></p><p><strong>A-&gt;B</strong>: 在版本B的基础上作出变化，形成了版本A</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144238.jpg" alt="ObjectGraph"></p><p>一个父对象可以有多个子对象（<strong>创建了分支</strong>）；除了initial commit没有父对象，一个子对象的父对象最多两个（<strong>合并分支</strong>）。</p><p>branch: a name that points to a commit</p><p>HEAD: pointing to the current commit</p><p>Git Object Graph 储单个文件的每个版本一次，并允许多次提交来共享该副本。若文件没有变化，则后续多个版本始终指向同一个文件；若文件发生变化了，存储两份不同的文件，两个版本指向不同的文件。</p><p>每个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。</p><ul><li>传统VCS：存储版本之间的变化（行）。优点：存储空间较小。缺点：由于存储的是变化情况，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。</li><li>Git：存储发生变化的文件（而非代码行），不变化的文件不重复存储，这样易于取出特定版本文件、易于创建分支（创建分支时，需要进行叠加来获得当前版本）。缺点：空间复杂度增加。</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144247.jpg" alt="VCS"></p><hr><h1 id="General-process-of-software-construction"><a href="#General-process-of-software-construction" class="headerlink" title="General process of software construction"></a><em>General</em> process of software construction</h1><p>$$<br>\begin{aligned} General process of software construction 广义软件构造过程: Design \Rightarrow Programming/refactoring \Rightarrow Debugging \Rightarrow Testing \Rightarrow Build \Rightarrow Release \end{aligned}<br>$$</p><p>$$<br>\begin{aligned} Narrow-sense process of software construction (Build) 狭义软件构造过程build: Validate \Rightarrow Compile \Rightarrow Link \Rightarrow Test \Rightarrow Package \Rightarrow Install \Rightarrow Deploy \end{aligned}<br>$$</p><h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ul><li><strong>Construction Languages</strong></li><li><strong>purpose 用途上划分</strong><ol><li>Programming languages (e.g., C, C++, Java, Python) 编程语言</li><li>Modeling languages (e.g., UML) 建模语言</li><li>Configuration languages (e.g., XML) 配置语言</li><li>Build languages (e.g., XML) 构建语言</li></ol></li><li><strong>form 形态上划分</strong><ol><li>Linguistic-based 基于语言学的构造语言</li><li>Mathematics-based (formal) 基于数学的形式化构造语言</li><li>Graphics-based (visual) 基于图形的可视化构造语言</li></ol></li></ul><h3 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h3><p><strong>IDE 集成开发环境</strong>包括</p><ul><li><strong>Source code editor</strong> with intelligent code completion, code refactoring tool 源代码编辑器：智能代码补全工具、代码重构工具</li><li>File management tool 文件管理</li><li>Library management tool 库管理</li><li>Class browser, object browser, class hierarchy diagram 软件逻辑实体可视化</li><li>Graphical User Interface (<strong>GUI</strong>) builder 图形化用户界面构造器</li><li>Compiler, interpreter 编译器、解释器</li><li>Build automation tools 自动化build工具</li><li>Version control system 版本控制系统</li><li>Extensible by more external third-party tools 外部的第三方工具</li></ul><h3 id="Modeling-Languages"><a href="#Modeling-Languages" class="headerlink" title="Modeling Languages"></a>Modeling Languages</h3><p>目的：可视化、推理、验证和交流系统的设计。</p><p>e.g. UML (Unified Modeling Language)</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144300.jpg" alt="UMLClassDiagram"></p><h3 id="Configuration-Languages"><a href="#Configuration-Languages" class="headerlink" title="Configuration Languages"></a>Configuration Languages</h3><p>e.g. XML, YAML, JSON</p><h2 id="Review-and-static-code-analysis"><a href="#Review-and-static-code-analysis" class="headerlink" title="Review and static code analysis"></a>Review and <em>static</em> code analysis</h2><h2 id="Dynamic-code-analysis-profiling-性能测试"><a href="#Dynamic-code-analysis-profiling-性能测试" class="headerlink" title="Dynamic code analysis/ profiling 性能测试"></a>Dynamic code analysis/ profiling 性能测试</h2><h2 id="Debugging-and-Testing"><a href="#Debugging-and-Testing" class="headerlink" title="Debugging and Testing"></a>Debugging and Testing</h2><h2 id="Refactoring-重构：不改变功能的前提下优化代码"><a href="#Refactoring-重构：不改变功能的前提下优化代码" class="headerlink" title="Refactoring 重构：不改变功能的前提下优化代码"></a>Refactoring 重构：不改变功能的前提下优化代码</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记二：软件测试与测试优先编程</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p><font color="red"> <strong>IMPORTANCE 本章重点</strong> </font></p><p><font color="red"> <strong>什么是测试</strong> </font></p><p><font color="red"> <strong>白盒测试与黑盒测试</strong> </font></p><p><font color="red"> <strong>按阶段、分步骤测试</strong> </font></p></blockquote><h1 id="1-Software-Testing"><a href="#1-Software-Testing" class="headerlink" title="1. Software Testing"></a>1. Software Testing</h1><h2 id="What-is-Testing"><a href="#What-is-Testing" class="headerlink" title="What is Testing"></a>What is Testing</h2><p>软件测试：为涉众提供有关被测试产品或服务的<strong>质量信息</strong>而进行的调查，是<strong>提高软件质量的重要手段</strong>，但是软件质量取决于设计而不是testing。</p><ul><li>寻找bug，确认是否达到可用级别(用户需求)</li><li>关注系统的某一侧面的<strong>质量特性</strong></li></ul><p>测试无法达到100%的无错误，never completely prove the absence of errors。</p><p>residual defect rates 残留缺陷率（bugs left over after the software has shipped）。对于大的系统来说，即使残留缺陷率很低，残留的bug也可能很多。</p><ul><li>1-10 defects/kloc(1000 Lines of Code)：Typical industry software</li><li>– 0.1-1 defects/kloc: High-quality validation.(Java Libraries)</li><li>0.01-0.1 defects/kloc: The very best, safety-critical validation.(NASA, Praxis)</li></ul><p>测试的目标与其他开发流程目标相反：to find errors（破坏、证错、“负能量”）</p><p>good testing： 能发现错误、不冗余、最佳特性、别太复杂也别太简单</p><h2 id="Testing-Level"><a href="#Testing-Level" class="headerlink" title="Testing Level"></a>Testing Level</h2><ul><li>Unit testing 单元测试：代码部分功能测试</li><li>Integration testing 集成测试：类、包、组件、子系统的组合执行</li><li>System testing 系统测试：完全集成的系统</li><li>Regression testing 回归测试：发现错误，改正后，前面的重新测试（自动化）</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143914.jpg" alt="TestLevel"></p><h2 id="Static-vs-Dynamic-Testing"><a href="#Static-vs-Dynamic-Testing" class="headerlink" title="Static vs. Dynamic Testing"></a>Static vs. Dynamic Testing</h2><ol><li><strong>静态测试 Static testing</strong>：without actually executing programs, 靠眼睛看，隐式的静态程序分析，review、walkthroughs、inspections</li><li><strong>动态测试 Dynamic testing</strong>：给定测试用例执行</li></ol><h2 id="Testing-vs-Debugging"><a href="#Testing-vs-Debugging" class="headerlink" title="Testing vs. Debugging"></a>Testing vs. Debugging</h2><ol><li><strong>测试</strong>：发现是否存在错误 (errors)</li><li><strong>调试</strong>：识别错误根源，消除错误 (causes of errors)</li></ol><h2 id="White-box-vs-black-box-testing"><a href="#White-box-vs-black-box-testing" class="headerlink" title=" White-box vs. black-box testing "></a><font color="red"> White-box vs. black-box testing </font></h2><ol><li><strong>白盒测试</strong>：对程序<strong>内部代码</strong>结构的测试，程序执行情况，by seeing the source code</li><li><strong>黑盒测试</strong>：对程序<strong>外部表现</strong>出来的行为的测试。just input and output，程序完成之前可以确定，用于<strong>检查代码的功能，不关心内部实现细节</strong></li></ol><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143931.jpg" alt="WhiteVSBlack-box-testing"></p><hr><h1 id="2-Test-Case"><a href="#2-Test-Case" class="headerlink" title="2. Test Case"></a>2. Test Case</h1><p><strong>测试用例：输入＋执行条件+期望结果</strong></p><p><em>E.g.</em> test cases: {2,4}, {0,0}, {-2,4} for program y=x^2</p><h1 id="3-Test-First-Programming"><a href="#3-Test-First-Programming" class="headerlink" title="3. Test-First Programming"></a>3. Test-First Programming</h1><p><strong>TDD Test-driven development</strong>：先写<strong>spec</strong> -&gt; 再写符合spec的<strong>测试用例</strong> -&gt; 写<strong>代码</strong>、<strong>执行测试</strong>、有问题再改、再执行测试用例，直到通过它</p><p>Testing First Saves a lot of time.避免将缺陷插入代码然后，减少检测到缺陷代码并删除缺陷的时间量</p><h1 id="4-Unit-Testing（单元测试）"><a href="#4-Unit-Testing（单元测试）" class="headerlink" title="4. Unit Testing（单元测试）"></a>4. Unit Testing（单元测试）</h1><p>针对软件的<strong>最小</strong>单元模型开展测试，隔离各个**模块(the software component or module)**，容易定位错误和调试。</p><h1 id="5-Automated-Unit-Testing-with-JUnit"><a href="#5-Automated-Unit-Testing-with-JUnit" class="headerlink" title="5. Automated Unit Testing with JUnit"></a>5. Automated Unit Testing with JUnit</h1><p><strong>annotation</strong>: @Test </p><p><strong>assertion methods</strong> like assertEquals, assertTrue, and assertFalse.</p><hr><h1 id="6-black-box-Testing"><a href="#6-black-box-Testing" class="headerlink" title="6.  black-box Testing "></a>6. <font color="red"> black-box Testing </font></h1><p><strong>only from the specification, not the implementation of the function</strong></p><p>黑盒测试用例根据<strong>规约</strong>、要求、设计参数来形成的。</p><p>用尽可能少的测试用例，尽快运行，并尽可能大的发现程序的错误。</p><h2 id="6-1-Choosing-Test-Cases-by-Partitioning-划分"><a href="#6-1-Choosing-Test-Cases-by-Partitioning-划分" class="headerlink" title="6.1 Choosing Test Cases by Partitioning 划分"></a>6.1 Choosing Test Cases by Partitioning 划分</h2><p><font color="red"> <strong>Equivalence Partitioning 等价类划分</strong> </font></p><ul><li>被测函数的<strong>输入域划分为等价类</strong>，从等价类中导出测试用例（衍生）</li><li>如果一组对象可以通过<strong>对称、传递和自反</strong>的关系链接，则存在等价类。</li><li>每个等价类代表着对输入约束加以满足/违反的有效/无效数据的集合</li></ul><p><strong>基于假设</strong>：相似的输入，将会展示相似的行为，可从每个等价类中选一个代表作为测试用例即可，可以降低测试用例数量。</p><p>等价类划分所选用例要<strong>覆盖全部类</strong>，还要考虑一些<strong>特殊情况（边界值等）</strong>：</p><ul><li>限定了数值范围：one valid and two invalid</li><li>指明了特定的值：one valid and one invalid</li><li>确定了一组数值：one valid and one invalid</li><li>输入数据是Boolean：one valid and one invalid</li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143948.jpg" alt="EquivalencPartitioningExample"></p><h2 id="Include-Boundaries-in-the-Partition"><a href="#Include-Boundaries-in-the-Partition" class="headerlink" title="Include Boundaries in the Partition"></a>Include Boundaries in the Partition</h2><p>Boundary Value Analysis (BVA) 边界测试</p><p>大量的错误发生在输入域的“边界”而非中央</p><p>边界值分析方法是对等价类划分方法的补充</p><p><strong>在等价类划分时，将边界作为等价类之一加入考虑</strong></p><h2 id="笛卡尔积：全覆盖-覆盖每个取值：最少1次即可"><a href="#笛卡尔积：全覆盖-覆盖每个取值：最少1次即可" class="headerlink" title="笛卡尔积：全覆盖/覆盖每个取值：最少1次即可"></a>笛卡尔积：全覆盖/覆盖每个取值：最少1次即可</h2><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144003.jpg" alt="BVAExample"></p><p>以此为例：</p><ol><li><strong>笛卡尔积全覆盖</strong>：3 × 5 × 5 = 75 test cases, but some combinations are impossible, such as <strong>a&lt;b, a=0, b=0</strong>（多维度多取值，组合每个维度都要有取值，但是并非所有组合情况都可能）</li><li><strong>Cover each part 覆盖每个取值最少1次即可</strong>：每个维度的每个取值至少被1个测试用例覆盖一次即可，如下。</li></ol><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144010.jpg" alt="BVAExampleAnswer"></p><p>笛卡尔积全覆盖测试完备，但用例数量多，测试代价高；后者方法测试用例少，代价低，但测试覆盖度未必高。Often we strike some compromise between these two extremes，两个极端之间做出一些<strong>妥协</strong>（出于谨慎、受白盒测试和代码覆盖工具的影响）。</p><h1 id="7-White-box-Testing"><a href="#7-White-box-Testing" class="headerlink" title="7 White-box Testing"></a>7 White-box Testing</h1><p><strong>白盒测试要考虑内部实现细节</strong>，开发人员去实现，<strong>尽量走全代码</strong>。</p><p>根据<strong>程序执行路径</strong>设计测试用例，只测试实现功能（不能测试缺失功能），不是根据需求选择的测试用例。</p><p>白盒测试可以在 unit, integration and system levels 执行，一般较早执行。</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144020.jpg" alt="BlackBoxTest"></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718144027.jpeg"></p><p>独立/基本路径测试：对程序所有执行路径进行等价类划分，找出有代表性的最简单的路径（例如循环只需执行1次），设计测试用例使每一条<strong>基本路径被至少覆盖1次</strong>。</p><h1 id="8-Coverage-of-Testing"><a href="#8-Coverage-of-Testing" class="headerlink" title="8 Coverage of Testing"></a>8 Coverage of Testing</h1><p>Code coverage 代码覆盖度：已有的测试用例有多大程度覆盖了被测程序（百分比衡量覆盖度）</p><p>代码覆盖度越低，测试越不充分；但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高。</p><p><strong>测试效果（难度）：路径覆盖&gt;分支覆盖&gt;语句覆盖（条件覆盖和分支覆盖没有可比性）</strong></p><p>最彻底的白盒测试是覆盖程序中的每一条路径（<strong>路径覆盖</strong>），但由于一般存在循环，路径数量巨大，难以全覆盖。</p><p> a code coverage tool EclEmma</p><p>实际中，根据预先设定的覆盖度标准，<strong>逐步增加测试用例</strong>的数量，直到覆盖度达到标准</p><h1 id="9-Automated-Testing-and-Regression-Testing"><a href="#9-Automated-Testing-and-Regression-Testing" class="headerlink" title="9 Automated Testing and Regression Testing"></a>9 Automated Testing and Regression Testing</h1><p><strong>Automated testing</strong>： 自动调用被测函数、自动判定测试结果、自动计算覆盖度。只是“测试用例的自动执行”，并非“自动生成测试用例”。A good testing framework, like <strong>JUnit</strong>, helps you build automated test suites, make  it easy to run the tests, not create test cases.</p><p><strong>Regression testing 回归测试</strong>：一旦程序被<strong>修改</strong>，重新执行之前的<strong>所有</strong>测试。</p><p>a test is good if it elicits a bug.</p><p>Automated regression testing 自动化回归测试（above 2 testing methods combined）：一旦发现bug，要马上写一个可重现该bug的测试用例，并将其加入测试库</p><h1 id="10-Documenting-Your-Testing-Strategy"><a href="#10-Documenting-Your-Testing-Strategy" class="headerlink" title="10 Documenting Your Testing Strategy"></a>10 Documenting Your Testing Strategy</h1><p>测试策略（根据什么来选择测试用例）非常重要，需要在程序中显式记录下来。</p><p>目的：在代码评审过程中，其他人可以理解你的测试，并评判你的测试是否足够充分</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造笔记一：软件构造的多维视图和质量目标</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="多维视图和质量目标"><a href="#多维视图和质量目标" class="headerlink" title="多维视图和质量目标"></a>多维视图和质量目标</h1><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143514.jpg" alt="MultiDimensionalSoftwareViews"></p><hr><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143536.jpg" alt="ThreeDimension"></p><h2 id="Build-time-Views"><a href="#Build-time-Views" class="headerlink" title="Build-time Views"></a>Build-time Views</h2><p><strong>Build-time（构造阶段）</strong>：idea <strong>-&gt;</strong> requirement <strong>-&gt;</strong> design <strong>-&gt;</strong> code <strong>-&gt;</strong> installable / executable package</p><blockquote><p><strong>Code-level view（代码的逻辑组织）</strong>：source code – how source code are <em>logically</em> organized by basic program blocks such as functions（函数）, classes（类）, methods（方法）, interfaces（接口）.</p><p><strong>Component-level view（代码的物理组织）</strong>：architecture – how source code are <em>physically</em> organized by files（文件）, directories（目录）, packages（包）, libraries（库）.</p><p><strong>Moment view</strong>：what do source code and component look like <em>in a specific time</em></p><p><strong>Period view</strong>： how do they evolve/change <em>along with time</em></p></blockquote><h3 id="Build-time-moment-and-code-level-view"><a href="#Build-time-moment-and-code-level-view" class="headerlink" title="Build-time, moment, and code-level view"></a>Build-time, moment, and code-level view</h3><ul><li><strong>词汇层面</strong>：Lexical-oriented source code</li><li><strong>语法层面</strong>：Syntax-oriented program structure: e.g. Abstract Syntax Tree (AST)</li><li><strong>语义层面</strong>：Semantics-oriented program structure: e.g. Class Diagram</li></ul><p><strong>AST：</strong>彻底结构化，将源代码变为一棵树，对树做各种操作==对源代码的修改.</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143552.png" alt="AST"></p><p>**Class Diagram (UML)**：describe interfaces, classes, attributes, methods, and relationships among them.</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143602.jpg" alt="UML"></p><h3 id="Build-time-period-and-code-level-view"><a href="#Build-time-period-and-code-level-view" class="headerlink" title="Build-time, period, and code-level view"></a>Build-time, period, and code-level view</h3><ul><li><strong>Code churm（代码变化）</strong></li></ul><h3 id="Build-time-moment-and-component-level-view"><a href="#Build-time-moment-and-component-level-view" class="headerlink" title="Build-time, moment, and component-level view"></a>Build-time, moment, and component-level view</h3><ul><li><strong>file, package, library</strong></li><li><strong>Static linking</strong></li><li><strong>Test Case</strong></li><li>build sript(component diagram) 构建脚本（组件图）</li></ul><p>Source code (physically organize)<strong>-&gt;</strong> files (organized by directories/ encapsulated) <strong>-&gt;</strong> packages <strong>-&gt;</strong> logically components and sub-systems（组件和子系统）.</p><p>Reusable modules（可重用模块） are in the form of libraries（库）.<strong>Libraries</strong> are stored in disk files（磁盘文件）.<strong>Sources of libraries</strong>: OS pre-installed set/ language SDK/ third-party sources/ developers’ own published libraries.</p><p>When a program is edited, built and installed, a list of libraries to search must be provided.（编程、build和安装时，需要提供库路径）。Two approaches integrating a library into program: Static or Dynamic linking.</p><p><strong>Static linking</strong>：静态链接发生在构造阶段(build time), 库被拷贝进入代码形成整体，执行的时候无需提供库文件.</p><p><strong>Dynamic linking</strong>：build time 仅仅做出标记，<strong>Runtime</strong>根据标记转载至内存与主程序关联。</p><h3 id="Build-time-period-and-component-level-view"><a href="#Build-time-period-and-component-level-view" class="headerlink" title="Build-time, period, and component-level view"></a>Build-time, period, and component-level view</h3><p>How files/packeages/components/libraries change.</p><ul><li>Software Configuration Item (<strong>SCI</strong>，配置项)</li><li><strong>Version</strong> (版本)</li></ul><hr><h2 id="Runtime-views"><a href="#Runtime-views" class="headerlink" title="Runtime views"></a>Runtime views</h2><p><strong>Runtime（运行阶段）</strong>: 程序被载入目标机器以及目标机器所需磁盘文件</p><blockquote><p><strong>Code-level view</strong>: 代码层面 – 逻辑实体（程序）在<strong>内存</strong>中如何呈现，程序单元（函数、对象等）交互情况</p><p><strong>Component-level view</strong>: 构件层面 – 物理实体在<strong>物理硬件环境</strong>中如何呈现和交互？</p><p><strong>Moment view</strong>: 逻辑/物理实体在内存/硬件环境中<strong>特定时刻</strong>的形态如何？</p><p><strong>Period view</strong>: 逻辑/物理实体在内存/硬件环境中的形态随时间如何<strong>变化</strong>？</p></blockquote><h3 id="High-level-concepts-of-run-time-software"><a href="#High-level-concepts-of-run-time-software" class="headerlink" title="High-level concepts of run-time software"></a>High-level concepts of run-time software</h3><ul><li>**Executable programs (可执行程序)**：CPU执行的机器可读指令</li><li><strong>Libraries</strong></li><li><strong>Configuration and data files (配置和数据文件)</strong> that the program can load from disk</li><li>**Distributed programs (分布式程序)**：多进程</li><li><strong>Native Machine Code (原生机器码)</strong></li><li><strong>Full Program Interpretation (程序完全解释执行)</strong></li><li><strong>Interpreted Byte Codes (解释型字节码)</strong></li></ul><h3 id="Run-time-moment-and-code-level-view"><a href="#Run-time-moment-and-code-level-view" class="headerlink" title="Run-time, moment, and code-level view"></a>Run-time, moment, and code-level view</h3><ul><li><strong>Code Snapshot</strong></li><li><strong>Memory dump (内存信息转储)</strong></li></ul><p><font color="red"><strong>Snapshot Diagram</strong>：程序运行时内存里变量层面的状态。</font></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143632.jpg" alt="SnapshotDiagram1"></p><h3 id="Run-time-period-and-code-level-view"><a href="#Run-time-period-and-code-level-view" class="headerlink" title="Run-time, period and code-level view"></a>Run-time, period and code-level view</h3><ul><li>**Execution tracing (执行跟踪)**：用日志方式记录程序执行的调用次序。</li><li><strong>Concurrent multi-threads (并发多线程)</strong></li></ul><h3 id="Run-time-moment-and-component-level-view"><a href="#Run-time-moment-and-component-level-view" class="headerlink" title="Run-time, moment, and component-level view"></a>Run-time, moment, and component-level view</h3><h3 id="Run-time-period-and-component-level-view"><a href="#Run-time-period-and-component-level-view" class="headerlink" title="Run-time, period, and component-level view"></a>Run-time, period, and component-level view</h3><ul><li><strong>Event log (事件日志)</strong></li><li><strong>Multi-processes (多进程)</strong></li><li><strong>Distributed processes (分布式进程)</strong></li></ul><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143651.jpg" alt="EventLogAndExecutionTracing"></p><hr><h1 id="Transformation-between-views"><a href="#Transformation-between-views" class="headerlink" title="Transformation between views"></a>Transformation between views</h1><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143712.jpg" alt="TransformationBetweenViews"></p><p>$$ \begin{aligned} \emptyset \Rightarrow Code\end{aligned} $$ 类、属性、方法</p><p>  Programming / Coding (ADT抽象数据类型 /OOP面向对象的程序设计)</p><p>  Review, static analysis/checking</p><p>$$ \begin{aligned} Code \Rightarrow Component \end{aligned} $$ 模块化</p><p>  Design (ADT/OOP; Reusability; Maintainability)</p><p>  Build: compile, static link, package, install, etc</p><p>$$ \begin{aligned} Build-time \Rightarrow Run-time \end{aligned} $$ 创建于运行</p><p>  Install / deploy</p><p>  Debug, unit/integration testing (Robustness and Correctness) 测试</p><p>$$ \begin{aligned} Moment \Rightarrow Perioid \end{aligned} $$ 瞬时与周期</p><p>  Version control</p><p>  Loading, dynamic linking, execution (dumping, profiling, logging)</p><p>  Concurrent threads</p><hr><h1 id="Quality-properties-of-software-systems-软件系统的质量"><a href="#Quality-properties-of-software-systems-软件系统的质量" class="headerlink" title="Quality properties of software systems (软件系统的质量)"></a>Quality properties of software systems (软件系统的质量)</h1><blockquote><p>External quality factors affect users. <strong>外部质量影响用户</strong></p><p>Internal quality factors affect the software itself and its developers. <strong>内部质量因素 影响 软件本身和它的开发者</strong></p><p>External quality results from internal quality. <strong>外部质量取决于内部质量，最终外部质量才最重要</strong></p></blockquote><h2 id="外部质量因素"><a href="#外部质量因素" class="headerlink" title="外部质量因素"></a>外部质量因素</h2><p><strong>外部质量因素：速度或易用性等质量，被用户检查</strong></p><ol><li><p><strong>Correctness (正确性)</strong>: 输入输出正确，按定义的规约 (specification)执行，这是软件开发<strong>最重要</strong>的因素。</p><ul><li>测试和调试 (Testing and debugging)：发现不正确、消除不正确</li><li>防御式编程 (Defensive programming)：在写程序的时候就确保正确性 (e.g. typing and assertions)</li><li>形式化方法 (Formal approach)：通过形式化验证发现问题</li></ul></li><li><p><strong>Robustness (健壮性)</strong>: 健壮性是针对异常情况的处理，<strong>出现异常(abnormal conditions)时不要“崩溃”</strong></p><ul><li>未被specification覆盖的情况即为”异常情况”</li><li>“narmal”和”abnormal”是主观而非客观的</li><li>产生错误信息，干净终止执行，进入“优雅”模式</li><li>出现规约定义之外的情形的时候，软件要做出恰当的反应</li></ul><p> <img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143734.jpg" alt="RobustnessVSCorrectness"></p></li><li><p><strong>Extendibility (可扩展性)</strong>: 适应规约变化的容易程度。<br>要便于软件功能的增加/扩展（ADT、OOP、留下一个Visitor），降低未来修改软件时的成本。</p><ul><li><strong>Design simplicity (简约主义设计)</strong></li><li>**Decentralization (分离主义设计)**：模块化</li><li>$$ \Rightarrow ADT and OOP/ Modularity and adaptability $$</li></ul></li><li><p><strong>Reusability (可复用性)</strong>: 一次开发，多次使用，寻找共性，未来直接使用现在的这段代码。</p></li><li><p><strong>Compatibility (兼容性)</strong>: 不同的软件系统之间相互可容易的集成。</p><ul><li>保持设计的同构性</li><li>兼容性的关键是<strong>标准化</strong>，特别是标准协议。</li></ul></li><li><p><strong>Efficiency (性能)</strong>: 。</p><ul><li>性能毫无意义，除非有足够的正确性</li><li>对性能的关注要与其他质量属性进行折中</li><li>过度的优化导致软件不再适应变化和复用</li><li>不要过早的优化，性能在没有正确性保障的条件下是没有意义的</li><li>性能和其他质量目标冲突，折中处理</li></ul></li><li><p><strong>Portability (可移植性)</strong>: 软件可方便地在不同的技术环境之间移植。</p><ul><li>硬件、操作系统</li></ul></li><li><p><strong>Ease of use (易用性)</strong>: 容易学、安装、操作、监控，给用户提供详细的指南。</p><ul><li><strong>Structural simplicity (结构简单)</strong>: 易于学习使用</li><li><strong>Know the user</strong>: understand the system’s intended user community</li></ul></li><li><p><strong>Functionality (功能性)</strong>: 功能过多程序复杂、不灵活、占用过多的磁盘空间，会导致易用性的降低。</p><ul><li>每增加一小点功能，都确保其他质量属性不受到损失</li><li>主要功能要首要提升质量<br><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143749.jpg" alt="OsmondCurves"></li></ul></li><li><p> <strong>Timeliness (及时性)</strong>: 软件要能够在用户需要甚至之前，能及时地设计出来。</p></li><li><p> <strong>Other qualities</strong>: Verifiability (可验证性), Integrity (完整性), Repairability (可修复性), Economy (经济性)。</p></li></ol><hr><h2 id="内部质量因素"><a href="#内部质量因素" class="headerlink" title="内部质量因素"></a>内部质量因素</h2><p><strong>内部质量因素：软件产品品质，如模块化和可读性，开发人员才能察觉</strong></p><ul><li>代码行数 (LOC)、圈复杂度 (Cyclomatic <strong>Complexity</strong>)</li><li><ul><li>Complexity 是外部因素的 enemy</li></ul></li><li>构架相关因素：耦合 (coupling)、内聚 (cohesion)</li><li>可读性 (Readability)</li><li>可理解性 (Understandability)</li><li>整洁度 (Clearness)</li><li>大小 (Size)</li></ul><h2 id="Tradeoff-between-quality-properties-折中、妥协"><a href="#Tradeoff-between-quality-properties-折中、妥协" class="headerlink" title="Tradeoff between quality properties (折中、妥协)"></a>Tradeoff between quality properties (折中、妥协)</h2><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143812.jpg" alt="tradeoff"></p><p>以上这些质量属性之间往往不能兼得，需要权衡，某些特定要求下可以放弃优化其他项而优化另一项。</p><p>正确的软件开发过程中，开发者应该将不同质量因素之间如何做出折中的设计决策和标准明确的写下来。</p><p><em><strong>正确性是绝不能与其他质量因素折中的.</strong></em></p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143822.jpg" alt="OOPimprovesQuality">五个关键的质量指标</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143843.jpg" alt="FiveKeyQualityObjectives"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件构造：实验二总结</title>
      <link href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%EF%BC%9A%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%EF%BC%9A%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="循环判断删除list元素"><a href="#循环判断删除list元素" class="headerlink" title="循环判断删除list元素"></a>循环判断删除list元素</h1><h2 id="错误演示增强for循环"><a href="#错误演示增强for循环" class="headerlink" title="错误演示增强for循环"></a>错误演示增强for循环</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String deleteString = <span class="string">"del"</span>;</span><br><span class="line">lists.add(<span class="string">"del"</span>);</span><br><span class="line">lists.add(<span class="string">"fhd"</span>);</span><br><span class="line">lists.add(<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : lists)</span><br><span class="line">    <span class="keyword">if</span> (s.equals(deleteString))</span><br><span class="line">        lists.remove(s);</span><br></pre></td></tr></tbody></table></figure><p>删除元素后继续循环会报错误信息ConcurrentModificationException，如下图所示：</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143350.jpg" alt="增强forError"></p><p><strong>直接原因：</strong><code>modCount != expectedModCount</code></p><ul><li><code>modCount</code>表示List的<code>add</code>或者<code>remove</code>方法次数</li><li><code>expectedModCount</code>是指 Iterator现在期望这个 List被修改的次数 </li></ul><p><strong>分析</strong> ：java的增强for循环根据list对象创建一个Iterator迭代对象，创建的时候modCount被赋值给了expectedModCount，但是调用<code>remove</code>方法的时候<code>modCount++</code>，但是expectedModCount没有改变，两个Count值不相等，由此抛出异常。所以不必赘述，使用iterator遍历删除的话，也会出现相同的错误。</p><h3 id="特别地"><a href="#特别地" class="headerlink" title="特别地"></a>特别地</h3><p>根据经验判断只有删除倒数第二个元素的时候不会抛出异常，删除其他元素都会抛出异常，此处就不再去追究原因。如下代码演示（将上述代码中deleteString从”del”换成”fhd”）以及结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteString = <span class="string">"fhd"</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143414.jpg" alt="forLast2delete"></p><h2 id="正确方法"><a href="#正确方法" class="headerlink" title="正确方法"></a>正确方法</h2><h3 id="创建一个作为条件判断的List"><a href="#创建一个作为条件判断的List" class="headerlink" title="创建一个作为条件判断的List"></a>创建一个作为条件判断的List</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s : lists)</span><br><span class="line">    res.add(s);</span><br><span class="line"><span class="keyword">for</span> (String s : res) {</span><br><span class="line">    <span class="keyword">if</span> (s.equals(deleteString))</span><br><span class="line">        lists.remove(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用removeIf方法"><a href="#使用removeIf方法" class="headerlink" title="使用removeIf方法"></a>使用<code>removeIf</code>方法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists.removeIf(string-&gt;string.equals(<span class="string">"deleteString"</span>));</span><br></pre></td></tr></tbody></table></figure><p>其中 <strong>-&gt;</strong> 后面的是判断条件，符合条件的<code>string</code>就删除。 </p><hr><h1 id="关于HashMap方法的总结"><a href="#关于HashMap方法的总结" class="headerlink" title="关于HashMap方法的总结"></a>关于HashMap方法的总结</h1><h2 id="java-HashMap-插入重复key"><a href="#java-HashMap-插入重复key" class="headerlink" title="java HashMap 插入重复key"></a>java HashMap 插入重复key</h2><p>在解释插入重复key会发生什么之前，不妨先了解一下HashMap是怎么储存和运行的。</p><p><strong>储存</strong> ：首先对于一对key和value，调用key的<code>hashCode()</code>方法得到对应的bucket位置，相同hashcode的Key就储存在同一个bucket中。但HashMap并不是直接储存，而是每一个bucket都对应一个LinkedList or as Entry，如下所示。由此，相同hashcode的key放在同一LinkedList上。</p><p><img src="https://github.com/FuLucas/cloudimg/tree/main/2022/20210718143425.png" alt="HashMap"></p><p><strong><code>put()</code>方法的实现</strong> ：首先得到待插入key的hashcode，根据此找到插入位置所在的LinkedList，之后会通过<code>equals(key)</code>方法判断是否存在键值对。对于重复的key和value，会用new value覆盖value，并返回old value；若之前不存在相应key，则返回<code>null</code>，这样就实现了key的唯一性。</p><h2 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h2><ul><li><strong>浅拷贝</strong> ：HashMap的浅拷贝结果映射到与原始HashMap相同的key和value对象。</li><li><strong>深拷贝</strong> ：HashMap的深拷贝可以深入复制所有映射，为所有key、value和映射创建新对象。</li></ul><h3 id="shallow-copy-examples"><a href="#shallow-copy-examples" class="headerlink" title="shallow copy examples"></a>shallow copy examples</h3><p><strong>1.HashMap clone() method</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = originalMap.clone();</span><br></pre></td></tr></tbody></table></figure><p><strong>2.putAll() method</strong> shallow-copies all of the mappings in one step.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">shallowCopy.putAll(originalMap); </span><br></pre></td></tr></tbody></table></figure><p><strong>3.put() method</strong>  by iterating over each entry and calling the put() method on another map.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, <span class="keyword">int</span>&gt; shallowCopy = <span class="keyword">new</span> HashMap&lt;String, <span class="keyword">int</span>&gt;();</span><br><span class="line">Set&lt;Entry&lt;String, <span class="keyword">int</span>&gt;&gt; entries = originalMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, <span class="keyword">int</span>&gt; mapEntry : entries) {</span><br><span class="line">    shallowCopy.put(mapEntry.getKey(), mapEntry.getValue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="deep-copy-examples"><a href="#deep-copy-examples" class="headerlink" title="deep copy examples"></a>deep copy examples</h3><p><strong>serialization–java序列化</strong></p><p>Use Google Gson library/ Alibaba to serialize the HashMap and deserialize.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
