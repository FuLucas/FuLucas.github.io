<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>软件构造笔记三：软件构造过程与配置管理</title><meta name="description" content="Shifting eyes and vacancy coming."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="重点掌握：软件开发过程与版本控制工具
Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）从无到有，从有到好。


Traditional Software Process Models
要求
区别不同开发过程模型的异同
根据不同场景给出相应模型


线性过程 Linear：顺序，要求一点要明确，难以更改
迭代过程 Iterative：每个阶段给用户反馈，用户需求不明确

选择合适模型依据：用户参与程度，适应变化能力，开发效率，管理复杂段，开发出的软件质量
瀑布过程 Waterfall (Linear, non-interative)线性推进、阶段划分清楚、整体推进、无迭代、管理简单
$$\begin{aligned} conception \Righta.."><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">FuLucas's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">软件构造笔记三：软件构造过程与配置管理</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Software-Development-Life-Cycle-SDLC-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%9C%88%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-text">Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Traditional-Software-Process-Models"><span class="toc-text">Traditional Software Process Models</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E8%BF%87%E7%A8%8B-Waterfall-Linear-non-interative"><span class="toc-text">瀑布过程 Waterfall (Linear, non-interative)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E8%BF%87%E7%A8%8B-Incremental-non-iterative"><span class="toc-text">增量过程 Incremental (non-iterative)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V%E5%AD%97%E6%A8%A1%E5%9E%8B-V-Model-for-verification-and-validation"><span class="toc-text">V字模型 V-Model (for verification and validation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E8%BF%87%E7%A8%8B-Prototyping-iterative"><span class="toc-text">原型过程 Prototyping (iterative)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B-Spiral-iterative"><span class="toc-text">螺旋模型 Spiral (iterative)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Agile-Development-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91"><span class="toc-text">Agile Development 敏捷开发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Software-Configuration-Management-SCM-and-Version-Control-System-VCS-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-version-control-is-required"><span class="toc-text">Why version control is required</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Version-control-terminology-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%9C%AF%E8%AF%AD"><span class="toc-text">Version control terminology 版本控制术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Version-Control-System-VCS"><span class="toc-text">Version Control System (VCS)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git"><span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-%E5%91%BD%E4%BB%A4"><span class="toc-text">Git 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-repository"><span class="toc-text">Git repository</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-Object-Graph"><span class="toc-text">Git Object Graph</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#General-process-of-software-construction"><span class="toc-text">General process of software construction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Programming"><span class="toc-text">Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Programming-Languages"><span class="toc-text">Programming Languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modeling-Languages"><span class="toc-text">Modeling Languages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Configuration-Languages"><span class="toc-text">Configuration Languages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Review-and-static-code-analysis"><span class="toc-text">Review and static code analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-code-analysis-profiling-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">Dynamic code analysis&#x2F; profiling 性能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debugging-and-Testing"><span class="toc-text">Debugging and Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refactoring-%E9%87%8D%E6%9E%84%EF%BC%9A%E4%B8%8D%E6%94%B9%E5%8F%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-text">Refactoring 重构：不改变功能的前提下优化代码</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/HIT%20Software%20Construction"><i class="tag post-item-tag">HIT Software Construction</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">软件构造笔记三：软件构造过程与配置管理</h1><time class="has-text-grey" datetime="2021-06-09T13:54:56.000Z">2021-06-09</time><article class="mt-2 post-content"><p><font color="red"><strong>重点掌握：软件开发过程与版本控制工具</strong></font></p>
<h1 id="Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）"><a href="#Software-Development-Life-Cycle-SDLC-软件开发生命圈（了解即可）" class="headerlink" title="Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）"></a>Software Development Life Cycle (SDLC) 软件开发生命圈（了解即可）</h1><p>从无到有，从有到好。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144052.jpg" alt="SDLC"></p>
<hr>
<h1 id="Traditional-Software-Process-Models"><a href="#Traditional-Software-Process-Models" class="headerlink" title="Traditional Software Process Models"></a>Traditional Software Process Models</h1><blockquote>
<p><strong>要求</strong></p>
<p>区别不同开发过程模型的异同</p>
<p>根据不同<em>场景</em>给出相应<em>模型</em></p>
</blockquote>
<ul>
<li><strong>线性过程 Linear</strong>：顺序，要求一点要明确，难以更改</li>
<li><strong>迭代过程 Iterative</strong>：每个阶段给用户反馈，用户需求不明确</li>
</ul>
<p><strong>选择合适模型依据</strong>：用户参与程度，适应变化能力，开发效率，管理复杂段，开发出的软件质量</p>
<h2 id="瀑布过程-Waterfall-Linear-non-interative"><a href="#瀑布过程-Waterfall-Linear-non-interative" class="headerlink" title="瀑布过程 Waterfall (Linear, non-interative)"></a>瀑布过程 Waterfall (Linear, non-interative)</h2><p>线性推进、阶段划分清楚、整体推进、无迭代、管理简单</p>
<p>$$<br>\begin{aligned} conception \Rightarrow initiation \Rightarrow analysis \Rightarrow design \Rightarrow construction \Rightarrow testing \Rightarrow implementation \Rightarrow verification \Rightarrow maintenance \end{aligned}<br>$$</p>
<p><strong>无法适应需求增加/变化(prohibitively costly)</strong></p>
<p>用户只在最后一个阶段看到？？</p>
<h2 id="增量过程-Incremental-non-iterative"><a href="#增量过程-Incremental-non-iterative" class="headerlink" title="增量过程 Incremental (non-iterative)"></a>增量过程 Incremental (non-iterative)</h2><p>线性推进、<strong>增量式（多个瀑布的串行</strong>、无迭代、比较容易适应需求的增加</p>
<p>系统切成小模块，每个模块/增量Waterfall，每个模块都要能运行，模块之间不影响，模块接口要简单，要求比较稳定。</p>
<h2 id="V字模型-V-Model-for-verification-and-validation"><a href="#V字模型-V-Model-for-verification-and-validation" class="headerlink" title="V字模型 V-Model (for verification and validation)"></a>V字模型 V-Model (for verification and validation)</h2><p><strong>瀑布模型的扩展开发，强调每个阶段测试</strong></p>
<p>瀑布阶段在code阶段之后向上弯曲，对 Life Cycle 的每个阶段及相关阶段进行测试。</p>
<h2 id="原型过程-Prototyping-iterative"><a href="#原型过程-Prototyping-iterative" class="headerlink" title="原型过程 Prototyping (iterative)"></a>原型过程 Prototyping (iterative)</h2><p><strong>迭代</strong>：开发出来之后由<strong>用户试用/评审</strong>，发现问题反馈给开发者，开发者修改原有的实现，继续交给用户评审。在这个过程中，<strong>用户需求不明确</strong>，循环往复这个过程，直到用户满意为止。时间代价高，但开发质量也高。</p>
<h2 id="螺旋模型-Spiral-iterative"><a href="#螺旋模型-Spiral-iterative" class="headerlink" title="螺旋模型 Spiral (iterative)"></a>螺旋模型 Spiral (iterative)</h2><ul>
<li><strong>适用于非常复杂的过程</strong></li>
<li><strong>多轮迭代基本遵循瀑布模式</strong> </li>
<li>每轮迭代有明确的目标，遵循“原型”过程，进行<strong>严格的风险分析</strong>，方可进入下一轮迭代</li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144113.jpg" alt="Spiral"></p>
<hr>
<h1 id="Agile-Development-敏捷开发"><a href="#Agile-Development-敏捷开发" class="headerlink" title="Agile Development 敏捷开发"></a>Agile Development 敏捷开发</h1><blockquote>
<p>敏捷开发：通过快速迭代和小规模的持续改进，以快速适应变化。短周期迭代。</p>
</blockquote>
<p>将任务划分成一个个小规模的任务，因此较小的团队也能够适应大规模软件的开发。在每个小步骤的迭代中，用户可以参与开发，软件可以随时修正，质量因此得到了保证。因此，敏捷开发是一次次小迭代，将任务细分成一个个小任务，在每个小任务上完成迭代。</p>
<p><strong>敏捷宣言 Agile Manifesto</strong></p>
<ul>
<li>个人和交互高于过程和工具</li>
<li>工作软件高于全面的文档（不需要文档）</li>
<li>客户合作高于合同谈判（客户参与）</li>
<li>应对变化高于遵循计划（快速适应变化）</li>
</ul>
<p>比原型模型更适应于满足客户需求，风险较低</p>
<p>$$<br>Agile = 增量 + 迭代 （每次迭代处理一个小规模增量）<br>$$</p>
<p><strong>极限编程 (XP, eXtreme Programming)</strong></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144130.jpg" alt="XP"></p>
<p>协作编程（两人编程）、测试驱动、测试与编程绑定</p>
<p>极限编程关注于测试驱动的开发(TDD)，自动化构建、持续集成、持续交付。</p>
<hr>
<h1 id="Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统"><a href="#Software-Configuration-Management-SCM-and-Version-Control-System-VCS-软件配置管理与版本控制系统" class="headerlink" title="Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统"></a>Software Configuration Management (SCM) and Version Control System (VCS) 软件配置管理与版本控制系统</h1><p>SCM 软件配置管理：追踪和控制软件的变化。</p>
<p>SCI (Software Configuration Item) 软件配置项: 软件中发生变化的基本单元（如文件）。</p>
<p>基线：软件持续变化过程中的“<strong>稳定</strong>时刻”（例如：对外发布的版本）。</p>
<p>CMDB：配置管理数据库（存储软件的各配置项随时间发生变化的信息+基线），分为<strong>本地和远程</strong></p>
<p><em>版本</em>：为软件的任一特定时刻（Moment）的形态指派一个唯一的编号，作为“身份标识”</p>
<h2 id="Why-version-control-is-required"><a href="#Why-version-control-is-required" class="headerlink" title="Why version control is required"></a>Why version control is required</h2><ul>
<li>for individuals<ol>
<li>Reverting to a past version 回滚到上一个版本</li>
<li>Comparing two different versions 比较两个版本的差异</li>
<li>Pushing full version history to another location 备份软件版本历史</li>
<li>Pulling history back from that location 获取备份</li>
<li>Merging versions that are offshoots of the same earlier version 合并</li>
</ol>
</li>
<li>for teamwork<ol>
<li>Communications and share/merge works among multiple developers 在多个开发者之间<strong>共享和协作</strong></li>
<li>Logging individualized works of different developers for auditing 记录每个开发者的动作，便于“审计”</li>
</ol>
</li>
</ul>
<h2 id="Version-control-terminology-版本控制术语"><a href="#Version-control-terminology-版本控制术语" class="headerlink" title="Version control terminology 版本控制术语"></a>Version control terminology 版本控制术语</h2><ul>
<li><strong>Repository</strong>: a local or remote store of the <strong>versions</strong> in a project 仓库：即于SCM（软件配置管理）中的CMDB（配置管理数据库）</li>
<li><strong>Working copy</strong>: a local, editable copy of a project that we can work on 工作拷贝：在<strong>开发者本地</strong>机器上的一份项目拷贝</li>
<li>File: a single file in the project 文件：一个独立的配置项</li>
<li>Version or revision: a record of the contents of the project at a point in time 版本：在某个特定时间点的所有文件的共同状态</li>
<li>Change or diff: the difference between two versions 变化：即code churn，两个版本之间的差异</li>
<li>Head: the current version <strong>HEAD</strong>：程序员正在其上工作的版本</li>
</ul>
<h2 id="Version-Control-System-VCS"><a href="#Version-Control-System-VCS" class="headerlink" title="Version Control System (VCS)"></a>Version Control System (VCS)</h2><p><strong>三类版本控制系统</strong></p>
<ul>
<li>Local VCS 本地版本控制系统</li>
<li><ul>
<li>仓库存储于开发者<strong>本地</strong>机器无法共享和协作。</li>
</ul>
</li>
<li>Centralized VCS（集中式版本控制系统）</li>
<li><ul>
<li>仓库存储于<strong>独立的服务器</strong>，支持多开发者之间的协作</li>
</ul>
</li>
<li>Distributed VCS（分布式版本控制系统）</li>
<li><ul>
<li>仓库存储于<strong>独立的服务器+每个开发者的本地</strong>机器</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><blockquote>
<p>版本图 <strong>&lt;–&gt;</strong> git命令</p>
<p>git文件状态 <strong>–&gt;</strong> 目录</p>
</blockquote>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144148.jpg" alt="gitManagement"></p>
<h2 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h2><blockquote>
<p><strong>创建</strong>本地仓库：git init</p>
<p>文件<strong>添加</strong>到本地仓库：git add <file></file></p>
<p>文件<strong>提交</strong>到本地仓库：git commit -m “commit message”</p>
<p>查看工作区状态：git status</p>
<p>比较差异修改：git diff</p>
<p>回到上一个版本：git reset –hard HEAD^</p>
<p>穿越到指定提交：git reset –hard <commit></commit></p>
<p>清空暂存区：git rm –cached</p>
<p>丢弃工作区更改: git checkout – <file></file></p>
<p>丢弃暂存区更改: git reset HEAD <file></file></p>
<p>丢弃本地版本库更改: git reset –hard HEAD^</p>
<p>添加远程仓库<strong>关联</strong>：git remote add origin <url></url></p>
<p>创建分支：git branch <branch name=""></branch></p>
<p>切换到分支：git checkout <branch name=""></branch></p>
<p>创建并切换分支：git checkout -b <branch name=""></branch></p>
<p>合并指定分支到当前分支：git merge <branch name="">: 如果是把一个做了更改的分支合并到一个未作更改的分支，那么就将未作更改的分支的<strong>指针移到做过更改分支的指针的位置</strong>。如果两个分支都做了更改，那么就找到更改的共同的祖先节点，以祖先节点为开始，将两个分支所有做出的<strong>更改都放在一起</strong>，在工作分支上形成一个<strong>新的节点</strong>。</branch></p>
<p>删除分支：git branch -d <branch name="">: 只是删除分支指针，没有删除在该分支上的commit</branch></p>
</blockquote>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144223.jpg" alt="gitBranch1"></p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144207.jpg" alt="gitBranch2"></p>
<blockquote>
<p>clone: git clone -b <btanch name=""> <url></url></btanch></p>
<p>git push -u origin master</p>
<p>git push <remote name=""> <branch name="">：远程端若更改后要先与本地端合并后才能push</branch></remote></p>
<p>git pull <remote name=""> <branch name="">: 从远程获取最新版本并merge到本地</branch></remote></p>
<p>git fetch <remote name=""> <branch name="">: 从远程获取最新版本到本地，不会自动merge</branch></remote></p>
</blockquote>
<h2 id="Git-repository"><a href="#Git-repository" class="headerlink" title="Git repository"></a>Git repository</h2><ul>
<li><strong>.git</strong> directory: <strong>本地</strong>的 CMDB（配置管理数据库）</li>
<li>Working directory 工作目录：本地文件系统</li>
<li>Staging area 暂存区：隔离工作目录和Git仓库</li>
</ul>
<ul>
<li>已修改 Modified: different between file in <strong>working directory</strong> and file in <strong>git directory</strong></li>
<li>已暂存 Staged: file added into staging area</li>
<li>已提交 Committed: file keep <strong>same in working directory and git directory</strong></li>
</ul>
<h2 id="Git-Object-Graph"><a href="#Git-Object-Graph" class="headerlink" title="Git Object Graph"></a>Git Object Graph</h2><p><strong>Object Graph: 版本演化关系图，是一个有向无环图。</strong></p>
<p><strong>A-&gt;B</strong>: 在版本B的基础上作出变化，形成了版本A</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144238.jpg" alt="ObjectGraph"></p>
<p>一个父对象可以有多个子对象（<strong>创建了分支</strong>）；除了initial commit没有父对象，一个子对象的父对象最多两个（<strong>合并分支</strong>）。</p>
<p>branch: a name that points to a commit</p>
<p>HEAD: pointing to the current commit</p>
<p>Git Object Graph 储单个文件的每个版本一次，并允许多次提交来共享该副本。若文件没有变化，则后续多个版本始终指向同一个文件；若文件发生变化了，存储两份不同的文件，两个版本指向不同的文件。</p>
<p>每个节点的存储的信息是文件信息指针tree、作者信息author、提交者信息commiter，而在每个tree中，包含所有文件的信息，对于每个文件指针，如果文件变化了，则指向变化后的新文件，如果没有变化，则指向上次提交的文件，不做重复存储。</p>
<ul>
<li>传统VCS：存储版本之间的变化（行）。优点：存储空间较小。缺点：由于存储的是变化情况，取出指定时期的文件要先取出原文件，再取出变化内容，最后做合并形成新文件，所以取出文件的时间复杂度较高。</li>
<li>Git：存储发生变化的文件（而非代码行），不变化的文件不重复存储，这样易于取出特定版本文件、易于创建分支（创建分支时，需要进行叠加来获得当前版本）。缺点：空间复杂度增加。</li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144247.jpg" alt="VCS"></p>
<hr>
<h1 id="General-process-of-software-construction"><a href="#General-process-of-software-construction" class="headerlink" title="General process of software construction"></a><em>General</em> process of software construction</h1><p>$$<br>\begin{aligned} General process of software construction 广义软件构造过程: Design \Rightarrow Programming/refactoring \Rightarrow Debugging \Rightarrow Testing \Rightarrow Build \Rightarrow Release \end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned} Narrow-sense process of software construction (Build) 狭义软件构造过程build: Validate \Rightarrow Compile \Rightarrow Link \Rightarrow Test \Rightarrow Package \Rightarrow Install \Rightarrow Deploy \end{aligned}<br>$$</p>
<h2 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h2><ul>
<li><strong>Construction Languages</strong></li>
<li><strong>purpose 用途上划分</strong><ol>
<li>Programming languages (e.g., C, C++, Java, Python) 编程语言</li>
<li>Modeling languages (e.g., UML) 建模语言</li>
<li>Configuration languages (e.g., XML) 配置语言</li>
<li>Build languages (e.g., XML) 构建语言</li>
</ol>
</li>
<li><strong>form 形态上划分</strong><ol>
<li>Linguistic-based 基于语言学的构造语言</li>
<li>Mathematics-based (formal) 基于数学的形式化构造语言</li>
<li>Graphics-based (visual) 基于图形的可视化构造语言</li>
</ol>
</li>
</ul>
<h3 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h3><p><strong>IDE 集成开发环境</strong>包括</p>
<ul>
<li><strong>Source code editor</strong> with intelligent code completion, code refactoring tool 源代码编辑器：智能代码补全工具、代码重构工具</li>
<li>File management tool 文件管理</li>
<li>Library management tool 库管理</li>
<li>Class browser, object browser, class hierarchy diagram 软件逻辑实体可视化</li>
<li>Graphical User Interface (<strong>GUI</strong>) builder 图形化用户界面构造器</li>
<li>Compiler, interpreter 编译器、解释器</li>
<li>Build automation tools 自动化build工具</li>
<li>Version control system 版本控制系统</li>
<li>Extensible by more external third-party tools 外部的第三方工具</li>
</ul>
<h3 id="Modeling-Languages"><a href="#Modeling-Languages" class="headerlink" title="Modeling Languages"></a>Modeling Languages</h3><p>目的：可视化、推理、验证和交流系统的设计。</p>
<p>e.g. UML (Unified Modeling Language)</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718144300.jpg" alt="UMLClassDiagram"></p>
<h3 id="Configuration-Languages"><a href="#Configuration-Languages" class="headerlink" title="Configuration Languages"></a>Configuration Languages</h3><p>e.g. XML, YAML, JSON</p>
<h2 id="Review-and-static-code-analysis"><a href="#Review-and-static-code-analysis" class="headerlink" title="Review and static code analysis"></a>Review and <em>static</em> code analysis</h2><h2 id="Dynamic-code-analysis-profiling-性能测试"><a href="#Dynamic-code-analysis-profiling-性能测试" class="headerlink" title="Dynamic code analysis/ profiling 性能测试"></a>Dynamic code analysis/ profiling 性能测试</h2><h2 id="Debugging-and-Testing"><a href="#Debugging-and-Testing" class="headerlink" title="Debugging and Testing"></a>Debugging and Testing</h2><h2 id="Refactoring-重构：不改变功能的前提下优化代码"><a href="#Refactoring-重构：不改变功能的前提下优化代码" class="headerlink" title="Refactoring 重构：不改变功能的前提下优化代码"></a>Refactoring 重构：不改变功能的前提下优化代码</h2></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/06/13/CSAPP-Chapter09/" title="CSAPP Chapter09"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: CSAPP Chapter09</span></a><a class="button is-default" href="/2021/06/08/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="软件构造笔记二：软件测试与测试优先编程"><span class="has-text-weight-semibold">Next: 软件构造笔记二：软件测试与测试优先编程</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/FuLucas"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> FuLucas 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>