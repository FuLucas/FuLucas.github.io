<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>CSAPP Chapter09</title><meta name="description" content="Shifting eyes and vacancy coming."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。
本章的前一部分描述虚拟内存工作原理，后一部分描述应用程序如何使用和管理虚拟内存。

9.1 物理和虚拟寻址**物理寻址 (physical addressing)**：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address, PA).
物理地址应用：早期的PC，而诸如数字信号处理器、嵌入式微控制器（汽车、电梯、数字图像帧等）以及Cray超级计算机仍然继续使用这种寻址方式。

**虚拟寻址 (virtual addressing)**：CPU 通过生成一个虚拟地址 (Virtual Address, VA)来访问.."><meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">FuLucas's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CSAPP Chapter09</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#9-1-%E7%89%A9%E7%90%86%E5%92%8C%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="toc-text">9.1 物理和虚拟寻址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-text">9.2 地址空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7"><span class="toc-text">9.3 虚拟内存作为缓存工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-1-DRAM-%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-text">9.3.1 DRAM 缓存的组织结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-2-%E9%A1%B5%E8%A1%A8"><span class="toc-text">9.3.2 页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-3-%E9%A1%B5%E5%91%BD%E4%B8%AD-Page-Hit"><span class="toc-text">9.3.3 页命中 Page Hit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-4-%E7%BC%BA%E9%A1%B5-Page-Fault"><span class="toc-text">9.3.4 缺页 Page Fault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-5-%E5%88%86%E9%85%8D%E9%A1%B5%E9%9D%A2"><span class="toc-text">9.3.5 分配页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-6-%E5%B1%80%E9%83%A8%E6%80%A7"><span class="toc-text">9.3.6 局部性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">9.4 虚拟内存作为内存管理的工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">9.5 虚拟内存作为内存保护的工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-6-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-text">9.6 地址翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-1-%E7%BB%93%E5%90%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">9.6.1 结合高速缓存和虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-2-%E5%88%A9%E7%94%A8-TLB-%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-text">9.6.2 利用 TLB 加速地址翻译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-3-%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">9.6.3 多级页表</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CSAPP Chapter09</h1><time class="has-text-grey" datetime="2021-06-12T18:31:39.000Z">2021-06-13</time><article class="mt-2 post-content"><blockquote>
<p><strong>虚拟内存</strong>是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。</p>
<p>本章的前一部分描述<strong>虚拟内存工作原理</strong>，后一部分描述<strong>应用程序如何使用和管理虚拟内存</strong>。</p>
</blockquote>
<h1 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h1><p>**物理寻址 (physical addressing)**：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address, PA).</p>
<p><strong>物理地址应用</strong>：早期的PC，而诸如数字信号处理器、嵌入式微控制器（汽车、电梯、数字图像帧等）以及Cray超级计算机仍然继续使用这种寻址方式。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104257.jpg" alt="PhysicalAddressing"></p>
<p>**虚拟寻址 (virtual addressing)**：CPU 通过生成一个虚拟地址 (Virtual Address, VA)来访问主存，这<br>个虚拟地址在被送到内存之前先转换成适当的物理地址。</p>
<p>**地址翻译 (address translation)**：个虚拟地址转换为物理地址</p>
<p>**内存管理单元 (Memory Management Unit, MMU)**：利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104330.jpg" alt="VirtualAddressing"></p>
<h1 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h1><ul>
<li>**地址空间 (address space)**：非负整数地址的有序集合 $$ { 0, 1, 2, … } $$</li>
<li>**线性地址空间 (linear address space)**：地址空间中的整数是连续的</li>
<li>**虚拟地址空间 (virtual address space)**：$$ N = 2^n $$ 个虚拟地址的集合，现代系统通常支持32位或者64位虚拟地址空间<br>$$ { 0, 1, 2, … ,  N-1 } $$</li>
<li>**物理地址空间 (physical address space)**：$$ M = 2^m $$ 个（不要求，但假设）物理地址的集合<br>$$ { 0, 1, 2, … ,  M-1 } $$</li>
</ul>
<p><strong>虚拟地址思想</strong>：允许每个数据对象有多个独立的地址，每个地址都选自一个不同的地址空间。</p>
<hr>
<h1 id="9-3-虚拟内存作为缓存工具"><a href="#9-3-虚拟内存作为缓存工具" class="headerlink" title="9.3 虚拟内存作为缓存工具"></a>9.3 虚拟内存作为缓存工具</h1><p>虚拟内存被组织为一个由存放在<strong>磁盘</strong>上的 N 个连续的字节大小的单元组成的<strong>数组</strong>。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被<strong>缓存在主存</strong>中。</p>
<p>VM 系统通过将虚拟内存分割为称为<strong>虚拟页</strong> (Virtual Page, VP)的大小固定的块来作为磁盘（低层）和主存（高层）之间的<strong>传输单元</strong>，页面大小 $$ P = 2^p 字节 $$<br>相似地，物理内存也分为<strong>物理页</strong> (Physical Page, PP)，大小也为 $$ P 字节 $$ 物理页也被称为<strong>页帧</strong>。</p>
<table>
  <tbody><tr>
    <td colspan="2">虚拟页面三种状态</td>
  </tr>
  <tr>
    <td>未分配</td> 
    <td>VM 系统还未分配(或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间（虚拟页也是根据需要创建的）。</td>
  </tr>
  <tr>
    <td>已缓存</td> 
    <td>当前已缓存在物理内存中的已分配页。</td>
  </tr>
  <tr>
    <td>未缓存</td> 
    <td>当未缓存在物理内存中的已分配页。</td>
  </tr>
</tbody></table>


<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104426.jpg" alt="example1"></p>
<p><strong>使用虚拟内存优点</strong></p>
<ul>
<li>有效使用主存：使用DRAM作为作为部分虚拟地址空间的缓存</li>
<li>简化内存管理：每个进程都使用统一的线性地址空间</li>
<li>独立空间地址：一个进程不能影响其他进程内存，用户程序无法获得特权内核信息和代码</li>
</ul>
<h2 id="9-3-1-DRAM-缓存的组织结构"><a href="#9-3-1-DRAM-缓存的组织结构" class="headerlink" title="9.3.1 DRAM 缓存的组织结构"></a>9.3.1 DRAM 缓存的组织结构</h2><p>DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。DRAM比SRAM要慢大约10倍，而磁盘要比DRAM慢大约100000多倍。</p>
<p>由于大的不命中处罚和访问第一个字节开销：<strong>虚拟页尺寸</strong>通常是4KB~4MB</p>
<p>由于大的不命中处罚，<strong>DRAM 缓存全相联</strong><br>任何虚拟页都可以放置在任何的物理页中。？？？？？？？？？？？？？<br>需要一个更大的映射函数，不同于硬件对SRAM缓存</p>
<p>硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。</p>
<p>DRAM 缓存总是<strong>使用写回，而不是直写</strong>。</p>
<h2 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h2><p>虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到 DRAM 中，替换这个牺牲页。</p>
<p><strong>页表将虚拟页映射到物理页</strong>：页表就是一个页表条目 (Page Table Entry, PTE)的数组，将虚拟页地址映射到物理页地址。每个页在页表中一个固定偏移量处都有一个 PTE。</p>
<p>我们将假设每个 PTE 是由一个<strong>有效位 (valid bit)<strong>和一个</strong>n位地址</strong>字段组成的。<strong>有效位</strong>表明了该虚拟页当前<em>是否被缓存在 DRAM</em> 中。</p>
<ul>
<li>有效位1，地址字段表示 DRAM 中相应的物理页的起始位置，<strong>这个物理页中缓存了该虚拟页</strong>。</li>
<li>有效位0，那么一个空地址表示这个虚拟页还未被分配。</li>
<li>有效位0，地址不为空，这个地址就指向该虚拟页在磁盘上的起始位置。</li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105342.jpg" alt="PageTable"></p>
<p>$$ PTE数量 = 2^n \div P $$ 其中，n 为虚拟地址大小，P 为页大小。</p>
<h2 id="9-3-3-页命中-Page-Hit"><a href="#9-3-3-页命中-Page-Hit" class="headerlink" title="9.3.3 页命中 Page Hit"></a>9.3.3 页命中 Page Hit</h2><p><strong>页命中</strong>：虚拟内存中的一个字存在于物理内存中 (DRAM缓存命中)。虚拟地址 <strong>-&gt;</strong> 定位PTE <strong>-&gt;</strong> 从内存读取</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104837.jpg" alt="PageHit"></p>
<h2 id="9-3-4-缺页-Page-Fault"><a href="#9-3-4-缺页-Page-Fault" class="headerlink" title="9.3.4 缺页 Page Fault"></a>9.3.4 缺页 Page Fault</h2><p><strong>缺页</strong>：引用虚拟内存中的字，不在物理内存中 (DRAM 缓存不命中)。</p>
<p><strong>缺页处理</strong>：关键是按需<em>页面调度/交换</em>，当有不命中时页从磁盘<em>换入</em>（或者页面<em>调入</em>）DRAM 和从 DRAM <em>换出</em>（或者页面<em>调出</em>）磁盘。</p>
<ol>
<li>从有效位判断未缓存，触发缺页异常</li>
<li>调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，牺牲页如果已经被修改则复制回磁盘。</li>
<li>内核从磁盘复制 VP 到内存中的 PP, 更新 PTE，随后返回</li>
<li>重新启动导致缺页的指令，命中！</li>
</ol>
<table>
<thead>
<tr>
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104858.jpg" alt="PageFault1"></th>
<th><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104910.jpg" alt="PageFault2"></th>
</tr>
</thead>
</table>
<h2 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h2><p>操作系统分配一个新的虚拟页面（如malloc结果），内核在磁盘上分配 VP5，将 PTE5 指向这个新创建的页面。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718104927.jpg" alt="AllocatePage"></p>
<h2 id="9-3-6-局部性"><a href="#9-3-6-局部性" class="headerlink" title="9.3.6 局部性"></a>9.3.6 局部性</h2><ul>
<li>虚拟内存看上去效率低，但是工作相当好，归功于“局部性”。</li>
<li>程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个<strong>较小的活动页面(active page)集合</strong>上工作，这个集合叫做**工作集(working set)或者常驻集合(resident set)**。程序的局部性越好，工作集越小。</li>
<li><strong>工作集大小 &lt; 物理内存大小</strong>：初始开销，即将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。</li>
<li><strong>工作集大小 &gt; 物理内存大小</strong>：**抖动（thrashing)**页面不断换进换出，导致程序性能暴跌。</li>
</ul>
<hr>
<h1 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h1><p><strong>核心思想</strong>：每个进程都拥有独立的虚拟地址空间。</p>
<ul>
<li><strong>简化链接</strong><ul>
<li>每个程序都有相似的虚拟地址空间</li>
<li>代码、数据和堆都使用相同的起始地址</li>
<li>每个进程的内存映像使用相同的基本格式，这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</li>
</ul>
</li>
<li><strong>简化加载</strong><ul>
<li>Linux 加载器 (execve)为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的）将页表条目指向目标文件中适当的位置。</li>
<li>每个页面被初次引用时，虚拟内存系统会按照需要自动的调入数据页。</li>
</ul>
</li>
<li><strong>简化内存分配</strong><ul>
<li>当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc），操作系统分配一个适当数字，如k个连<strong>续的虚拟内存页面</strong>，并且将它们映射到物理内存中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配是个连续的物理内存页面。物理页面可以随机地分散在物理内存中。</li>
<li>每个虚拟内存页面都要映射到一个物理页面</li>
<li>一个虚拟内存页面每次可以分配到不同的物理页面</li>
</ul>
</li>
<li><strong>简化共享</strong><ul>
<li>不同的虚拟页面映射到相同的物理页面</li>
<li>一般来讲还是需要进程共享代码和数据，而不是给每个进程创建完全私有的代码、数据、堆以及栈区域</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105003.jpg" alt="Management"></p>
<hr>
<h1 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h1><p>在PTE（页表条目）上扩展<strong>许可位</strong>来控制对一个虚拟页面内容的访问，内存管理单元 (MMU) 每次访问数据都要检查许可位。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105024.jpg" alt="Protection"></p>
<p>如图所示三个许可位：SUP 位表示进程是否必须运行在内核(超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和 WRITE 位控制对页面的读和写访问。</p>
<hr>
<h1 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h1><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105038.jpg" alt="symbols"></p>
<p>地址翻译是一个 iV 元素的虚拟地址空间（VAS)中的元素和一个 M 元素的物理地址空间(PAS)中元素之间的映射:<br>$$<br>MAP:VAS \rightarrow PAS \bigcup \emptyset<br>$$</p>
<p>$$<br>MAP(A)=\left{<br>  \begin{matrix}<br>    A’, 虚拟地址A处的数据在PAS的物理地址A’处 \<br>    \emptyset, 虚拟地址A处的数据不在物理内存中<br>  \end{matrix}<br>  \right.<br>$$</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105055.jpg" alt="AddressTranslationBasedOnPageTable"></p>
<p>CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register, PTBR)指向当前页表。n 位的虚拟地址包含两个部分：一个 p 位的<strong>虚拟页面偏移</strong>(Virtual Page Offset，VPO)和一个(n-p)位的<strong>虚拟页号</strong>(Virtual Page Number, VPN)。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0, VPN 1选择 PTE 1，以此类推。将页表条目中<strong>物理页号</strong>(Physical Page Number, PPN)和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。注意，因为<em>物理和虚拟页面都是 P 字节</em>的，所以物理页面偏移(Physical Page Offset, PPO)和 VPO 是相同的。</p>
<p><strong>地址翻译：页面命中</strong></p>
<ol>
<li>处理器生成一个虚拟地址，并把它传送给 MMU。</li>
<li>MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。<ul>
<li>PTE 地址(PTEA)：**%CR3 + 页号 * 字节数**</li>
</ul>
</li>
<li>高速缓存/主存向 MMU 返回 PTE。</li>
<li>MMU 构造物理地址，并把它传送给高速缓存/主存。</li>
<li>高速缓存/主存返回所请求的数据字给处理器。</li>
</ol>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105258.jpeg"></p>
<p><strong>地址翻译：缺页异常</strong></p>
<ol>
<li>处理器生成一个虚拟地址，并把它传送给 MMU。</li>
<li>MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。<ul>
<li>PTE 地址(PTEA)：**%CR3 + 页号 * 字节数**</li>
</ul>
</li>
<li>高速缓存/主存向 MMU 返回 PTE。</li>
<li>PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘（写回策略）。</li>
<li>缺页处理程序页面调入新的页面，并更新内存中的 PTE。</li>
<li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令。</li>
</ol>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105244.jpg" alt="TranslationPageFault"></p>
<h2 id="9-6-1-结合高速缓存和虚拟内存"><a href="#9-6-1-结合高速缓存和虚拟内存" class="headerlink" title="9.6.1 结合高速缓存和虚拟内存"></a>9.6.1 结合高速缓存和虚拟内存</h2><p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105123.jpg" alt="CacheAndMemory"></p>
<h2 id="9-6-2-利用-TLB-加速地址翻译"><a href="#9-6-2-利用-TLB-加速地址翻译" class="headerlink" title="9.6.2 利用 TLB 加速地址翻译"></a>9.6.2 利用 <strong>TLB</strong> 加速地址翻译</h2><p>页表条目 (PTEs) 与其他内存数据字一样缓存在 L1中。每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE, 以便将虚拟地址翻译为物理地址。</p>
<ul>
<li>PTE可能被其他数据引用所替换/驱逐，导致不命中，从内存多取一次数据，代价是几十到几百个周期。</li>
<li>PTE 碰巧缓存在 L1 中（Cache 命中），那么开销仍需要 1~2 个周期。</li>
</ul>
<p><strong>翻译后备缓冲器 (Translation Lookaside Buffer, TLB)<strong>：MMU中一个小的具有</strong>高相联度</strong>的存储集合。</p>
<p>用于<strong>组选择和行匹配</strong>的索引和标记字段是从虚拟地址中的<strong>虚拟页号</strong>中提取出来的。如果 TLB 有： $$ T = 2^t $$ 个组，那么 TLB 索引(TLBI)是由 VPN 的 t 个最低位组成的，而 TLB 标记(TLBT)是由 VPN 中剩余的位组成的。</p>
<ol>
<li><p>CPU 产生一个虚拟地址.</p>
</li>
<li><p>MMU 根据 VPN 标记索引</p>
</li>
<li><p>从 TLB 中取出相应的 PTE</p>
</li>
</ol>
<p>  <img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105203.jpg" alt="VPNTLBPTE"></p>
<ol start="4">
<li><p>MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</p>
</li>
<li><p>高速缓存/主存将所请求的数据字返回给 CPU。</p>
</li>
</ol>
<p>当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。因为局部性，TLB不命中很少发生。</p>
<p><img src="https://gitee.com/ifu18/blog-image/raw/master/2021/20210718105220.jpg" alt="TLB"></p>
<h2 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h2></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/06/24/CSAPP-FinalHomeWork/" title="CSAPP FinalHomeWork"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: CSAPP FinalHomeWork</span></a><a class="button is-default" href="/2021/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%AC%94%E8%AE%B0%E4%B8%89/" title="软件构造笔记三：软件构造过程与配置管理"><span class="has-text-weight-semibold">Next: 软件构造笔记三：软件构造过程与配置管理</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/FuLucas"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> FuLucas 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>